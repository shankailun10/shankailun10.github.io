# leetcode题解
1. TOC
{:toc}

## 101. 对称二叉树
题目：给定一个二叉树，检查它是否是镜像对称的。
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归

#### 2. 非递归
思路：判断根是否为空，是返回True, 否判断左右两个孩子是否相等，是继续判断左孩子的左节点和右孩子的右节点是否相等，以及左孩子的右节点和右孩子的左节点是否相等

    #队列代码
    def getRes(root):
        if not root:
            return True
        queue = [(root.left, root.right)]
        while queue != []:
            left, right = queue.pop()
            if not left and not right:
                continue
            if left and right and left.val == right.val:
                queue.append((left.left, right.right))
                queue.append((left.right, right.left))
            else:
                return False
        return True
        
## 102. 二叉树的层序遍历
题目：给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1、递归

#### 2. 非递归
思路：若根为空，返回[]，若根不空将根入队列queue，然后依次遍历队列中的节点值存入res，然后依次遍历队列中的节点，把该节点的左节点、右节点依次入子队列l1，将子队列l1赋值给queue,返回res。

    # 代码
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        res, queue = [], [root]
        while queue:
            res.append([q.val for q in queue])
            l1 = []
            for q in queue:
                if q.left:
                    l1.append(q.left)
                if q.right:
                    l1.append(q.right)
            queue = l1
        return res
        

## 100. 相同的树
题目：给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
### 两种方法：1、递归实现，2. 非递归实现(队列)
####1. 递归
思路：比较根节点是否相等，然后递归比较左子树节点和右子树节点是否相等。

    # 代码
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        if not p and not q:
            return True
        elif not p or not q:
            return False
        elif p.val != q.val:
            return False
        else:
            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)

####2. 非递归
思路：同时遍历两棵树，依次比较节点值，若当前左子树或右子树为空时也入队列。

## 104. 二叉树最大深度
给定一个二叉树，找出其最大深度。
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明: 叶子节点是指没有子节点的节点。
### 两种方法：1、递归实现，2. 非递归实现(队列)
####1. 递归
思路：若根为空，返回0，若根不空，则最大深度为左子树最大深度和右子树最大深度取最大值+1

    # 代码
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        l = self.maxDepth(root.left)
        r = self.maxDepth(root.right)
        return max(l, r) + 1

### 2. 非递归
思路：二叉树层次遍历，返回数组长度。

## 108. 将有序数组转换为二叉搜索树
题目：给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。
高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：取数组中间位置做根，中间位置的左边部分构建左子树，右边部分构建右子树。

    # 代码
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        def mark_tree(s, e):
            if s > e:
                return None
            mid = (s + e) // 2
            sub_tree = TreeNode(nums[mid])
            sub_tree.left = mark_tree(s, mid - 1)
            sub_tree.right = mark_tree(mid + 1, e)
            return sub_tree
        return mark_tree(0, len(nums) - 1)

#### 2. 非递归
思路：

## 110. 平衡二叉树
题目：给定一个二叉树，判断它是否是高度平衡的二叉树。
本题中，一棵高度平衡二叉树定义为：
一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：若根为空，返回True,判断根的左右子树高度差绝对值是否<=1，否：返回False,依次判断根的左子树、右子树是否是平衡树

    # 代码
    def isBalanced(self, root: TreeNode) -> bool:
        def maxDepth(node):
            if not node:
                return 0
            l = maxDepth(node.left)
            r = maxDepth(node.right)
            return max(l, r) + 1

        if not root:
            return True
        return abs(maxDepth(root.left) - maxDepth(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)

#### 2. 非递归
思路：

## 111. 二叉树的最小深度
题目：给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。说明：叶子节点是指没有子节点的节点。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：层序遍历二叉树，记录深度，遇到某个节点没有左子树或右子树直接返回深度即可。

    # 代码
    def minDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        queue = [root]
        depth = 1
        while queue:
            l1 = []
            for q in queue:
                if not q.left and not q.right:
                    return depth
                if q.left:
                    l1.append(q.left)
                if q.right:
                    l1.append(q.right)
            queue = l1
            depth += 1
        return depth

#### 2. 非递归
思路：

## 112. 路径总和
题目：给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：深度优先遍历，判断当前节点是否是叶子结点并且路径和是否等于给定值，若是则返回true,否则返回false

    # 代码
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if not root:
            return targetSum == 0

        if not root.left and not root.right and root.val == targetSum:
            return True
        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)

#### 2. 非递归
思路：

## 144. 二叉树的前序遍历
题目：给你二叉树的根节点 root ，返回它节点值的 前序 遍历。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：深度优先遍历，一次打印节点值

    # 代码
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        
        res = []

        def dfs(node):
            if not node:
                return None
            res.append(node.val)
            dfs(node.left)
            dfs(node.right)
        
        dfs(root)
        return res

#### 2. 非递归
思路：

## 144. 二叉树的后序遍历
题目：给定一个二叉树，返回它的 后序 遍历。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：深度优先遍历，一次打印节点值

    # 代码
    def postorderTraversal(self, root: TreeNode) -> List[int]:

        res = []

        def dfs(node):
            if not node:
                return
            dfs(node.left)
            dfs(node.right)
            res.append(node.val)
        
        dfs(root)
        return res

#### 2. 非递归
思路：

## 226. 翻转二叉树
题目：翻转一棵二叉树。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：递归遍历根节点，交换左右节点值，遍历左子树，遍历🈶右子树，返回根节点。

    # 代码
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return None
        root.left, root.right = root.right, root.left
        self.invertTree(root.left)
        self.invertTree(root.right)
        return root

#### 2. 非递归
思路：



## 235. 二叉搜索树的最近公共祖先
题目：给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：由于是二叉搜索树，最近公共祖先的值一定在p,q值的中间，因此可遍历二叉搜索树，寻找在中间的节点。

    # 代码
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if p.val < root.val and q.val < root.val:
            return self.lowestCommonAncestor(root.left, p, q)
        elif p.val > root.val and q.val >root.val:
            return self.lowestCommonAncestor(root.right, p, q)
        else:
            return root

#### 2. 非递归
思路：

## 257. 二叉树的所有路径
题目：给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。叶子节点 是指没有子节点的节点。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：深度优先遍历，遍历时记录当前路径即可。

    # 代码
    def binaryTreePaths(self, root: TreeNode) -> List[str]:

        res = []
    
        def dfs(root, path):
            if not root:
                return
            if not root.left and not root.right:
                path += (str(root.val))
            else:
                path += (str(root.val) + '->')
            if not root.left and not root.right:
                res.append(path)
            dfs(root.left, path)
            dfs(root.right, path)
        
        dfs(root, '')
        return res

#### 2. 非递归
思路：

## 404. 左叶子之和
题目：计算给定二叉树的所有左叶子之和。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：深度优先遍历，遍历时记录当前路径即可。

    # 代码
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        
        self.num = 0

        def dfs(root, flag):
            if not root:
                return
            if not root.left and not root.right and flag == 1:
                self.num += root.val
            dfs(root.left, 1)
            dfs(root.right, 0)
        
        dfs(root, 0)
        
        return self.num

#### 2. 非递归
思路：

## 501. 二叉搜索树中的众数
题目：给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。
假定 BST 有如下定义：
结点左子树中所含结点的值小于等于当前结点的值
结点右子树中所含结点的值大于等于当前结点的值
左子树和右子树都是二叉搜索树
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：中序遍历，边遍历边记录当前出现最大值即可。

    # 代码
    def findMode(self, root: TreeNode) -> List[int]:

        self.res = []
        self.pre = None  # 前一个节点
        self.current_count = 0 # 当前节点重复数量
        self.max_count = 0 # 当前最大数量

        def dfs(root):
            if not root:
                return 
            dfs(root.left)
            if self.pre and self.pre.val == root.val:
                self.current_count += 1
            else:
                self.current_count = 1
            self.pre = root
            if self.current_count == self.max_count:
                self.res.append(root.val)
            elif self.current_count > self.max_count:
                self.max_count = self.current_count
                self.res.clear()
                self.res.append(root.val)

            dfs(root.right)
        
        dfs(root)
        return self.res

#### 2. 非递归
思路：

## 530. 二叉搜索树的最小绝对差
题目：给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：中序遍历，拿当前节点和前一节点比较求出最小值即可。

    # 代码
    def getMinimumDifference(self, root: TreeNode) -> int:

        value = float('inf')
        pre = None

        def dfs(root):
            nonlocal value, pre
            if not root:
                return 
            dfs(root.left)
            if pre and abs(pre.val - root.val) < value:
                value = abs(pre.val - root.val)
            pre = root
            dfs(root.right)

        dfs(root)
        return value

#### 2. 非递归
思路：

## 543. 二叉树的直径
题目：给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：求以每个节点为根节点的最大高度，记录最大值即可。

    # 代码
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        max_v = 0

        def depth(root):
            nonlocal max_v
            if not root:
                return 0
            l = depth(root.left)
            r = depth(root.right)
            max_v = max(max_v, l+r+1)
            return max(l, r) + 1

        depth(root)
        return max_v-1

#### 2. 非递归
思路：

## 559. N 叉树的最大深度
题目：给定一个 N 叉树，找到其最大深度。最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。
N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：若根为空，返回高度为0，若根的所有children子节点为空（根是叶子节点），返回高度为1；递归求出每一个子节点树的高度，得出最大值即可。

    # 代码
    def maxDepth(self, root: 'Node') -> int:

        def dfs(root):
            nonlocal max_d
            if not root:
                return 0
            if not root.children:
                return 1
            height = []
            for cl in root.children:
                height.append(dfs(cl))
            return max(height) + 1

        max_d = dfs(root)
        return max_d

#### 2. 非递归
思路：

## 563. 二叉树的坡度
题目：给定一个二叉树，计算 整个树 的坡度 。
一个树的 节点的坡度 定义即为，该节点左子树的节点之和和右子树节点之和的 差的绝对值 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。
整个树 的坡度就是其所有节点的坡度之和。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：求以某个节点为根节点的的树的值总和，即左节点总和+右节点总和+自身值，其中，左节点总和和右节点总和差的绝对值即为当前节点的坡度，对所有节点求坡度然后做加和即为树的坡度。

    # 代码
    def findTilt(self, root: TreeNode) -> int:
        res = 0

        # 求以某个节点为根的总和
        def getNodeSum(root):
            nonlocal res
            if not root:
                return 0
            ls = getNodeSum(root.left)
            rs = getNodeSum(root.right)
            res += abs(ls - rs)
            return ls+rs+root.val

        getNodeSum(root)

        return res

#### 2. 非递归
思路：

## 572. 另一棵树的子树
题目：给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。
二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：遍历root每一个节点，以每个子节点树为根判断是否是相同的树。

    # 代码
    def isSubtree(self, root: TreeNode, subRoot: TreeNode) -> bool:

        # 以p, q 为根节点的两颗二叉树是否为相同的树
        def isSambleTree(p, q):
            if not p and not q:
                return True
            elif not q or not p:
                return False
            elif p.val != q.val:
                return False
            else:
                return isSambleTree(p.left, q.left) and isSambleTree(p.right, q.right)
        
        # 遍历root树，并判断是否为相同的树
        def dfs(root, subRoot):
            if not root and not subRoot:
                return True
            if not root or not subRoot:
                return False
            else:
                return isSambleTree(root, subRoot) or dfs(root.left, subRoot) or dfs(root.right, subRoot)

        # 法2
        def dfs2(root, subRoot):
            if not root:
                return False
            if root.val == subRoot.val:
                if isSambleTree(root, subRoot):
                    return True
        
            return dfs2(root.left, subRoot) or dfs2(root.right, subRoot)
        
        return dfs2(root, subRoot)

#### 2. 非递归
思路：

## 589. N 叉树的前序遍历
题目：给定一个 N 叉树，返回其节点值的 前序遍历 。N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。
进阶：递归法很简单，你可以使用迭代法完成此题吗?
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：依次遍历即可。

    # 代码
    def preorder(self, root: 'Node') -> List[int]:
        res = []

        def dfs(root):
            nonlocal res
            if not root:
                return 
            res.append(root.val)
            for cl in root.children:
                dfs(cl)
        
        dfs(root)
        return res


#### 2. 非递归
思路：

## 590. N 叉树的后序遍历
题目：给定一个 N 叉树，返回其节点值的 后序遍历 。N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。
进阶：递归法很简单，你可以使用迭代法完成此题吗?
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：依次遍历即可。

    # 代码
    def postorder(self, root: 'Node') -> List[int]:

        res = []

        def dfs(root):
            nonlocal res
            if not root:
                return 
            for cl in root.children:
                dfs(cl)
            res.append(root.val)

        dfs(root)
        return res


#### 2. 非递归
思路：

## 617. 合并二叉树
题目：给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。
你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：依次遍历即可。

    # 代码
    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:

        def dfs(root1, root2):
            if root1 and root2:
                root = TreeNode(root1.val + root2.val)
                root.left = dfs(root1.left, root2.left)
                root.right = dfs(root1.right, root2.right)
            elif root1:
                root = TreeNode(root1.val)
                root.left = dfs(root1.left, None)
                root.right = dfs(root1.right, None)
            elif root2:
                root = TreeNode(root2.val)
                root.left = dfs(root2.left, None)
                root.right = dfs(root2.right, None)
            else:
                root = None
                return 
            return root

        return dfs(root1, root2)


#### 2. 非递归
思路：

## 637. 二叉树的层平均值
题目：给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：层序遍历，求每层平均值即可。

    # 代码
    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:

        res = []
        queue = [root]
        while queue:
            res.append(sum([q.val for q in queue]) / len([q.val for q in queue]))
            l1 = []
            for q in queue:
                if q.left:
                    l1.append(q.left)
                if q.right:
                    l1.append(q.right)
            queue = l1
        return res


#### 2. 非递归
思路：

## 653. 两数之和 IV - 输入 BST
题目：给定一个二叉搜索树 root 和一个目标结果 k，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：层序遍历，求每层平均值即可。

    # 代码
    def findTarget(self, root: TreeNode, k: int) -> bool:

        res = []

        def dfs(root):
            nonlocal res
            if not root:
                return
            dfs(root.left)
            res.append(root.val)
            dfs(root.right)

        dfs(root)

        l, r = 0, len(res)-1
        while l < r:
            if res[l] + res[r] == k:
                return True
            elif res[l] + res[r] > k:
                r -= 1
            else:
                l += 1
        return False

#### 2. 非递归
思路：

## 671. 二叉树中第二小的节点
题目：给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。
更正式地说，root.val = min(root.left.val, root.right.val) 总成立。给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 前序遍历，找到第一个不等于根节点的值返回即可。

    # 代码
    def findSecondMinimumValue(self, root: TreeNode) -> int:
        min_v = root.val

        def dfs(root):
            if not root:
                return float('inf')
            if root.val != min_v:
                return root.val
            else:
                return min(dfs(root.left), dfs(root.right))

        return dfs(root) if dfs(root) != float('inf') else -1

#### 2. 非递归
思路：

## 700. 二叉搜索树中的搜索
题目：给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 前序遍历，判断当前节点和给定值的大小，若大则遍历左子树，否则右子树。

    # 代码
    def searchBST(self, root: TreeNode, val: int) -> TreeNode:

        def dfs(root):
            if not root:
                return -1
            if root.val == val:
                return root
            elif root.val > val:
                return dfs(root.left)
            else:
                return dfs(root.right)

        return dfs(root) if dfs(root)!= -1 else None

#### 2. 非递归
思路：

## 703. 数据流中的第 K 大元素
题目：设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。
请实现 KthLargest 类：
KthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。
int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 

    # 代码
    

#### 2. 非递归
思路：

## 783. 二叉搜索树节点最小距离
题目：给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 中序遍历，记录最小差值即可。

    # 代码
    def minDiffInBST(self, root: TreeNode) -> int:

        min_v = float('inf')
        pre = None

        def dfs(root):
            nonlocal min_v, pre
            if not root:
                return
            dfs(root.left)
            if pre and abs(pre.val - root.val) < min_v:
                min_v = abs(pre.val - root.val)
            pre = root
            dfs(root.right)
        
        dfs(root)
        return min_v

#### 2. 非递归
思路：

## 872. 叶子相似的树
题目：请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 叶值序列 。
举个例子，如上图所示，给定一棵叶值序列为 (6, 7, 4, 9, 8) 的树。如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是 叶相似 的。
如果给定的两个根结点分别为 root1 和 root2 的树是叶相似的，则返回 true；否则返回 false 。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 中序遍历，记录最小差值即可。

    # 代码
    def leafSimilar(self, root1: TreeNode, root2: TreeNode) -> bool:

        def dfs(root, res):
            if not root:
                return
            if not root.left and not root.right:
                res.append(root.val) 

            dfs(root.left, res)
            dfs(root.right, res)

        res1, res2 = [], []
        dfs(root1, res1)
        dfs(root2, res2)
        return res1 == res2

#### 2. 非递归
思路：

## 897. 递增顺序搜索树
题目：给你一棵二叉搜索树，请你 按中序遍历 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 中序遍历，然后构建递增树即可。

    # 代码
    def increasingBST(self, root: TreeNode) -> TreeNode:

        res = []

        def dfs(root):
            nonlocal res
            if not root:
                return
            dfs(root.left)
            res.append(root.val)
            dfs(root.right)

        dfs(root)
        if not res:
            return None
        main_node = TreeNode(0)
        res_node = main_node
        for re in res:
            tmp = TreeNode(re)
            main_node.left = None
            main_node.right = tmp
            main_node = main_node.right

        return res_node.right

#### 2. 非递归
思路：

## 938. 二叉搜索树的范围和
题目：给定二叉搜索树的根结点 root，返回值位于范围 [low, high] 之间的所有结点的值的和。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 中序遍历，值在给定范围的求和即可。

    # 代码
    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:

        res = []

        def dfs(root):
            if not root:
                return 
            dfs(root.left)
            if root.val >= low and root.val <=high:
                res.append(root.val)
            dfs(root.right)
        
        dfs(root)
        return sum(res)

#### 2. 非递归
思路：

## 965. 单值二叉树
题目：如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。只有给定的树是单值二叉树时，才返回 true；否则返回 false。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 前序遍历，把所有值存入数组，然后判断数组是否只包含同一个数即可。

    # 代码
    def isUnivalTree(self, root: TreeNode) -> bool:
        val = root.val

        def dfs(root):
            if not root:
                return True
            if root.val != val:
                return False
            else:
                return dfs(root.left) and dfs(root.right)
        
        return dfs(root)

#### 2. 非递归
思路：

## 993. 二叉树的堂兄弟节点
题目：在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。
我们给出了具有唯一值的二叉树的根节点 root ，以及树中两个不同节点的值 x 和 y 。只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true 。否则，返回 false。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 前序遍历，记录当前节点的深度，和当前节点的父节点。

    # 代码
    def isCousins(self, root: TreeNode, x: int, y: int) -> bool:
        x_d, y_d, x_p, y_p = 0, 0, None, None

        def dfs(root, parent, x, y, depth):
            nonlocal x_d, x_p, y_d, y_p
            if not root:
                return
            if root.val == x:
                x_d = depth
                x_p = parent
            if root.val == y:
                y_d = depth
                y_p = parent
            dfs(root.left, root, x, y, depth+1)
            dfs(root.right, root, x, y, depth+1)
        
        dfs(root, None, x, y, depth=0)
        return x_d == y_d and x_p !=y_p

#### 2. 非递归
思路：

## 1022. 从根到叶的二进制数之和
题目：给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。例如，如果路径为 0 -> 1 -> 1 -> 0 -> 1，那么它表示二进制数 01101，也就是 13 。对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。返回这些数字之和。题目数据保证答案是一个 32 位 整数。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 遍历记录根到叶子节点的路径，然后求和即可。

    # 代码
    def sumRootToLeaf(self, root: TreeNode) -> int:

        res = []

        def dfs(root, path):
            if not root:
                return
            path += str(root.val)
            if not root.left and not root.right:
                res.append(path)
            dfs(root.left, path)
            dfs(root.right, path)

        def getNum(s):
            sum = 0
            for i in range(len(s)):
                sum += (int(s[len(s) - i -1]) * pow(2, i))
            return sum

        dfs(root, '')
        sum = 0
        for re in res:
            sum += getNum(re)
        return sum

#### 2. 非递归
思路：

## 95. 不同的二叉搜索树 II
题目：给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 从[1,...n] 遍历，一次当根，因为是二叉搜索树，当根节点取i时，[1,...i] 构成左子树，[i,...n] 构成右子树，左右子树再递归求解即可。

    # 代码
    def generateTrees(self, n: int) -> List[TreeNode]:

        def dfs(s, e):
            res = []
            if s > e:
                return [None]
            for i in range(s, e+1):
                lefts = dfs(s, i-1)
                rights = dfs(i+1, e)
                for l in lefts:
                    for r in rights:
                        node = TreeNode(i)
                        node.left = l
                        node.right = r
                        res.append(node)
            return res
        return dfs(1, n)

#### 2. 非递归
思路：

## 96. 不同的二叉搜索树
题目：给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 记忆化搜索，总的种数=左子树种数*右子树数量。
    # 代码
    def numTrees(self, n: int) -> int:

        dic = {0: 1, 1: 2, 2: 2}

        def dfs(n):
            if n <= 0: return 1
            if n <= 2: return n
            if n in dic:
                return dic[n]
            dic[n] = sum([dfs(i-1) * dfs(n-i) for i in range(1, n+1)])
            return dic[n]

        return dfs(n)

#### 2. 非递归
思路：

## 98. 验证二叉搜索树
题目：给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。有效 二叉搜索树定义如下：
节点的左子树只包含 小于 当前节点的数。节点的右子树只包含 大于 当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 中序遍历，单调递增

    # 代码
    def isValidBST(self, root: TreeNode) -> bool:
        pre = None

        def dfs(root):
            nonlocal pre
            if not root:
                return True
            left = dfs(root.left)
            if pre and pre.val >= root.val:
                return False
            pre = root
            right = dfs(root.right)
            return left and right
        
        return dfs(root)

#### 2. 非递归
思路：

## 99. 恢复二叉搜索树
题目：给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。
进阶：使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 中序遍历，找到第一个a>b的，取a,然后取第二个a>b的取b,最后交换a和b。

    # 代码
    def recoverTree(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """

        firstNode = None
        secondNode = None
        pre = None

        def dfs(root):
            nonlocal pre, firstNode, secondNode
            if not root:
                return 
            
            dfs(root.left)
            if pre:
                if not firstNode and pre.val > root.val:
                    firstNode = pre
                    secondNode = root
                elif firstNode and pre.val > root.val:
                    secondNode = root
            pre = root
            dfs(root.right)

        dfs(root)
        if firstNode and secondNode:
            firstNode.val, secondNode.val = secondNode.val, firstNode.val

#### 2. 非递归
思路：

## 102. 二叉树的层序遍历
题目：给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 

#### 2. 非递归
思路：层序遍历，非递归。

    # 代码
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        
        res = []
        queue = [root]

        while queue:
            res.append([q.val for q in queue])
            l = []
            for q in queue:
                if q.left:
                    l.append(q.left)
                if q.right:
                    l.append(q.right)
            queue = l
        
        return res

## 103. 二叉树的锯齿形层序遍历
题目：给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 

#### 2. 非递归
思路：层序遍历，使用单独遍历记录是否需要翻转。

    # 代码
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        res = []
        queue = [root]
        is_reverse = False
        while queue:
            tmp = [q.val for q in queue]
            if is_reverse:
                tmp.reverse()
                res.append(tmp)
                is_reverse = False
            else:
                res.append(tmp)
                is_reverse = True

            l = []
            for q in queue:
                if q.left:
                    l.append(q.left)
                if q.right:
                    l.append(q.right)
            queue = l
        
        return res
        
## 105. 从前序与中序遍历序列构造二叉树
题目：给定一棵树的前序遍历 preorder 与中序遍历  inorder。请构造二叉树并返回其根节点。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 根据前序找到根节点，然后递归构建左子树和右子树

    # 构造二叉树
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:

        def dfs(preorder, inorder):
            if not preorder or not inorder:
                return
            root = TreeNode(preorder[0])
            index = inorder.index(preorder[0])
            root.left = dfs(preorder[1:index+1], inorder[0:index])
            root.right = dfs(preorder[index+1:], inorder[index+1:])
            return root

        return dfs(preorder, inorder)

#### 2. 非递归
思路：

## 106. 从中序与后序遍历序列构造二叉树
题目：根据一棵树的中序遍历与后序遍历构造二叉树。
注意:你可以假设树中没有重复的元素。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 根据后序找到根节点，然后递归构建左子树和右子树

    # 构造二叉树
    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:

        def dfs(inorder, postorder):
            if not inorder or not postorder:
                return 
            index = inorder.index(postorder[-1])
            root = TreeNode(postorder[-1])
            root.left = dfs(inorder[0:index], postorder[0:index])
            root.right = dfs(inorder[index+1:], postorder[index:len(postorder)-1])
            return root
        
        return dfs(inorder, postorder)

#### 2. 非递归
思路：

## 107. 二叉树的层序遍历 II
题目：给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 层序遍历，将结果翻转即可。

    # 层顺序遍历
    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []

        res = []
        queue = [root]
        while queue:
            res.append([q.val for q in queue])
            l = []
            for q in queue:
                if q.left:
                    l.append(q.left)
                if q.right:
                    l.append(q.right)
            queue= l

        res.reverse()

        return res
#### 2. 非递归
思路：

## 109. 有序链表转换二叉搜索树
题目：给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。
本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 有序链表快慢指针找中点，然后构建树即可。

    # 层顺序遍历
    def sortedListToBST(self, head: ListNode) -> TreeNode:

        def findMid(head, tail):
            fast = head
            slow = head
            while fast != tail and fast.next != tail:
                slow = slow.next
                fast = fast.next.next
            return slow
        
        def dfs(head, tail):
            if head == tail:
                return None
            node = findMid(head, tail)
            root= TreeNode(node.val)
            root.left = dfs(head, node)
            root.right = dfs(node.next, tail)
            return root

        return dfs(head, None)
#### 2. 非递归
思路：

## 113. 路径总和 II
题目：给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。
叶子节点 是指没有子节点的节点。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 深度优先遍历，遍历到叶子节点时判断即可。

    # 层顺序遍历
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:

        res = []
        sub_res = []
        def dfs(root):
            nonlocal res, sub_res
            if not root:
                return 
            sub_res.append(root.val)
            if not root.left and not root.right:
                if sum(sub_res) == targetSum:
                    res.append([s for s in sub_res])
            dfs(root.left)
            dfs(root.right)
            sub_res.pop()

        dfs(root)
        return res
#### 2. 非递归
思路：

## 114. 二叉树展开为链表
题目：给你二叉树的根结点 root ，请你将它展开为一个单链表：
展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
展开后的单链表应该与二叉树 先序遍历 顺序相同。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 先序遍历，根左右，将根节点的右子树移到左子树的最右节点，将左子树变为根的右子树，将根的右子树置为空，然后根节点右移循环判断。

    # 层顺序遍历
    def flatten(self, root: TreeNode) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        if not root:
            return 

        node = root

        while node:
            if node.left:
                sub_left = node.left
                tmp = sub_left
                while tmp.right:
                    tmp = tmp.right
                tmp.right = node.right
                node.right = sub_left
                node.left = None
            node = node.right
#### 2. 非递归
思路：

## 116. 填充每个节点的下一个右侧节点指针
题目：给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
初始状态下，所有 next 指针都被设置为 NULL。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 每个根节点的左节点next应该指向根节点的右节点，每个根节点的右节点next应该指向其父节点的next节点的左节点。

    # 
    def connect(self, root: 'Node') -> 'Node':

        def dfs(root):
            if not root:
                return
            if root.left:
                root.left.next = root.right
            if root.right:
                if root.next:
                    root.right.next = root.next.left
            dfs(root.left)
            dfs(root.right)

        dfs(root)
        return root
#### 2. 非递归
思路：

## 117. 填充每个节点的下一个右侧节点指针 II
题目：给定一个二叉树
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
初始状态下，所有 next 指针都被设置为 NULL。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 每个根节点的左节点next应该指向根节点的右节点，每个根节点的右节点next应该指向其父节点的next节点的左节点。

    # 
    
#### 2. 非递归
思路：

## 129. 求根节点到叶节点数字之和
给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。
每条从根节点到叶节点的路径都代表一个数字：
例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。
计算从根节点到叶节点生成的 所有数字之和 。
叶节点 是指没有子节点的节点。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 深度遍历，直接求和即可。

    # 
    def sumNumbers(self, root: TreeNode) -> int:

        res = 0
        def dfs(root, num):
            nonlocal res
            if not root:
                return
            if not root.left and not root.right:
                res += num
            if root.left:
                dfs(root.left, num * 10 + root.left.val)
            if root.right:
                dfs(root.right, num * 10 + root.right.val)
        dfs(root, root.val)
        return res
    
#### 2. 非递归
思路：

## 173. 二叉搜索树迭代器
实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：
BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。
boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。
int next()将指针向右移动，然后返回指针处的数字。
注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。
你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 求next时构造单调栈。

    # 
    class BSTIterator:

    def __init__(self, root: TreeNode):
        self.res = []
        while root:
            self.res.append(root)
            root = root.left


    def next(self) -> int:
        cur = self.res.pop()
        node = cur.right
        while node:
            self.res.append(node)
            node = node.left
        return cur.val


    def hasNext(self) -> bool:
        return len(self.res) > 0
    
#### 2. 非递归
思路：

## 199. 二叉树的右视图
给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 层次遍历，每层取最右边节点。

    # 
    def rightSideView(self, root: TreeNode) -> List[int]:
        if not root:
            return []

        res = []
        queue = [root]
        while queue:
            res.append(queue[-1].val)
            l = []
            for q in queue:
                if q.left:
                    l.append(q.left)
                if q.right:
                    l.append(q.right)
            queue = l

        return res
    
#### 2. 非递归
思路：

## 222. 完全二叉树的节点个数
给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。
完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 遍历根节点饿左子树高度和右子树高度，若高度相同则表示左子树肯定是满二叉树，总节点个数为左子树满二叉树+递归右子树，若不想等，则右子树肯定是二叉树，总节点个数为右子树满二叉树+递归左子树

    # 
    def countNodes(self, root: TreeNode) -> int:
        if not root:
            return 0

        def getDepth(node):
            if not node:
                return 0
            return max(getDepth(node.left), getDepth(node.right)) + 1

        def dfs(root):
            if not root:
                return 0
            l_d, r_d = getDepth(root.left), getDepth(root.right)
            if l_d == r_d:
                return (1<<l_d) + dfs(root.right)
            else:
                return (1<<r_d) + dfs(root.left)
        
        return dfs(root)
    
#### 2. 非递归
思路：

## 230. 二叉搜索树中第K小的元素
给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 中序遍历，遍历到第k个时结束即可。

    # 
    def kthSmallest(self, root: TreeNode, k: int) -> int:

        res = 0

        def dfs(root):
            nonlocal res, k
            if not root:
                return
            dfs(root.left)
            k -= 1
            if k == 0:
                res = root.val
                return
            dfs(root.right)

        dfs(root)

        return res
    
#### 2. 非递归
思路：

## 236. 二叉树的最近公共祖先
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 最近公共祖先只会出现在情况，一是在根节点的左子树和右子树中，则为根，二是p是q的根，三是q是p的根。

    # 
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':

        def dfs(root):
            # nonlocal p, q
            if not root:
                return None
            if root == p or root == q:
                return root
            left = dfs(root.left)
            right = dfs(root.right)
            if not left:
                return right
            elif not right:
                return left
            elif not left and not right:
                return None
            else:
                return root

        return dfs(root)
    
#### 2. 非递归
思路：

## 331. 验证二叉树的前序序列化
序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 3##变为#，栈最后只剩一个#，返回true，反之反回false

    # 
    def isValidSerialization(self, preorder: str) -> bool:

        stack = []
        data = preorder.split(',')
        for s in data:
            stack.append(s)
            while len(stack) >= 3 and stack[-1] == '#' and stack[-2] == '#' and stack[-3] != '#':
                for i in range(3):
                    stack.pop()
                stack.append('#')
        return len(stack) == 1 and stack[0] == '#'
    
#### 2. 非递归
思路：

## 337. 打家劫舍 III
在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。
计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 递归，当根节点不偷时，左右两个孩子可以偷，可以不偷，取偷和不偷的最大值，当根节点偷时，左右两个孩子都不偷。

    # 
    def rob(self, root: TreeNode) -> int:

        def dfs(root):
            if not root:
                return 0, 0  # 偷，不偷
            left = dfs(root.left)
            right = dfs(root.right)
            # 偷当前节点，其左右两个孩子都不能偷
            v1 = root.val + left[1] + right[1]
            # 不偷当前节点，则左右两个孩子可以偷，可以不偷，取孩子最大值
            v2 = max(left[0], left[1]) + max(right[0], right[1])
            return v1, v2

        res = dfs(root)
        return max(res[0], res[1])
    
#### 2. 非递归
思路：

## 341. 扁平化嵌套列表迭代器
题目：给你一个嵌套的整数列表 nestedList 。每个元素要么是一个整数，要么是一个列表；该列表的元素也可能是整数或者是其他列表。请你实现一个迭代器将其扁平化，使之能够遍历这个列表中的所有整数。
实现扁平迭代器类 NestedIterator ：
NestedIterator(List<NestedInteger> nestedList) 用嵌套列表 nestedList 初始化迭代器。
int next() 返回嵌套列表的下一个整数。
boolean hasNext() 如果仍然存在待迭代的整数，返回 true ；否则，返回 false 。
你的代码将会用下述伪代码检测：
    
    # 
    initialize iterator with nestedList
    res = []
    while iterator.hasNext()
        append iterator.next() to the end of res
    return res

如果 res 与预期的扁平化列表匹配，那么你的代码将会被判为正确。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 递归，将NestedInteger列表中的整数加入列表，将NestedInteger列表中的列表递归出整数加入列表。
    
    # 
    class NestedIterator:
        def __init__(self, nestedList: [NestedInteger]):
            self.res = []
            self.index = 0
            def dfs(nestedList):
                for n in nestedList:
                    if n.isInteger():
                        self.res.append(n.getInteger())
                    else:
                        tmp_list = n.getList()
                        for l in tmp_list:
                            if l.isInteger():
                                self.res.append(l.getInteger())
                            else:
                                dfs(l.getList())
    
            dfs(nestedList)
            self.length = len(self.res)
    
    
        def next(self) -> int:
            data = self.res[self.index]
            self.index += 1
            return data
    
    
        def hasNext(self) -> bool:
            return self.index < self.length                   
    
#### 2. 非递归
思路：
                                           
## 429. N 叉树的层序遍历
题目：给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。
树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 二叉树层次遍历，改造一下即可。

    # 
    def levelOrder(self, root: 'Node') -> List[List[int]]:

        if not root:
            return []

        res = []
        queue = [root]
        while queue:
            res.append([q.val for q in queue])
            l = []
            for q in queue:
                # if q.left:
                #     l.append(q.left)
                # if q.right:
                #     l.append(q.right)
                for c in q.children:
                    l.append(c)
            queue = l

        return res
    
#### 2. 非递归
思路：         
    
## 437. 路径总和 III
题目：给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。
路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 前缀和

    # 
    def pathSum(self, root: TreeNode, targetSum: int) -> int:

        if not root:
            return 0

        res = 0
        def dfs(root, preSum):
            nonlocal res
            if not root:
                return
            for i in range(len(preSum)):
                preSum[i] += root.val
            preSum.append(root.val)
            for i in preSum:
                if i == targetSum:
                    res += 1
            dfs(root.left, preSum[:])
            dfs(root.right, preSum[:])

        dfs(root, [])
        return res
    
#### 2. 非递归
思路：       
    
## 449. 序列化和反序列化二叉搜索树
题目：序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。
设计一个算法来序列化和反序列化 二叉搜索树 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。
编码的字符串应尽可能紧凑。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 序列化前序，反序列化时由前序得到中序，然后前序，中序构建二叉树。

    # 
    def pathSum(self, root: TreeNode, targetSum: int) -> int:

        if not root:
            return 0

        res = 0
        def dfs(root, preSum):
            nonlocal res
            if not root:
                return
            for i in range(len(preSum)):
                preSum[i] += root.val
            preSum.append(root.val)
            for i in preSum:
                if i == targetSum:
                    res += 1
            dfs(root.left, preSum[:])
            dfs(root.right, preSum[:])

        dfs(root, [])
        return resclass Codec:

    def serialize(self, root: TreeNode) -> str:
        """Encodes a tree to a single string.
        """
        str1 = ''
        def dfs(root):
            nonlocal str1
            if not root:
                return
            str1 += ' ' + str(root.val)
            dfs(root.left)
            dfs(root.right)
        dfs(root)
        return str1
        

    def deserialize(self, data: str) -> TreeNode:
        """Decodes your encoded data to tree.
        """
        preOrder = []
        for d in data.split(' '):
            if d:
                preOrder.append(int(d))
        inOrder = [p for p in preOrder]
        inOrder.sort()

        # 前序、中序构建二叉树
        def dfs(preOrder, inOrder):
            if not preOrder or not inOrder:
                return
            root = TreeNode(preOrder[0])
            index = inOrder.index(preOrder[0])
            root.left = dfs(preOrder[1:index+1], inOrder[0:index])
            root.right = dfs(preOrder[index+1:], inOrder[index+1:])
            return root

        return dfs(preOrder, inOrder)
    
#### 2. 非递归
思路：   
    
## 997. 找到小镇的法官
题目：在一个小镇里，按从 1 到 n 为 n 个人进行编号。传言称，这些人中有一个是小镇上的秘密法官。
如果小镇的法官真的存在，那么：
小镇的法官不相信任何人。
每个人（除了小镇法官外）都信任小镇的法官。
只有一个人同时满足条件 1 和条件 2 。
给定数组 trust，该数组由信任对 trust[i] = [a, b] 组成，表示编号为 a 的人信任编号为 b 的人。
如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的编号。否则，返回 -1。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 有向图，法官是出度为0，入度为n-1的节点。

    # 
    def findJudge(self, n: int, trust: List[List[int]]) -> int:

        # 法官的出度是0，入度是n-1,且只存在一个这样的节点
        in_degree = [0] * (n+1)
        out_degree = [0] * (n+1) 
        for a, b in trust:
            out_degree[a] += 1
            in_degree[b] += 1
        for i in range(1, n+1):
            if in_degree[i] == n-1 and out_degree[i] == 0:
                return i
        return -1 
    
#### 2. 非递归
思路：    
    
## 1791. 找出星型图的中心节点
题目：有一个无向的 星型 图，由 n 个编号从 1 到 n 的节点组成。星型图有一个 中心 节点，并且恰有 n - 1 条边将中心节点与其他每个节点连接起来。
给你一个二维整数数组 edges ，其中 edges[i] = [ui, vi] 表示在节点 ui 和 vi 之间存在一条边。请你找出并返回 edges 所表示星型图的中心节点。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 依次就入度，中心节点入度为n-1

    # 
    def findCenter(self, edges: List[List[int]]) -> int:

        n = len(edges) + 1
        in_degree = [0] * (n+1)
        for a, b in edges:
            in_degree[a] += 1
            in_degree[b] += 1
        for i in range(1, n+1):
            if in_degree[i] == n - 1:
                return i
        return -1
    
#### 2. 非递归
思路：    
    
## LCP 07. 传递信息
题目：小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：
有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0
每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。
每轮信息必须需要传递给另一个人，且信息可重复经过同一个人
给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 深度优先遍历，当走了k步，且当前节点在n-1时+1。

    # 
    def numWays(self, n: int, relation: List[List[int]], k: int) -> int:
        edages = {}
        for a, b in relation:
            if a not in edages:
                edages[a] = [b]
            else:
                edages[a].append(b)
        ways = 0

        print(edages)

        def dfs(index, steps):
            nonlocal n, k, ways, edages
            if steps == k :
                if index == n - 1:
                    ways += 1
                return
            if index in edages:
                for i in edages[index]:
                    dfs(i, steps + 1)
        
        dfs(0, 0)
        return ways
    
#### 2. 非递归
思路：    
    
## 207. 课程表
题目：你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。
在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。
例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。
请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 判断是否为有向无环图。

    # 
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:

        # 判断课程表是不是有向无环图
        in_degree = [0] * numCourses # 记录每个节点的入度
        adjest = {} # 邻接矩阵
        for cur, pre in prerequisites:
            in_degree[cur] += 1
            if pre not in adjest:
                adjest[pre] = [cur]
            else:
                adjest[pre].append(cur)
        # 找到所有入度为0的节点，加入队列，然后删除入度为0的节点，该节点的临接节点入度-1
        queue = []
        for i in range(len(in_degree)):
            if in_degree[i] == 0:
                queue.append(i)
        
        while queue:
            pre = queue.pop(0)
            # 删除入度为0的节点，即课程数-1
            numCourses -= 1
            if pre in adjest:
                for i in adjest[pre]:
                    in_degree[i] -= 1
                    if in_degree[i] == 0:
                        queue.append(i)

        return numCourses == 0
    
#### 2. 非递归
思路：    
     
## 210. 课程表 II
题目：现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1。给你一个数组 prerequisites ，其中 prerequisites[i] = [ai, bi] ，表示在选修课程 ai 前 必须 先选修 bi 。
例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1] 。
返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组 。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 判断是否为有向无环图,并记录删除的入度为0的节点返回即可。

    # 
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:

        in_degree = [0] * numCourses
        adjest = {}
        for cur, pre in prerequisites:
            in_degree[cur] += 1
            if pre not in adjest:
                adjest[pre] = [cur]
            else:
                adjest[pre].append(cur)
        queue = []
        for i in range(len(in_degree)):
            if in_degree[i] == 0:
                queue.append(i)

        res = []
        while queue:
            numCourses -= 1
            pre = queue.pop(0)
            res.append(pre)
            if pre in adjest:
                for i in adjest[pre]:
                    in_degree[i] -= 1
                    if in_degree[i] == 0:
                        queue.append(i)
        if numCourses == 0:
            return res
        else:
            return []
    
#### 2. 非递归
思路：     
    
## 53. 最大子序和
题目：给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 定义dp[i]表示以i为结尾的最大子序和，dp[i] = max(dp[i] + nums[i], nums[i])

    # 
    def maxSubArray(self, nums: List[int]) -> int:

        dp = [0] * len(nums)
        dp[0] = nums[0]
        for i in range(1, len(nums)):
            dp[i] = max(dp[i-1]+nums[i], nums[i])
        return max(dp)
    
#### 2. 非递归
思路：  
    
## 70. 爬楼梯
题目：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
注意：给定 n 是一个正整数。
#### 1. 递归
思路: 定义dp[i]表示以i级阶梯的爬法总和，dp[i] = dp[i-1] + dp[i-2]

    # 
    def climbStairs(self, n: int) -> int:
        if n == 1:
            return 1
        dp = [0] * (n+1)
        dp[1] = 1
        dp[2] = 2
        for i in range(3, n+1):
            dp[i] = dp[i-1] + dp[i-2]
        return dp[n]
    
#### 2. 非递归
思路：  
    
## 118. 杨辉三角
题目：给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。
在「杨辉三角」中，每个数是它左上方和右上方的数的和。
#### 1. 递归
思路: dp,动态规划

    # 
    def generate(self, numRows: int) -> List[List[int]]:
        dp = []
        temp = []
        for i in range(numRows):
            temp = [1] * (i+1)
            for j in range(1, i):
                temp[j] = dp[i-1][j-1] + dp[i-1][j]
            dp.append(temp)
        return dp
    
#### 2. 非递归
思路：  
    
## 119. 杨辉三角 II
题目：给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。
在「杨辉三角」中，每个数是它左上方和右上方的数的和。
#### 1. 递归
思路: dp,动态规划

    # 
    def getRow(self, rowIndex: int) -> List[int]:
        dp = []
        for i in range(rowIndex+1):
            temp = [1] * (i+1)
            for j in range(1, i):
                temp[j] = dp[i-1][j-1] + dp[i-1][j]
            dp.append(temp)
        return dp[rowIndex]
    
#### 2. 非递归
思路：  
    
## 121. 买卖股票的最佳时机
题目：给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
#### 1. 递归
思路: dp,动态规划，dp[i]表示第i天获得的最大利润，dp[i] = max(dp[i-1], prices[i] - minPirce),其中minPrice表示前i-1天的最低价格

    # 
    def maxProfit(self, prices: List[int]) -> int:

        dp = [0] * len(prices)
        dp[0] = 0
        minPirce = prices[0]
        for i in range(1, len(prices)):
            dp[i] = max(dp[i-1], prices[i] - minPirce) 
            minPirce = min(minPirce, prices[i])
        return dp[-1]
        return dp[rowIndex]
    
#### 2. 非递归
思路：  
    
## 338. 比特位计数
题目：给你一个整数 n ，对于 0 <= i <= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: i为偶数，1的个数=i/2的1的个数，i 为奇数，1的个数=i-1的个数。

    # 
    def countBits(self, n: int) -> List[int]:
        # dp实现
        dp = [0] * (n+1)
        for i in range(n+1):
            if i % 2 == 0:
                dp[i] = dp[i // 2]
            else:
                dp[i] = dp[i-1] + 1
        return dp
    
#### 2. 非递归
思路：  
    
## 392. 判断子序列
题目：给定字符串 s 和 t ，判断 s 是否为 t 的子序列。
字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。
进阶：
如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 遍历T，看每个字符是否在S中，若在则继续遍历，最后看S是否已遍历完，遍历完返回true,否则返回false.

    # 
    def isSubsequence(self, s: str, t: str) -> bool:

        index = 0
        for i in t:
            if index == len(s):
                return True
            if i == s[index]:
                index += 1
        if index == len(s):
            return True
        else:
            return False
    
#### 2. 非递归
思路：  
    
## 509. 斐波那契数
题目：斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给你 n ，请计算 F(n) 。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: dp[i] 表示i的数和，dp[i] = dp[i-1] + dp[i-2]

    # 
    def fib(self, n: int) -> int:
        if n <= 0:
            return 0
        dp = [0] * (n+1)
        dp[1] = 1
        for i in range(2, n+1):
            dp[i] = dp[i-1]+ dp[i-2]
        return dp[n]
                 
#### 2. 非递归
思路：  
                 
## 746. 使用最小花费爬楼梯
题目：数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。
每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。
请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: dp[i] 表示到达i级阶梯的最小花费，则dp[i] = min(dp[i-1], dp[i-2]) + cost[i]

    # 
    def minCostClimbingStairs(self, cost: List[int]) -> int:

        n = len(cost)
        dp = [0] * n
        dp[0] = cost[0]
        dp[1] = cost[1]
        for i in range(2, len(cost)):
            dp[i] = min(dp[i-1], dp[i-2]) + cost[i]
        return min(dp[n-1], dp[n-2])
                 
#### 2. 非递归
思路：  
    
    
## 1025. 除数博弈
题目：爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。
最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：
选出任一 x，满足 0 < x < N 且 N % x == 0 。
用 N - x 替换黑板上的数字 N 。
如果玩家无法执行这些操作，就会输掉游戏。
只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 False。假设两个玩家都以最佳状态参与游戏。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 先手，偶赢奇输。
    
    # 
    def divisorGame(self, n: int) -> bool:
        return n % 2 == 0
                 
#### 2. 非递归
思路： 
    
## 1137. 第 N 个泰波那契数
题目：泰波那契序列 Tn 定义如下： 
T0 = 0, T1 = 1, T2 = 1, 且在 n >= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2
给你整数 n，请返回第 n 个泰波那契数 Tn 的值。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 先手，偶赢奇输。
    
    # 
    def tribonacci(self, n: int) -> int:
        if n <= 0:
            return 0
        elif n <= 2:
            return 1
        dp = [0] * (n+1)
        dp[1] = 1
        dp[2] = 1
        for i in range(3, n+1):
            dp[i] = dp[i-1] + dp[i-2] + dp[i-3]
        return dp[-1]
                 
#### 2. 非递归
思路： 
    
## 1646. 获取生成数组中的最大值
题目：给你一个整数 n 。按下述规则生成一个长度为 n + 1 的数组 nums ：
nums[0] = 0
nums[1] = 1
当 2 <= 2 * i <= n 时，nums[2 * i] = nums[i]
当 2 <= 2 * i + 1 <= n 时，nums[2 * i + 1] = nums[i] + nums[i + 1]
返回生成数组 nums 中的 最大 值。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 按照公式计算即可。
    
    # 
    def getMaximumGenerated(self, n: int) -> int:
        if n == 0:
            return 0
        nums = [0] * (n+1)
        nums[1] = 1
        for i in range(1, n+1):
            if 2 * i  >= 2 and 2 * i <= n:
                nums[2 * i] = nums[i]
            if 2 * i + 1  >= 2 and 2 * i + 1 <= n:
                nums[2 * i + 1] = nums[i] + nums[i + 1]
        return max(nums)
                 
#### 2. 非递归
思路： 

## 5. 最长回文子串
题目：给你一个字符串 s，找到 s 中最长的回文子串。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: dp[i][j] 表示[i][j]字符串是否是回文串，dp[i][j] = dp[i+1][j-1] && s[i] == s[j], j - i >= 2
    
    # 
    def longestPalindrome(self, s: str) -> str:

        n = len(s)
        dp = [[False for _ in range(n)] for _ in range(n)]
        # dp[i][j]表示[i, j]的字符串是否是回文串
        # dp[i][j] = dp[i+1][j-1] && s[i] == s[j], j - i >= 2
        for i in range(n):
            dp[i][i] = True

        start, end = 0, 0
        max_len = 0
        for j in range(n):
            for i in range(j):
                if j - i >= 2:
                    if dp[i+1][j-1] and s[i] == s[j]:
                        dp[i][j] = True
                        if j - i + 1 > max_len:
                            max_len = j - i + 1
                            start, end = i, j
                elif j - i == 1:
                    if s[i] == s[j]:
                        dp[i][j] = True
                        if j - i + 1 > max_len:
                            max_len = j - i + 1
                            start, end = i, j
        return s[start:end+1]
                 
#### 2. 非递归
思路： 

## 45. 跳跃游戏 II
题目：给你一个非负整数数组 nums ，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用最少的跳跃次数到达数组的最后一个位置。
假设你总是可以到达数组的最后一个位置。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: dp[i]表示跳到i位置处所需的最小步数，dp[i] = min(dp[i], dp[j] + 1), 其中0<=j<i。
    
    # 
    def jump(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [math.inf] * n  # dp[i] 表示跳到i位置需要的最小次数
        dp[0] = 0
        for i in range(1, n):
            for j in range(i):
                if i - j <= nums[j]:
                    dp[i] =  min(dp[i], dp[j] + 1)  # j是[0, i-1]到达i位置最小的次数
        # print(dp)
        return dp[-1]
                 
#### 2. 非递归
思路： 
                                   
## 55. 跳跃游戏
题目：给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个下标。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: dp[i]表示在i位置处能跳的最大距离，dp[i] = max(dp[i-1], i+nums[i]), dp[i-1] >= i, 否则 dp[i] = dp[i-1]
    
    # 
    def canJump(self, nums: List[int]) -> bool:
        n = len(nums)
        dp = [0] * n
        dp[0] = nums[0]
        for i in range(1, n):
            if dp[i-1] >= i:
                dp[i] = max(dp[i-1], i + nums[i])
            else:
                dp[i] = dp[i-1]  # 前面能跳的最大距离都跳不到当前位置，那么当前位置能跳大的最大距离取前一能跳到的最大距离。
        # print(dp)
        return dp[-1] >= len(nums) - 1
                 
#### 2. 非递归
思路： 

## 62. 不同路径
题目：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
问总共有多少条不同的路径？
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: dp[i][j]表示到达[i, j]位置时的路径数，dp[i][j] = dp[i-1][j] + dp[i][j-1]
    
    # 
    def uniquePaths(self, m: int, n: int) -> int:

        # i>0 j and j>0 dp[i][j] = dp[i-1][j] + dp[i][j-1]
        dp = [[0 for _ in range(n)] for _ in range(m)]
        dp[0][0] = 1
        for i in range(m):
            for j in range(n):
                if i == 0:
                    dp[i][j] = 1
                elif j == 0:
                    dp[i][j] = 1
                else:
                    dp[i][j] = dp[i-1][j] + dp[i][j-1]
        return dp[m-1][n-1]
                 
#### 2. 非递归
思路：
    
## 63. 不同路径 II
题目：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
网格中的障碍物和空位置分别用 1 和 0 来表示。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: dp[i][j]表示到达[i, j]位置时的路径数，当网格为1时，到达该网格的路径数为0，否则为dp[i][j] = dp[i-1][j] + dp[i][j-1]
    
    # 
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        if obstacleGrid[0][0] == 1:
            return 0
        m = len(obstacleGrid)
        n = len(obstacleGrid[0])
        dp = [[0 for _ in range(n)] for _ in range(m)]
        dp[0][0] = 1
        for i in range(m):
            for j in range(n):
                if obstacleGrid[i][j] == 1:
                    dp[i][j] = 0
                elif i == 0 and j == 0:
                    dp[i][j] = 1
                elif i == 0:
                    dp[i][j] = dp[i][j-1]
                elif j == 0:
                    dp[i][j] = dp[i-1][j]
                else:
                    dp[i][j] = dp[i-1][j] + dp[i][j-1]
        return dp[m-1][n-1]
                 
#### 2. 非递归
思路：
    
## 64. 最小路径和
题目：给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
说明：每次只能向下或者向右移动一步。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: dp[i][j]表示到达[i, j]位置时的最小路径和，dp[i][j] = min(dp[i-1][j] + dp[i][j-1]) + grid[i][j]
    
    # 
    def minPathSum(self, grid: List[List[int]]) -> int:

        # i>j and j>0 dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
        # dp[i][j] 表示到达[i][j]位置的最小路径和
        m = len(grid)
        n = len(grid[0])
        dp = [[0 for _ in range(n)] for _ in range(m)]
        dp[0][0] = grid[0][0]

        for i in range(m):
            for j in range(n):
                if i == 0 and j == 0:
                    dp[i][j] = grid[i][j]
                elif i == 0:
                    dp[i][j] = dp[i][j-1] + grid[i][j]
                elif j == 0:
                    dp[i][j] = dp[i-1][j] + grid[i][j]
                else:
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
        return dp[m-1][n-1]
                 
#### 2. 非递归
思路：

## 91. 解码方法
题目：一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：
'A' -> 1
'B' -> 2
...
'Z' -> 26
要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：
"AAJF" ，将消息分组为 (1 1 10 6)
"KJF" ，将消息分组为 (11 10 6)
注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。
给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。
题目数据保证答案肯定是一个 32 位 的整数。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: dp[i]
    
    # 
    def numDecodings(self, s: str) -> int:
        if not s:
            return 0
        elif s[0] == '0':
            return 0
        m = len(s)
        dp = [0] * (m+1)
        dp[0] = 1
        dp[1] = 1
        for i in range(2, m+1):
            if s[i-1] == '0' and s[i-2] not in '12':
                return 0
            if s[i-2:i] in ['10', '20']:
                dp[i] = dp[i-2]
            elif '10' <= s[i-2:i] <= '26':
                dp[i] = dp[i-1] + dp[i-2]
            else:
                dp[i] = dp[i-1]
            
        print(dp)
        return dp[-1]
                 
#### 2. 非递归
思路：
    
## 97. 交错字符串
题目：给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。
两个字符串 s 和 t 交错 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：
s = s1 + s2 + ... + sn
t = t1 + t2 + ... + tm
|n - m| <= 1
交错 是 s1 + t1 + s2 + t2 + s3 + t3 + ... 或者 t1 + s1 + t2 + s2 + t3 + s3 + ...
提示：a + b 意味着字符串 a 和 b 连接。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: dp[i][j]表示s1的前i个元素和s2的前j个元素是否能构成s3前i+j元素。
    
    # 
    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:

        # dp[i][j]: s1的前i个元素和s2的前j个元素是否能构成s3前i+j元素

        l1 = len(s1)
        l2 = len(s2)
        l3 = len(s3)
        if l1 + l2 != l3:
            return False

        dp = [[False for _ in range(l2+1)] for _ in range(l1+1)]
        dp[0][0] = True
        
        # print(dp)
        for i in range(l1 + 1):
            for j in range(l2 + 1):
                if i == 0 and j == 0:
                    dp[i][j] = True
                elif i == 0:
                    dp[i][j] = dp[i][j-1] and s2[j-1] == s3[i+j-1]
                elif j == 0:
                    dp[i][j] = dp[i-1][j] and s1[i-1] == s3[i+j-1]
                else:
                    dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i+j-1]) or (dp[i][j-1] and s2[j-1] == s3[i+j-1])
        # print(dp)
        return dp[-1][-1]
                 
#### 2. 非递归
思路：

## 120. 三角形最小路径和
题目：给定一个三角形 triangle ，找出自顶向下的最小路径和。
每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: dp[i][j] 表示位置[i][j]的最小路径和,dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]
    
    # 
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        m = len(triangle)
        n = len(triangle[-1])
        # dp[i][j] 表示位置[i][j]的最小路径和
        # dp[i][j] = min(dp[i][j-1], dp[i-1][j-1]) + triangle[i][j]

        dp = [[math.inf for _ in range(n)] for _ in range(m)]
        dp[0][0] = triangle[0][0]
        
        for i in range(m):
            for j in range(i+1):
                if i == 0 and j == 0:
                    dp[i][j] = triangle[0][0]
                elif i == 0:
                    dp[i][j] = triangle[0][0]
                elif j == 0:
                    dp[i][j] = dp[i-1][j] + triangle[i][j]
                else:
                    dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]
        # print(dp)
        return min(dp[-1])
                 
#### 2. 非递归
思路：

## 122. 买卖股票的最佳时机 II
题目：给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: dp[i][j]: 第i天的交易状态的收益，dp[i][0]手中有股票获取的最大收益,dp[i][1]手中没股票获取的最大收益
    
    # 
    def maxProfit(self, prices: List[int]) -> int:

        # dp[i][j]: 第i天的交易状态的收益，dp[i][0]手中有股票获取的最大收益,dp[i][1]手中没股票获取的最大收益
        n = len(prices)
        dp = [[0 for _ in range(2)] for _ in range(n)]
        dp[0][0] = -prices[0]
        dp[0][1] = 0
        for i in range(n):
            if i == 0:
                dp[i][0] = -prices[i]
                dp[i][1] = 0
            else:
                dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i])
                dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])
        # print(dp)
        return dp[-1][1]
                 
#### 2. 非递归
思路：
    
## 139. 单词拆分
题目：给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。
说明：
拆分时可以重复使用字典中的单词。
你可以假设字典中没有重复的单词。
    
示例 1：
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
示例 2：
输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
     注意你可以重复使用字典中的单词。
示例 3：
输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: dp[i]: s的前i个字符是否能用wordDict字典表示, 从s起点“”出发,按照 wordDict规则进行跳跃，能否跳到终点
    
    # 
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        n = len(s)
        # dp[i]: s的前i个字符是否能用wordDict字典表示 
        # 从s起点“”出发,按照 wordDict规则进行跳跃，能否跳到终点
        # 题解：https://leetcode-cn.com/problems/word-break/solution/python3-dong-tai-gui-hua-by-irruma/
        
        dp = [False] * (n+1)
        dp[0] = True
        for i in range(n):
            if dp[i]:  # 每次从跳到的位置继续判断
                for j in range(i+1, n+1):
                    if s[i:j] in wordDict:
                        dp[j] = True
        # print(dp)
        return dp[-1]
                 
#### 2. 非递归
思路：
    
## 152. 乘积最大子数组
题目：给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。
    
示例 1:
输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
示例 2:
输入: [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: dp[i]: 表示i位置处的最大状态(dp[i][0]最大值，dp[i][1]最小值)，然后遍历每个位置处的最大状态，找到最大值即可。
    
    # 
    def maxProduct(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [[0 for _ in range(2)] for _ in range(n)]

        res = -math.inf
        for i in range(n):
            if i == 0:
                dp[i][0] = nums[i]  # 存储当前位置最大值
                dp[i][1] = nums[i]  # 存储当前位置最小值
            else:
                dp[i][0] = max(dp[i-1][0]*nums[i], dp[i-1][1]*nums[i], nums[i])
                dp[i][1] = min(dp[i-1][0]*nums[i], dp[i-1][1]*nums[i], nums[i])
            res = max(res, dp[i][0])
        # print(dp)
        return res
                 
#### 2. 非递归
思路：
    
## 198. 打家劫舍
题目：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
示例 1：
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
示例 2：
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: dp[i]: 第i个房间获得的最大金额,dp[i][0]->偷获得的最大利润，dp[i][1]->不偷获得的最大利润
    
    # 
    def rob(self, nums: List[int]) -> int:

        # dp[i]: 第i个房间获得的最大金额,dp[i][0]->偷获得的最大利润，dp[i][1]->不偷获得的最大利润
        n = len(nums)
        dp = [[0 for _ in range(2)] for _ in range(n)]

        for i in range(n):
            if i == 0:
                dp[i][0] = nums[i]
                dp[i][1] = 0
            else:
                dp[i][0] = dp[i-1][1] + nums[i]
                dp[i][1] = max(dp[i-1][0], dp[i-1][1])
        print(dp)
        return max(dp[-1])
                 
#### 2. 非递归
思路：
    
## 213. 打家劫舍 II
题目：你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。
给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。
示例 1：
输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
示例 2：
输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
示例 3：
输入：nums = [0]
输出：0
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: dp[i]: 第i个房间获得的最大金额,dp[i][0]->偷获得的最大利润，dp[i][1]->不偷获得的最大利润,分两种情况，第一天偷时，最后一天不能偷，或第一天不偷时，最后一天可以偷。
    
    # 
    def rob(self, nums: List[int]) -> int:
        # dp[i]: 第i天获得的最大利润,dp[i][0]->偷获得的最大利润,dp[i][1]->不偷获得的最大利润
        n  = len(nums)
        if n == 0:
            return 0
        elif n == 1:
            return nums[0]
        dp = [[0 for _ in range(2)] for _ in range(n)]
        max1, max2 = 0, 0
        for i in range(n):  # 当第一家不偷时获得的最大利润
            if i == 0:
                dp[i][0] = 0
                dp[i][1] = 0
            else:
                dp[i][0] = dp[i-1][1] + nums[i]
                dp[i][1] = max(dp[i-1])
        max1 = max(dp[-1])
        for i in range(n-1):  # 当第一家偷时获得的最大利润, 最后一家不能偷
            if i == 0:
                dp[i][0] = nums[i]
                dp[i][1] = 0
            else:
                dp[i][0] = dp[i-1][1] + nums[i]
                dp[i][1] = max(dp[i-1])
        max2 = max(dp[-2])
        return max(max1, max2)
                 
#### 2. 非递归
思路：

## 221. 最大正方形
题目：在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。
示例 1：
输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
输出：4
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: dp[i][j]: 表示以[i,j]位置为右下角的正方形的最小边长，若该位置为0,则最小边长为0,即dp[i][j]=0；若为1则最小边长为左边，上边，左上角的最小边的最小值，即 dp[i][j] = min(dp[i-1][j],dp[i[j-1], dp[i-1][j-1]) + 1
    
    # 
    def maximalSquare(self, matrix: List[List[str]]) -> int:

        # dp[i][j]: 表示以[i,j]位置为右下角的正方形的最小边长，若该位置为0,则最小边长为0,即dp[i][j]=0；若为1则最小边长为左边，上边，左上角的最小边的最小值，即 dp[i][j] = min(dp[i-1][j],dp[i[j-1], dp[i-1][j-1]) + 1
        m = len(matrix)
        n = len(matrix[0])
        dp = [[0 for _ in range(n)] for _ in range(m)]

        maxL = 0
        for i in range(m):
            for j in range(n):
                if i == 0 and j == 0:
                    if matrix[i][j] == '1':
                        dp[i][j] = 1
                    else:
                        dp[i][j] = 0
                elif i == 0:
                    if matrix[i][j] == '1':
                        dp[i][j] = 1
                    else:
                        dp[i][j] = 0
                elif j == 0:
                    if matrix[i][j] == '1':
                        dp[i][j] = 1
                    else:
                        dp[i][j] = 0
                else:
                    if matrix[i][j] == '1':
                        dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
                    else:
                        dp[i][j] = 0
                    
                maxL = max(maxL, dp[i][j])
        # print(dp)
        return maxL * maxL
                 
#### 2. 非递归
思路：
    
## 241. 为运算表达式设计优先级
题目：给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。

示例 1:
输入: "2-1-1"
输出: [0, 2]
解释: 
((2-1)-1) = 0 
(2-(1-1)) = 2
示例 2:
输入: "2*3-4*5"
输出: [-34, -14, -10, -10, 10]
解释: 
(2*(3-(4*5))) = -34 
((2*3)-(4*5)) = -14 
((2*(3-4))*5) = -10 
(2*((3-4)*5)) = -10 
(((2*3)-4)*5) = 10
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 分治算法。
    
    # 
    def diffWaysToCompute(self, expression: str) -> List[int]:
        if expression.isdigit():
            return [int(expression)]

        res = []
        # 分治算法: 
        for i, dig in enumerate(expression):
            if dig in ['+', '-', '*']:
                lefts = self.diffWaysToCompute(expression[0:i])
                rights = self.diffWaysToCompute(expression[i+1:])
                for l in lefts:
                    for r in rights:
                        if dig == '+':
                            res.append(l+r)
                        elif dig == '-':
                            res.append(l-r)
                        elif dig == '*':
                            res.append(l*r)
        return res
                 
#### 2. 非递归
思路：

## 264. 丑数 II
题目：给你一个整数 n ，请你找出并返回第 n 个 丑数 。
丑数 就是只包含质因数 2、3 和/或 5 的正整数。
    
示例 1：
输入：n = 10
输出：12
解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。
示例 2：
输入：n = 1
输出：1
解释：1 通常被视为丑数。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: dp[i]: 第i个丑数, dp[i] = min(2 * dp[index1], 3 * dp[index2], 5 * dp[index3])
    
    # 
    def nthUglyNumber(self, n: int) -> int:

        # dp[i]: 第i个丑数
        dp = [1] * n
        index1, index2, index3 = 0, 0, 0
        for i in range(n):
            if i == 0:
                dp[i] = 1
            else:
                dp[i] = min(2 * dp[index1], 3 * dp[index2], 5 * dp[index3])
                if 2 * dp[index1] == dp[i]:
                    index1 += 1
                if 3 * dp[index2] == dp[i]:
                    index2 += 1
                if 5 * dp[index3] == dp[i]:
                    index3 += 1
        print(dp)
        return dp[-1]
                 
#### 2. 非递归
思路：
    
## 279. 完全平方数
题目：给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。
给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。
完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。
    
示例 1：
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
示例 2：
输入：n = 13
输出：2
解释：13 = 4 + 9
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: dp[i]: 表示数i最少可以由多少个完全平方数构成
    
    # 
    def numSquares(self, n: int) -> int:

        # dp[i]: 表示数i最少可以由多少个完全平方数构成
        # dp[i] = min(dp[i], d[i - j*j] + 1)

        dp = [i for i in range(n+1)]

        for i in range(2, n+1):
            for j in range(1, int(i ** (0.5))  + 1):
                dp[i] = min(dp[i], dp[i - j * j] + 1)
        print(dp)
        return dp[-1] 
                 
#### 2. 非递归
思路：
    
## 300. 最长递增子序列
题目：给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

示例 1：
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
示例 2：
输入：nums = [0,1,0,3,2,3]
输出：4
示例 3：
输入：nums = [7,7,7,7,7,7,7]
输出：1
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: dp[i]:表示以[i]位置结尾的最长递增子序列
    
    # 
    def lengthOfLIS(self, nums: List[int]) -> int:

        # dp[i]:表示以[i]位置结尾的最长递增子序列
        # dp[i] = max(dp[i], d[j] + 1) , if nums[j] < nums[j] , 0 <= j < i

        n = len(nums)
        dp = [1] * n
        for i in range(n):
            for j in range(i):
                if nums[j] < nums[i]:
                    dp[i] = max(dp[i], dp[j] + 1)
        print(dp)
        return max(dp)
                 
#### 2. 非递归
思路：
    
## 309. 最佳买卖股票时机含冷冻期
题目：给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​
设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

示例:
输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: dp0: 无股票且非冷冻期，dp1: 无股票且冷冻期，dp2有股票, dp0 = max(dp0, dp1), 当天无股票且非冷冻期，可能是昨天也无股票且非冷冻期，或昨天无股票且处于冷冻期；dp1 = dp0 + prices, 当前无股票且处于冷冻期，是昨天有股票且卖掉了；dp2 = max(dp2, dp1-prices),当天有股票可能昨天也有股票或昨天处于非冷冻期今天买入
    
    # 
    def maxProfit(self, prices: List[int]) -> int:

        # dp0: 无股票且非冷冻期，dp1: 无股票且冷冻期，dp2有股票
        # dp0 = max(dp0, dp1), 当天无股票且非冷冻期，可能是昨天也无股票且非冷冻期，或昨天无股票且处于冷冻期；dp1 = dp0 + prices, 当前无股票且处于冷冻期，是昨天有股票且卖掉了；dp2 = max(dp2, dp1-prices),当天有股票可能昨天也有股票或昨天处于非冷冻期今天买入

        n = len(prices)
        dp0, dp1, dp2 = 0, 0, -prices[0]
        for i in range(1, n):
            new_dp0 = max(dp0, dp1)
            new_dp1 = dp2 + prices[i]
            new_dp2 = max(dp2, dp0-prices[i])
            dp0, dp1, dp2 = new_dp0, new_dp1, new_dp2
        print(dp0, dp1, dp2)
        return max(dp0, dp1)
                 
#### 2. 非递归
思路：
    
## 322. 零钱兑换
题目：给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。
计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。
你可以认为每种硬币的数量是无限的。

示例 1：
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
示例 2：
输入：coins = [2], amount = 3
输出：-1
示例 3：
输入：coins = [1], amount = 0
输出：0
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 完全背包问题：dp[i] = min(dp[i], dp[i-coins[j] + 1]), 凑成i元硬币需要的最少硬币数，为凑成i-coins[j] 需要的最少硬币数+一枚coins[j]硬币
    
    # 
    def coinChange(self, coins: List[int], amount: int) -> int:

        # 完全背包问题：dp[i] = min(dp[i], dp[i-coins[j] + 1]), 凑成i元硬币需要的最少硬币数，为凑成i-coins[j] 需要的最少硬币数+一枚coins[j]硬币
        n = len(coins)
        dp = [math.inf for _ in range(amount+1)]
        dp[0] = 0
        for i in range(1, amount+1):
            for j in range(n):
                if i - coins[j] >= 0:
                    dp[i] = min(dp[i], dp[i-coins[j]] + 1)
        print(dp)
        return dp[-1] if dp[-1] != math.inf else -1
                 
#### 2. 非递归
思路：
    
## 337. 打家劫舍 III
题目：在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。
计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 后续遍历，每个节点可以偷或不偷。
    
    # 
    def rob(self, root: TreeNode) -> int:

        def dfs(root):
            if not root:
                return 0, 0  # 偷，不偷
            left = dfs(root.left)
            right = dfs(root.right)
            # 偷当前节点，其左右两个孩子都不能偷
            v1 = root.val + left[1] + right[1]
            # 不偷当前节点，则左右两个孩子可以偷，可以不偷，取孩子最大值
            v2 = max(left[0], left[1]) + max(right[0], right[1])
            return v1, v2

        res = dfs(root)
        return max(res[0], res[1])
                 
#### 2. 非递归
思路：
    
## 343. 整数拆分
题目：给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

示例 1:
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
示例 2:
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 数学理论，记住即可。
    
    # 
    def integerBreak(self, n: int) -> int:

        memo = {2: 1}

        def dfs(n):
            nonlocal memo 
            if n in memo:
                return memo[n]

            if n == 2:
                return 1

            # 数学理论，记住即可。
            res = 0
            for i in range(1, n):
                res = max(res, max(i * dfs(n - i), i * (n - i)))
            memo[n] = res
            return res
        return dfs(n)
                 
#### 2. 非递归
思路：
