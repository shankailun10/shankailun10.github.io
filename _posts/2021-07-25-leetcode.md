# leetcodeé¢˜è§£
1. TOC
{:toc}

## 101. å¯¹ç§°äºŒå‰æ ‘
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ£€æŸ¥å®ƒæ˜¯å¦æ˜¯é•œåƒå¯¹ç§°çš„ã€‚
ä¾‹å¦‚ï¼ŒäºŒå‰æ ‘ [1,2,2,3,4,4,3] æ˜¯å¯¹ç§°çš„ã€‚ä½†æ˜¯ä¸‹é¢è¿™ä¸ª [1,2,2,null,3,null,3] åˆ™ä¸æ˜¯é•œåƒå¯¹ç§°çš„:

### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’

#### 2. éé€’å½’
æ€è·¯ï¼šåˆ¤æ–­æ ¹æ˜¯å¦ä¸ºç©ºï¼Œæ˜¯è¿”å›True, å¦åˆ¤æ–­å·¦å³ä¸¤ä¸ªå­©å­æ˜¯å¦ç›¸ç­‰ï¼Œæ˜¯ç»§ç»­åˆ¤æ–­å·¦å­©å­çš„å·¦èŠ‚ç‚¹å’Œå³å­©å­çš„å³èŠ‚ç‚¹æ˜¯å¦ç›¸ç­‰ï¼Œä»¥åŠå·¦å­©å­çš„å³èŠ‚ç‚¹å’Œå³å­©å­çš„å·¦èŠ‚ç‚¹æ˜¯å¦ç›¸ç­‰

    #é˜Ÿåˆ—ä»£ç 
    def getRes(root):
        if not root:
            return True
        queue = [(root.left, root.right)]
        while queue != []:
            left, right = queue.pop()
            if not left and not right:
                continue
            if left and right and left.val == right.val:
                queue.append((left.left, right.right))
                queue.append((left.right, right.left))
            else:
                return False
        return True
        
## 102. äºŒå‰æ ‘çš„å±‚åºéå†
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¯·ä½ è¿”å›å…¶æŒ‰ å±‚åºéå† å¾—åˆ°çš„èŠ‚ç‚¹å€¼ã€‚ ï¼ˆå³é€å±‚åœ°ï¼Œä»å·¦åˆ°å³è®¿é—®æ‰€æœ‰èŠ‚ç‚¹ï¼‰ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1ã€é€’å½’

#### 2. éé€’å½’
æ€è·¯ï¼šè‹¥æ ¹ä¸ºç©ºï¼Œè¿”å›[]ï¼Œè‹¥æ ¹ä¸ç©ºå°†æ ¹å…¥é˜Ÿåˆ—queueï¼Œç„¶åä¾æ¬¡éå†é˜Ÿåˆ—ä¸­çš„èŠ‚ç‚¹å€¼å­˜å…¥resï¼Œç„¶åä¾æ¬¡éå†é˜Ÿåˆ—ä¸­çš„èŠ‚ç‚¹ï¼ŒæŠŠè¯¥èŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹ã€å³èŠ‚ç‚¹ä¾æ¬¡å…¥å­é˜Ÿåˆ—l1ï¼Œå°†å­é˜Ÿåˆ—l1èµ‹å€¼ç»™queue,è¿”å›resã€‚

    # ä»£ç 
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        res, queue = [], [root]
        while queue:
            res.append([q.val for q in queue])
            l1 = []
            for q in queue:
                if q.left:
                    l1.append(q.left)
                if q.right:
                    l1.append(q.right)
            queue = l1
        return res
        

## 100. ç›¸åŒçš„æ ‘
é¢˜ç›®ï¼šç»™ä½ ä¸¤æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ p å’Œ q ï¼Œç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥æ£€éªŒè¿™ä¸¤æ£µæ ‘æ˜¯å¦ç›¸åŒã€‚å¦‚æœä¸¤ä¸ªæ ‘åœ¨ç»“æ„ä¸Šç›¸åŒï¼Œå¹¶ä¸”èŠ‚ç‚¹å…·æœ‰ç›¸åŒçš„å€¼ï¼Œåˆ™è®¤ä¸ºå®ƒä»¬æ˜¯ç›¸åŒçš„ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
####1. é€’å½’
æ€è·¯ï¼šæ¯”è¾ƒæ ¹èŠ‚ç‚¹æ˜¯å¦ç›¸ç­‰ï¼Œç„¶åé€’å½’æ¯”è¾ƒå·¦å­æ ‘èŠ‚ç‚¹å’Œå³å­æ ‘èŠ‚ç‚¹æ˜¯å¦ç›¸ç­‰ã€‚

    # ä»£ç 
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        if not p and not q:
            return True
        elif not p or not q:
            return False
        elif p.val != q.val:
            return False
        else:
            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)

####2. éé€’å½’
æ€è·¯ï¼šåŒæ—¶éå†ä¸¤æ£µæ ‘ï¼Œä¾æ¬¡æ¯”è¾ƒèŠ‚ç‚¹å€¼ï¼Œè‹¥å½“å‰å·¦å­æ ‘æˆ–å³å­æ ‘ä¸ºç©ºæ—¶ä¹Ÿå…¥é˜Ÿåˆ—ã€‚

## 104. äºŒå‰æ ‘æœ€å¤§æ·±åº¦
ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾å‡ºå…¶æœ€å¤§æ·±åº¦ã€‚
äºŒå‰æ ‘çš„æ·±åº¦ä¸ºæ ¹èŠ‚ç‚¹åˆ°æœ€è¿œå¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°ã€‚è¯´æ˜: å¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
####1. é€’å½’
æ€è·¯ï¼šè‹¥æ ¹ä¸ºç©ºï¼Œè¿”å›0ï¼Œè‹¥æ ¹ä¸ç©ºï¼Œåˆ™æœ€å¤§æ·±åº¦ä¸ºå·¦å­æ ‘æœ€å¤§æ·±åº¦å’Œå³å­æ ‘æœ€å¤§æ·±åº¦å–æœ€å¤§å€¼+1

    # ä»£ç 
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        l = self.maxDepth(root.left)
        r = self.maxDepth(root.right)
        return max(l, r) + 1

### 2. éé€’å½’
æ€è·¯ï¼šäºŒå‰æ ‘å±‚æ¬¡éå†ï¼Œè¿”å›æ•°ç»„é•¿åº¦ã€‚

## 108. å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œå…¶ä¸­å…ƒç´ å·²ç»æŒ‰ å‡åº æ’åˆ—ï¼Œè¯·ä½ å°†å…¶è½¬æ¢ä¸ºä¸€æ£µ é«˜åº¦å¹³è¡¡ äºŒå‰æœç´¢æ ‘ã€‚
é«˜åº¦å¹³è¡¡ äºŒå‰æ ‘æ˜¯ä¸€æ£µæ»¡è¶³ã€Œæ¯ä¸ªèŠ‚ç‚¹çš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡ 1 ã€çš„äºŒå‰æ ‘ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šå–æ•°ç»„ä¸­é—´ä½ç½®åšæ ¹ï¼Œä¸­é—´ä½ç½®çš„å·¦è¾¹éƒ¨åˆ†æ„å»ºå·¦å­æ ‘ï¼Œå³è¾¹éƒ¨åˆ†æ„å»ºå³å­æ ‘ã€‚

    # ä»£ç 
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        def mark_tree(s, e):
            if s > e:
                return None
            mid = (s + e) // 2
            sub_tree = TreeNode(nums[mid])
            sub_tree.left = mark_tree(s, mid - 1)
            sub_tree.right = mark_tree(mid + 1, e)
            return sub_tree
        return mark_tree(0, len(nums) - 1)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 110. å¹³è¡¡äºŒå‰æ ‘
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œåˆ¤æ–­å®ƒæ˜¯å¦æ˜¯é«˜åº¦å¹³è¡¡çš„äºŒå‰æ ‘ã€‚
æœ¬é¢˜ä¸­ï¼Œä¸€æ£µé«˜åº¦å¹³è¡¡äºŒå‰æ ‘å®šä¹‰ä¸ºï¼š
ä¸€ä¸ªäºŒå‰æ ‘æ¯ä¸ªèŠ‚ç‚¹ çš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡ 1 
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šè‹¥æ ¹ä¸ºç©ºï¼Œè¿”å›True,åˆ¤æ–­æ ¹çš„å·¦å³å­æ ‘é«˜åº¦å·®ç»å¯¹å€¼æ˜¯å¦<=1ï¼Œå¦ï¼šè¿”å›False,ä¾æ¬¡åˆ¤æ–­æ ¹çš„å·¦å­æ ‘ã€å³å­æ ‘æ˜¯å¦æ˜¯å¹³è¡¡æ ‘

    # ä»£ç 
    def isBalanced(self, root: TreeNode) -> bool:
        def maxDepth(node):
            if not node:
                return 0
            l = maxDepth(node.left)
            r = maxDepth(node.right)
            return max(l, r) + 1

        if not root:
            return True
        return abs(maxDepth(root.left) - maxDepth(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 111. äºŒå‰æ ‘çš„æœ€å°æ·±åº¦
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾å‡ºå…¶æœ€å°æ·±åº¦ã€‚æœ€å°æ·±åº¦æ˜¯ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿‘å¶å­èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°é‡ã€‚è¯´æ˜ï¼šå¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šå±‚åºéå†äºŒå‰æ ‘ï¼Œè®°å½•æ·±åº¦ï¼Œé‡åˆ°æŸä¸ªèŠ‚ç‚¹æ²¡æœ‰å·¦å­æ ‘æˆ–å³å­æ ‘ç›´æ¥è¿”å›æ·±åº¦å³å¯ã€‚

    # ä»£ç 
    def minDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        queue = [root]
        depth = 1
        while queue:
            l1 = []
            for q in queue:
                if not q.left and not q.right:
                    return depth
                if q.left:
                    l1.append(q.left)
                if q.right:
                    l1.append(q.right)
            queue = l1
            depth += 1
        return depth

#### 2. éé€’å½’
æ€è·¯ï¼š

## 112. è·¯å¾„æ€»å’Œ
é¢˜ç›®ï¼šç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹Â root å’Œä¸€ä¸ªè¡¨ç¤ºç›®æ ‡å’Œçš„æ•´æ•°Â targetSum ï¼Œåˆ¤æ–­è¯¥æ ‘ä¸­æ˜¯å¦å­˜åœ¨ æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹ çš„è·¯å¾„ï¼Œè¿™æ¡è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹å€¼ç›¸åŠ ç­‰äºç›®æ ‡å’ŒÂ targetSum ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šæ·±åº¦ä¼˜å…ˆéå†ï¼Œåˆ¤æ–­å½“å‰èŠ‚ç‚¹æ˜¯å¦æ˜¯å¶å­ç»“ç‚¹å¹¶ä¸”è·¯å¾„å’Œæ˜¯å¦ç­‰äºç»™å®šå€¼ï¼Œè‹¥æ˜¯åˆ™è¿”å›true,å¦åˆ™è¿”å›false

    # ä»£ç 
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if not root:
            return targetSum == 0

        if not root.left and not root.right and root.val == targetSum:
            return True
        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 144. äºŒå‰æ ‘çš„å‰åºéå†
é¢˜ç›®ï¼šç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å›å®ƒèŠ‚ç‚¹å€¼çš„ å‰åº éå†ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šæ·±åº¦ä¼˜å…ˆéå†ï¼Œä¸€æ¬¡æ‰“å°èŠ‚ç‚¹å€¼

    # ä»£ç 
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        
        res = []

        def dfs(node):
            if not node:
                return None
            res.append(node.val)
            dfs(node.left)
            dfs(node.right)
        
        dfs(root)
        return res

#### 2. éé€’å½’
æ€è·¯ï¼š

## 144. äºŒå‰æ ‘çš„ååºéå†
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¿”å›å®ƒçš„ ååº éå†ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šæ·±åº¦ä¼˜å…ˆéå†ï¼Œä¸€æ¬¡æ‰“å°èŠ‚ç‚¹å€¼

    # ä»£ç 
    def postorderTraversal(self, root: TreeNode) -> List[int]:

        res = []

        def dfs(node):
            if not node:
                return
            dfs(node.left)
            dfs(node.right)
            res.append(node.val)
        
        dfs(root)
        return res

#### 2. éé€’å½’
æ€è·¯ï¼š

## 226. ç¿»è½¬äºŒå‰æ ‘
é¢˜ç›®ï¼šç¿»è½¬ä¸€æ£µäºŒå‰æ ‘ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šé€’å½’éå†æ ¹èŠ‚ç‚¹ï¼Œäº¤æ¢å·¦å³èŠ‚ç‚¹å€¼ï¼Œéå†å·¦å­æ ‘ï¼Œéå†ğŸˆ¶å³å­æ ‘ï¼Œè¿”å›æ ¹èŠ‚ç‚¹ã€‚

    # ä»£ç 
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return None
        root.left, root.right = root.right, root.left
        self.invertTree(root.left)
        self.invertTree(root.right)
        return root

#### 2. éé€’å½’
æ€è·¯ï¼š



