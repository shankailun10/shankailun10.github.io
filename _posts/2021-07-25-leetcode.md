# leetcode题解
1. TOC
{:toc}

## 101. 对称二叉树
题目：给定一个二叉树，检查它是否是镜像对称的。
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归

#### 2. 非递归
思路：判断根是否为空，是返回True, 否判断左右两个孩子是否相等，是继续判断左孩子的左节点和右孩子的右节点是否相等，以及左孩子的右节点和右孩子的左节点是否相等

    #队列代码
    def getRes(root):
        if not root:
            return True
        queue = [(root.left, root.right)]
        while queue != []:
            left, right = queue.pop()
            if not left and not right:
                continue
            if left and right and left.val == right.val:
                queue.append((left.left, right.right))
                queue.append((left.right, right.left))
            else:
                return False
        return True
        
## 102. 二叉树的层序遍历
题目：给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1、递归

#### 2. 非递归
思路：若根为空，返回[]，若根不空将根入队列queue，然后依次遍历队列中的节点值存入res，然后依次遍历队列中的节点，把该节点的左节点、右节点依次入子队列l1，将子队列l1赋值给queue,返回res。

    # 代码
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        res, queue = [], [root]
        while queue:
            res.append([q.val for q in queue])
            l1 = []
            for q in queue:
                if q.left:
                    l1.append(q.left)
                if q.right:
                    l1.append(q.right)
            queue = l1
        return res
        

## 100. 相同的树
题目：给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
### 两种方法：1、递归实现，2. 非递归实现(队列)
####1. 递归
思路：比较根节点是否相等，然后递归比较左子树节点和右子树节点是否相等。

    # 代码
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        if not p and not q:
            return True
        elif not p or not q:
            return False
        elif p.val != q.val:
            return False
        else:
            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)

####2. 非递归
思路：同时遍历两棵树，依次比较节点值，若当前左子树或右子树为空时也入队列。

## 104. 二叉树最大深度
给定一个二叉树，找出其最大深度。
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明: 叶子节点是指没有子节点的节点。
### 两种方法：1、递归实现，2. 非递归实现(队列)
####1. 递归
思路：若根为空，返回0，若根不空，则最大深度为左子树最大深度和右子树最大深度取最大值+1

    # 代码
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        l = self.maxDepth(root.left)
        r = self.maxDepth(root.right)
        return max(l, r) + 1

### 2. 非递归
思路：二叉树层次遍历，返回数组长度。

## 108. 将有序数组转换为二叉搜索树
题目：给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。
高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：取数组中间位置做根，中间位置的左边部分构建左子树，右边部分构建右子树。

    # 代码
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        def mark_tree(s, e):
            if s > e:
                return None
            mid = (s + e) // 2
            sub_tree = TreeNode(nums[mid])
            sub_tree.left = mark_tree(s, mid - 1)
            sub_tree.right = mark_tree(mid + 1, e)
            return sub_tree
        return mark_tree(0, len(nums) - 1)

#### 2. 非递归
思路：

## 110. 平衡二叉树
题目：给定一个二叉树，判断它是否是高度平衡的二叉树。
本题中，一棵高度平衡二叉树定义为：
一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：若根为空，返回True,判断根的左右子树高度差绝对值是否<=1，否：返回False,依次判断根的左子树、右子树是否是平衡树

    # 代码
    def isBalanced(self, root: TreeNode) -> bool:
        def maxDepth(node):
            if not node:
                return 0
            l = maxDepth(node.left)
            r = maxDepth(node.right)
            return max(l, r) + 1

        if not root:
            return True
        return abs(maxDepth(root.left) - maxDepth(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)

#### 2. 非递归
思路：

## 111. 二叉树的最小深度
题目：给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。说明：叶子节点是指没有子节点的节点。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：层序遍历二叉树，记录深度，遇到某个节点没有左子树或右子树直接返回深度即可。

    # 代码
    def minDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        queue = [root]
        depth = 1
        while queue:
            l1 = []
            for q in queue:
                if not q.left and not q.right:
                    return depth
                if q.left:
                    l1.append(q.left)
                if q.right:
                    l1.append(q.right)
            queue = l1
            depth += 1
        return depth

#### 2. 非递归
思路：

## 112. 路径总和
题目：给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：深度优先遍历，判断当前节点是否是叶子结点并且路径和是否等于给定值，若是则返回true,否则返回false

    # 代码
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if not root:
            return targetSum == 0

        if not root.left and not root.right and root.val == targetSum:
            return True
        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)

#### 2. 非递归
思路：

## 144. 二叉树的前序遍历
题目：给你二叉树的根节点 root ，返回它节点值的 前序 遍历。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：深度优先遍历，一次打印节点值

    # 代码
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        
        res = []

        def dfs(node):
            if not node:
                return None
            res.append(node.val)
            dfs(node.left)
            dfs(node.right)
        
        dfs(root)
        return res

#### 2. 非递归
思路：

## 144. 二叉树的后序遍历
题目：给定一个二叉树，返回它的 后序 遍历。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：深度优先遍历，一次打印节点值

    # 代码
    def postorderTraversal(self, root: TreeNode) -> List[int]:

        res = []

        def dfs(node):
            if not node:
                return
            dfs(node.left)
            dfs(node.right)
            res.append(node.val)
        
        dfs(root)
        return res

#### 2. 非递归
思路：

## 226. 翻转二叉树
题目：翻转一棵二叉树。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：递归遍历根节点，交换左右节点值，遍历左子树，遍历🈶右子树，返回根节点。

    # 代码
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return None
        root.left, root.right = root.right, root.left
        self.invertTree(root.left)
        self.invertTree(root.right)
        return root

#### 2. 非递归
思路：



