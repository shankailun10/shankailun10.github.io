# leetcode题解
1. TOC
{:toc}

## 101. 对称二叉树
题目：给定一个二叉树，检查它是否是镜像对称的。
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归

#### 2. 非递归
思路：判断根是否为空，是返回True, 否判断左右两个孩子是否相等，是继续判断左孩子的左节点和右孩子的右节点是否相等，以及左孩子的右节点和右孩子的左节点是否相等

    #队列代码
    def getRes(root):
        if not root:
            return True
        queue = [(root.left, root.right)]
        while queue != []:
            left, right = queue.pop()
            if not left and not right:
                continue
            if left and right and left.val == right.val:
                queue.append((left.left, right.right))
                queue.append((left.right, right.left))
            else:
                return False
        return True
        
## 102. 二叉树的层序遍历
题目：给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归

#### 2. 非递归
思路：若根为空，返回[]，若根不空将根入队列queue，然后依次遍历队列中的节点值存入res，然后依次遍历队列中的节点，把该节点的左节点、右节点依次入子队列l1，将子队列l1赋值给queue,返回res。

    # 代码
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        res, queue = [], [root]
        while queue:
            res.append([q.val for q in queue])
            l1 = []
            for q in queue:
                if q.left:
                    l1.append(q.left)
                if q.right:
                    l1.append(q.right)
            queue = l1
        return res
        

### 103. 


