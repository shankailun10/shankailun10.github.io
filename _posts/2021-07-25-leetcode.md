# leetcodeé¢˜è§£
1. TOC
{:toc}

## 101. å¯¹ç§°äºŒå‰æ ‘
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ£€æŸ¥å®ƒæ˜¯å¦æ˜¯é•œåƒå¯¹ç§°çš„ã€‚
ä¾‹å¦‚ï¼ŒäºŒå‰æ ‘ [1,2,2,3,4,4,3] æ˜¯å¯¹ç§°çš„ã€‚ä½†æ˜¯ä¸‹é¢è¿™ä¸ª [1,2,2,null,3,null,3] åˆ™ä¸æ˜¯é•œåƒå¯¹ç§°çš„:

### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’

#### 2. éé€’å½’
æ€è·¯ï¼šåˆ¤æ–­æ ¹æ˜¯å¦ä¸ºç©ºï¼Œæ˜¯è¿”å›True, å¦åˆ¤æ–­å·¦å³ä¸¤ä¸ªå­©å­æ˜¯å¦ç›¸ç­‰ï¼Œæ˜¯ç»§ç»­åˆ¤æ–­å·¦å­©å­çš„å·¦èŠ‚ç‚¹å’Œå³å­©å­çš„å³èŠ‚ç‚¹æ˜¯å¦ç›¸ç­‰ï¼Œä»¥åŠå·¦å­©å­çš„å³èŠ‚ç‚¹å’Œå³å­©å­çš„å·¦èŠ‚ç‚¹æ˜¯å¦ç›¸ç­‰

    #é˜Ÿåˆ—ä»£ç 
    def getRes(root):
        if not root:
            return True
        queue = [(root.left, root.right)]
        while queue != []:
            left, right = queue.pop()
            if not left and not right:
                continue
            if left and right and left.val == right.val:
                queue.append((left.left, right.right))
                queue.append((left.right, right.left))
            else:
                return False
        return True
        
## 102. äºŒå‰æ ‘çš„å±‚åºéå†
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¯·ä½ è¿”å›å…¶æŒ‰ å±‚åºéå† å¾—åˆ°çš„èŠ‚ç‚¹å€¼ã€‚ ï¼ˆå³é€å±‚åœ°ï¼Œä»å·¦åˆ°å³è®¿é—®æ‰€æœ‰èŠ‚ç‚¹ï¼‰ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1ã€é€’å½’

#### 2. éé€’å½’
æ€è·¯ï¼šè‹¥æ ¹ä¸ºç©ºï¼Œè¿”å›[]ï¼Œè‹¥æ ¹ä¸ç©ºå°†æ ¹å…¥é˜Ÿåˆ—queueï¼Œç„¶åä¾æ¬¡éå†é˜Ÿåˆ—ä¸­çš„èŠ‚ç‚¹å€¼å­˜å…¥resï¼Œç„¶åä¾æ¬¡éå†é˜Ÿåˆ—ä¸­çš„èŠ‚ç‚¹ï¼ŒæŠŠè¯¥èŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹ã€å³èŠ‚ç‚¹ä¾æ¬¡å…¥å­é˜Ÿåˆ—l1ï¼Œå°†å­é˜Ÿåˆ—l1èµ‹å€¼ç»™queue,è¿”å›resã€‚

    # ä»£ç 
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        res, queue = [], [root]
        while queue:
            res.append([q.val for q in queue])
            l1 = []
            for q in queue:
                if q.left:
                    l1.append(q.left)
                if q.right:
                    l1.append(q.right)
            queue = l1
        return res
        

## 100. ç›¸åŒçš„æ ‘
é¢˜ç›®ï¼šç»™ä½ ä¸¤æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ p å’Œ q ï¼Œç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥æ£€éªŒè¿™ä¸¤æ£µæ ‘æ˜¯å¦ç›¸åŒã€‚å¦‚æœä¸¤ä¸ªæ ‘åœ¨ç»“æ„ä¸Šç›¸åŒï¼Œå¹¶ä¸”èŠ‚ç‚¹å…·æœ‰ç›¸åŒçš„å€¼ï¼Œåˆ™è®¤ä¸ºå®ƒä»¬æ˜¯ç›¸åŒçš„ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
####1. é€’å½’
æ€è·¯ï¼šæ¯”è¾ƒæ ¹èŠ‚ç‚¹æ˜¯å¦ç›¸ç­‰ï¼Œç„¶åé€’å½’æ¯”è¾ƒå·¦å­æ ‘èŠ‚ç‚¹å’Œå³å­æ ‘èŠ‚ç‚¹æ˜¯å¦ç›¸ç­‰ã€‚

    # ä»£ç 
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        if not p and not q:
            return True
        elif not p or not q:
            return False
        elif p.val != q.val:
            return False
        else:
            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)

####2. éé€’å½’
æ€è·¯ï¼šåŒæ—¶éå†ä¸¤æ£µæ ‘ï¼Œä¾æ¬¡æ¯”è¾ƒèŠ‚ç‚¹å€¼ï¼Œè‹¥å½“å‰å·¦å­æ ‘æˆ–å³å­æ ‘ä¸ºç©ºæ—¶ä¹Ÿå…¥é˜Ÿåˆ—ã€‚

## 104. äºŒå‰æ ‘æœ€å¤§æ·±åº¦
ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾å‡ºå…¶æœ€å¤§æ·±åº¦ã€‚
äºŒå‰æ ‘çš„æ·±åº¦ä¸ºæ ¹èŠ‚ç‚¹åˆ°æœ€è¿œå¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°ã€‚è¯´æ˜: å¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
####1. é€’å½’
æ€è·¯ï¼šè‹¥æ ¹ä¸ºç©ºï¼Œè¿”å›0ï¼Œè‹¥æ ¹ä¸ç©ºï¼Œåˆ™æœ€å¤§æ·±åº¦ä¸ºå·¦å­æ ‘æœ€å¤§æ·±åº¦å’Œå³å­æ ‘æœ€å¤§æ·±åº¦å–æœ€å¤§å€¼+1

    # ä»£ç 
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        l = self.maxDepth(root.left)
        r = self.maxDepth(root.right)
        return max(l, r) + 1

### 2. éé€’å½’
æ€è·¯ï¼šäºŒå‰æ ‘å±‚æ¬¡éå†ï¼Œè¿”å›æ•°ç»„é•¿åº¦ã€‚

## 108. å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œå…¶ä¸­å…ƒç´ å·²ç»æŒ‰ å‡åº æ’åˆ—ï¼Œè¯·ä½ å°†å…¶è½¬æ¢ä¸ºä¸€æ£µ é«˜åº¦å¹³è¡¡ äºŒå‰æœç´¢æ ‘ã€‚
é«˜åº¦å¹³è¡¡ äºŒå‰æ ‘æ˜¯ä¸€æ£µæ»¡è¶³ã€Œæ¯ä¸ªèŠ‚ç‚¹çš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡ 1 ã€çš„äºŒå‰æ ‘ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šå–æ•°ç»„ä¸­é—´ä½ç½®åšæ ¹ï¼Œä¸­é—´ä½ç½®çš„å·¦è¾¹éƒ¨åˆ†æ„å»ºå·¦å­æ ‘ï¼Œå³è¾¹éƒ¨åˆ†æ„å»ºå³å­æ ‘ã€‚

    # ä»£ç 
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        def mark_tree(s, e):
            if s > e:
                return None
            mid = (s + e) // 2
            sub_tree = TreeNode(nums[mid])
            sub_tree.left = mark_tree(s, mid - 1)
            sub_tree.right = mark_tree(mid + 1, e)
            return sub_tree
        return mark_tree(0, len(nums) - 1)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 110. å¹³è¡¡äºŒå‰æ ‘
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œåˆ¤æ–­å®ƒæ˜¯å¦æ˜¯é«˜åº¦å¹³è¡¡çš„äºŒå‰æ ‘ã€‚
æœ¬é¢˜ä¸­ï¼Œä¸€æ£µé«˜åº¦å¹³è¡¡äºŒå‰æ ‘å®šä¹‰ä¸ºï¼š
ä¸€ä¸ªäºŒå‰æ ‘æ¯ä¸ªèŠ‚ç‚¹ çš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡ 1 
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šè‹¥æ ¹ä¸ºç©ºï¼Œè¿”å›True,åˆ¤æ–­æ ¹çš„å·¦å³å­æ ‘é«˜åº¦å·®ç»å¯¹å€¼æ˜¯å¦<=1ï¼Œå¦ï¼šè¿”å›False,ä¾æ¬¡åˆ¤æ–­æ ¹çš„å·¦å­æ ‘ã€å³å­æ ‘æ˜¯å¦æ˜¯å¹³è¡¡æ ‘

    # ä»£ç 
    def isBalanced(self, root: TreeNode) -> bool:
        def maxDepth(node):
            if not node:
                return 0
            l = maxDepth(node.left)
            r = maxDepth(node.right)
            return max(l, r) + 1

        if not root:
            return True
        return abs(maxDepth(root.left) - maxDepth(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 111. äºŒå‰æ ‘çš„æœ€å°æ·±åº¦
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾å‡ºå…¶æœ€å°æ·±åº¦ã€‚æœ€å°æ·±åº¦æ˜¯ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿‘å¶å­èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°é‡ã€‚è¯´æ˜ï¼šå¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šå±‚åºéå†äºŒå‰æ ‘ï¼Œè®°å½•æ·±åº¦ï¼Œé‡åˆ°æŸä¸ªèŠ‚ç‚¹æ²¡æœ‰å·¦å­æ ‘æˆ–å³å­æ ‘ç›´æ¥è¿”å›æ·±åº¦å³å¯ã€‚

    # ä»£ç 
    def minDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        queue = [root]
        depth = 1
        while queue:
            l1 = []
            for q in queue:
                if not q.left and not q.right:
                    return depth
                if q.left:
                    l1.append(q.left)
                if q.right:
                    l1.append(q.right)
            queue = l1
            depth += 1
        return depth

#### 2. éé€’å½’
æ€è·¯ï¼š

## 112. è·¯å¾„æ€»å’Œ
é¢˜ç›®ï¼šç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹Â root å’Œä¸€ä¸ªè¡¨ç¤ºç›®æ ‡å’Œçš„æ•´æ•°Â targetSum ï¼Œåˆ¤æ–­è¯¥æ ‘ä¸­æ˜¯å¦å­˜åœ¨ æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹ çš„è·¯å¾„ï¼Œè¿™æ¡è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹å€¼ç›¸åŠ ç­‰äºç›®æ ‡å’ŒÂ targetSum ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šæ·±åº¦ä¼˜å…ˆéå†ï¼Œåˆ¤æ–­å½“å‰èŠ‚ç‚¹æ˜¯å¦æ˜¯å¶å­ç»“ç‚¹å¹¶ä¸”è·¯å¾„å’Œæ˜¯å¦ç­‰äºç»™å®šå€¼ï¼Œè‹¥æ˜¯åˆ™è¿”å›true,å¦åˆ™è¿”å›false

    # ä»£ç 
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if not root:
            return targetSum == 0

        if not root.left and not root.right and root.val == targetSum:
            return True
        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 144. äºŒå‰æ ‘çš„å‰åºéå†
é¢˜ç›®ï¼šç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å›å®ƒèŠ‚ç‚¹å€¼çš„ å‰åº éå†ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šæ·±åº¦ä¼˜å…ˆéå†ï¼Œä¸€æ¬¡æ‰“å°èŠ‚ç‚¹å€¼

    # ä»£ç 
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        
        res = []

        def dfs(node):
            if not node:
                return None
            res.append(node.val)
            dfs(node.left)
            dfs(node.right)
        
        dfs(root)
        return res

#### 2. éé€’å½’
æ€è·¯ï¼š

## 144. äºŒå‰æ ‘çš„ååºéå†
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¿”å›å®ƒçš„ ååº éå†ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šæ·±åº¦ä¼˜å…ˆéå†ï¼Œä¸€æ¬¡æ‰“å°èŠ‚ç‚¹å€¼

    # ä»£ç 
    def postorderTraversal(self, root: TreeNode) -> List[int]:

        res = []

        def dfs(node):
            if not node:
                return
            dfs(node.left)
            dfs(node.right)
            res.append(node.val)
        
        dfs(root)
        return res

#### 2. éé€’å½’
æ€è·¯ï¼š

## 226. ç¿»è½¬äºŒå‰æ ‘
é¢˜ç›®ï¼šç¿»è½¬ä¸€æ£µäºŒå‰æ ‘ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šé€’å½’éå†æ ¹èŠ‚ç‚¹ï¼Œäº¤æ¢å·¦å³èŠ‚ç‚¹å€¼ï¼Œéå†å·¦å­æ ‘ï¼Œéå†ğŸˆ¶å³å­æ ‘ï¼Œè¿”å›æ ¹èŠ‚ç‚¹ã€‚

    # ä»£ç 
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return None
        root.left, root.right = root.right, root.left
        self.invertTree(root.left)
        self.invertTree(root.right)
        return root

#### 2. éé€’å½’
æ€è·¯ï¼š



## 235. äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æœç´¢æ ‘, æ‰¾åˆ°è¯¥æ ‘ä¸­ä¸¤ä¸ªæŒ‡å®šèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚
ç™¾åº¦ç™¾ç§‘ä¸­æœ€è¿‘å…¬å…±ç¥–å…ˆçš„å®šä¹‰ä¸ºï¼šâ€œå¯¹äºæœ‰æ ¹æ ‘ T çš„ä¸¤ä¸ªç»“ç‚¹ pã€qï¼Œæœ€è¿‘å…¬å…±ç¥–å…ˆè¡¨ç¤ºä¸ºä¸€ä¸ªç»“ç‚¹ xï¼Œæ»¡è¶³ x æ˜¯ pã€q çš„ç¥–å…ˆä¸” x çš„æ·±åº¦å°½å¯èƒ½å¤§ï¼ˆä¸€ä¸ªèŠ‚ç‚¹ä¹Ÿå¯ä»¥æ˜¯å®ƒè‡ªå·±çš„ç¥–å…ˆï¼‰ã€‚â€
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šç”±äºæ˜¯äºŒå‰æœç´¢æ ‘ï¼Œæœ€è¿‘å…¬å…±ç¥–å…ˆçš„å€¼ä¸€å®šåœ¨p,qå€¼çš„ä¸­é—´ï¼Œå› æ­¤å¯éå†äºŒå‰æœç´¢æ ‘ï¼Œå¯»æ‰¾åœ¨ä¸­é—´çš„èŠ‚ç‚¹ã€‚

    # ä»£ç 
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if p.val < root.val and q.val < root.val:
            return self.lowestCommonAncestor(root.left, p, q)
        elif p.val > root.val and q.val >root.val:
            return self.lowestCommonAncestor(root.right, p, q)
        else:
            return root

#### 2. éé€’å½’
æ€è·¯ï¼š

## 257. äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼ŒæŒ‰ ä»»æ„é¡ºåº ï¼Œè¿”å›æ‰€æœ‰ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ã€‚å¶å­èŠ‚ç‚¹ æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šæ·±åº¦ä¼˜å…ˆéå†ï¼Œéå†æ—¶è®°å½•å½“å‰è·¯å¾„å³å¯ã€‚

    # ä»£ç 
    def binaryTreePaths(self, root: TreeNode) -> List[str]:

        res = []
    
        def dfs(root, path):
            if not root:
                return
            if not root.left and not root.right:
                path += (str(root.val))
            else:
                path += (str(root.val) + '->')
            if not root.left and not root.right:
                res.append(path)
            dfs(root.left, path)
            dfs(root.right, path)
        
        dfs(root, '')
        return res

#### 2. éé€’å½’
æ€è·¯ï¼š

## 404. å·¦å¶å­ä¹‹å’Œ
é¢˜ç›®ï¼šè®¡ç®—ç»™å®šäºŒå‰æ ‘çš„æ‰€æœ‰å·¦å¶å­ä¹‹å’Œã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šæ·±åº¦ä¼˜å…ˆéå†ï¼Œéå†æ—¶è®°å½•å½“å‰è·¯å¾„å³å¯ã€‚

    # ä»£ç 
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        
        self.num = 0

        def dfs(root, flag):
            if not root:
                return
            if not root.left and not root.right and flag == 1:
                self.num += root.val
            dfs(root.left, 1)
            dfs(root.right, 0)
        
        dfs(root, 0)
        
        return self.num

#### 2. éé€’å½’
æ€è·¯ï¼š

## 501. äºŒå‰æœç´¢æ ‘ä¸­çš„ä¼—æ•°
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªæœ‰ç›¸åŒå€¼çš„äºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰ï¼Œæ‰¾å‡º BST ä¸­çš„æ‰€æœ‰ä¼—æ•°ï¼ˆå‡ºç°é¢‘ç‡æœ€é«˜çš„å…ƒç´ ï¼‰ã€‚
å‡å®š BST æœ‰å¦‚ä¸‹å®šä¹‰ï¼š
ç»“ç‚¹å·¦å­æ ‘ä¸­æ‰€å«ç»“ç‚¹çš„å€¼å°äºç­‰äºå½“å‰ç»“ç‚¹çš„å€¼
ç»“ç‚¹å³å­æ ‘ä¸­æ‰€å«ç»“ç‚¹çš„å€¼å¤§äºç­‰äºå½“å‰ç»“ç‚¹çš„å€¼
å·¦å­æ ‘å’Œå³å­æ ‘éƒ½æ˜¯äºŒå‰æœç´¢æ ‘
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šä¸­åºéå†ï¼Œè¾¹éå†è¾¹è®°å½•å½“å‰å‡ºç°æœ€å¤§å€¼å³å¯ã€‚

    # ä»£ç 
    def findMode(self, root: TreeNode) -> List[int]:

        self.res = []
        self.pre = None  # å‰ä¸€ä¸ªèŠ‚ç‚¹
        self.current_count = 0 # å½“å‰èŠ‚ç‚¹é‡å¤æ•°é‡
        self.max_count = 0 # å½“å‰æœ€å¤§æ•°é‡

        def dfs(root):
            if not root:
                return 
            dfs(root.left)
            if self.pre and self.pre.val == root.val:
                self.current_count += 1
            else:
                self.current_count = 1
            self.pre = root
            if self.current_count == self.max_count:
                self.res.append(root.val)
            elif self.current_count > self.max_count:
                self.max_count = self.current_count
                self.res.clear()
                self.res.append(root.val)

            dfs(root.right)
        
        dfs(root)
        return self.res

#### 2. éé€’å½’
æ€è·¯ï¼š

## 530. äºŒå‰æœç´¢æ ‘çš„æœ€å°ç»å¯¹å·®
é¢˜ç›®ï¼šç»™ä½ ä¸€æ£µæ‰€æœ‰èŠ‚ç‚¹ä¸ºéè´Ÿå€¼çš„äºŒå‰æœç´¢æ ‘ï¼Œè¯·ä½ è®¡ç®—æ ‘ä¸­ä»»æ„ä¸¤èŠ‚ç‚¹çš„å·®çš„ç»å¯¹å€¼çš„æœ€å°å€¼ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šä¸­åºéå†ï¼Œæ‹¿å½“å‰èŠ‚ç‚¹å’Œå‰ä¸€èŠ‚ç‚¹æ¯”è¾ƒæ±‚å‡ºæœ€å°å€¼å³å¯ã€‚

    # ä»£ç 
    def getMinimumDifference(self, root: TreeNode) -> int:

        value = float('inf')
        pre = None

        def dfs(root):
            nonlocal value, pre
            if not root:
                return 
            dfs(root.left)
            if pre and abs(pre.val - root.val) < value:
                value = abs(pre.val - root.val)
            pre = root
            dfs(root.right)

        dfs(root)
        return value

#### 2. éé€’å½’
æ€è·¯ï¼š

## 543. äºŒå‰æ ‘çš„ç›´å¾„
é¢˜ç›®ï¼šç»™å®šä¸€æ£µäºŒå‰æ ‘ï¼Œä½ éœ€è¦è®¡ç®—å®ƒçš„ç›´å¾„é•¿åº¦ã€‚ä¸€æ£µäºŒå‰æ ‘çš„ç›´å¾„é•¿åº¦æ˜¯ä»»æ„ä¸¤ä¸ªç»“ç‚¹è·¯å¾„é•¿åº¦ä¸­çš„æœ€å¤§å€¼ã€‚è¿™æ¡è·¯å¾„å¯èƒ½ç©¿è¿‡ä¹Ÿå¯èƒ½ä¸ç©¿è¿‡æ ¹ç»“ç‚¹ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šæ±‚ä»¥æ¯ä¸ªèŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„æœ€å¤§é«˜åº¦ï¼Œè®°å½•æœ€å¤§å€¼å³å¯ã€‚

    # ä»£ç 
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        max_v = 0

        def depth(root):
            nonlocal max_v
            if not root:
                return 0
            l = depth(root.left)
            r = depth(root.right)
            max_v = max(max_v, l+r+1)
            return max(l, r) + 1

        depth(root)
        return max_v-1

#### 2. éé€’å½’
æ€è·¯ï¼š

## 559. N å‰æ ‘çš„æœ€å¤§æ·±åº¦
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ª N å‰æ ‘ï¼Œæ‰¾åˆ°å…¶æœ€å¤§æ·±åº¦ã€‚æœ€å¤§æ·±åº¦æ˜¯æŒ‡ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿œå¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ€»æ•°ã€‚
N å‰æ ‘è¾“å…¥æŒ‰å±‚åºéå†åºåˆ—åŒ–è¡¨ç¤ºï¼Œæ¯ç»„å­èŠ‚ç‚¹ç”±ç©ºå€¼åˆ†éš”ï¼ˆè¯·å‚è§ç¤ºä¾‹ï¼‰ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šè‹¥æ ¹ä¸ºç©ºï¼Œè¿”å›é«˜åº¦ä¸º0ï¼Œè‹¥æ ¹çš„æ‰€æœ‰childrenå­èŠ‚ç‚¹ä¸ºç©ºï¼ˆæ ¹æ˜¯å¶å­èŠ‚ç‚¹ï¼‰ï¼Œè¿”å›é«˜åº¦ä¸º1ï¼›é€’å½’æ±‚å‡ºæ¯ä¸€ä¸ªå­èŠ‚ç‚¹æ ‘çš„é«˜åº¦ï¼Œå¾—å‡ºæœ€å¤§å€¼å³å¯ã€‚

    # ä»£ç 
    def maxDepth(self, root: 'Node') -> int:

        def dfs(root):
            nonlocal max_d
            if not root:
                return 0
            if not root.children:
                return 1
            height = []
            for cl in root.children:
                height.append(dfs(cl))
            return max(height) + 1

        max_d = dfs(root)
        return max_d

#### 2. éé€’å½’
æ€è·¯ï¼š

## 563. äºŒå‰æ ‘çš„å¡åº¦
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè®¡ç®— æ•´ä¸ªæ ‘ çš„å¡åº¦ ã€‚
ä¸€ä¸ªæ ‘çš„ èŠ‚ç‚¹çš„å¡åº¦ å®šä¹‰å³ä¸ºï¼Œè¯¥èŠ‚ç‚¹å·¦å­æ ‘çš„èŠ‚ç‚¹ä¹‹å’Œå’Œå³å­æ ‘èŠ‚ç‚¹ä¹‹å’Œçš„ å·®çš„ç»å¯¹å€¼ ã€‚å¦‚æœæ²¡æœ‰å·¦å­æ ‘çš„è¯ï¼Œå·¦å­æ ‘çš„èŠ‚ç‚¹ä¹‹å’Œä¸º 0 ï¼›æ²¡æœ‰å³å­æ ‘çš„è¯ä¹Ÿæ˜¯ä¸€æ ·ã€‚ç©ºç»“ç‚¹çš„å¡åº¦æ˜¯ 0 ã€‚
æ•´ä¸ªæ ‘ çš„å¡åº¦å°±æ˜¯å…¶æ‰€æœ‰èŠ‚ç‚¹çš„å¡åº¦ä¹‹å’Œã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šæ±‚ä»¥æŸä¸ªèŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„çš„æ ‘çš„å€¼æ€»å’Œï¼Œå³å·¦èŠ‚ç‚¹æ€»å’Œ+å³èŠ‚ç‚¹æ€»å’Œ+è‡ªèº«å€¼ï¼Œå…¶ä¸­ï¼Œå·¦èŠ‚ç‚¹æ€»å’Œå’Œå³èŠ‚ç‚¹æ€»å’Œå·®çš„ç»å¯¹å€¼å³ä¸ºå½“å‰èŠ‚ç‚¹çš„å¡åº¦ï¼Œå¯¹æ‰€æœ‰èŠ‚ç‚¹æ±‚å¡åº¦ç„¶ååšåŠ å’Œå³ä¸ºæ ‘çš„å¡åº¦ã€‚

    # ä»£ç 
    def findTilt(self, root: TreeNode) -> int:
        res = 0

        # æ±‚ä»¥æŸä¸ªèŠ‚ç‚¹ä¸ºæ ¹çš„æ€»å’Œ
        def getNodeSum(root):
            nonlocal res
            if not root:
                return 0
            ls = getNodeSum(root.left)
            rs = getNodeSum(root.right)
            res += abs(ls - rs)
            return ls+rs+root.val

        getNodeSum(root)

        return res

#### 2. éé€’å½’
æ€è·¯ï¼š

## 572. å¦ä¸€æ£µæ ‘çš„å­æ ‘
é¢˜ç›®ï¼šç»™ä½ ä¸¤æ£µäºŒå‰æ ‘ root å’Œ subRoot ã€‚æ£€éªŒ root ä¸­æ˜¯å¦åŒ…å«å’Œ subRoot å…·æœ‰ç›¸åŒç»“æ„å’ŒèŠ‚ç‚¹å€¼çš„å­æ ‘ã€‚å¦‚æœå­˜åœ¨ï¼Œè¿”å› true ï¼›å¦åˆ™ï¼Œè¿”å› false ã€‚
äºŒå‰æ ‘ tree çš„ä¸€æ£µå­æ ‘åŒ…æ‹¬ tree çš„æŸä¸ªèŠ‚ç‚¹å’Œè¿™ä¸ªèŠ‚ç‚¹çš„æ‰€æœ‰åä»£èŠ‚ç‚¹ã€‚tree ä¹Ÿå¯ä»¥çœ‹åšå®ƒè‡ªèº«çš„ä¸€æ£µå­æ ‘ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šéå†rootæ¯ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä»¥æ¯ä¸ªå­èŠ‚ç‚¹æ ‘ä¸ºæ ¹åˆ¤æ–­æ˜¯å¦æ˜¯ç›¸åŒçš„æ ‘ã€‚

    # ä»£ç 
    def isSubtree(self, root: TreeNode, subRoot: TreeNode) -> bool:

        # ä»¥p, q ä¸ºæ ¹èŠ‚ç‚¹çš„ä¸¤é¢—äºŒå‰æ ‘æ˜¯å¦ä¸ºç›¸åŒçš„æ ‘
        def isSambleTree(p, q):
            if not p and not q:
                return True
            elif not q or not p:
                return False
            elif p.val != q.val:
                return False
            else:
                return isSambleTree(p.left, q.left) and isSambleTree(p.right, q.right)
        
        # éå†rootæ ‘ï¼Œå¹¶åˆ¤æ–­æ˜¯å¦ä¸ºç›¸åŒçš„æ ‘
        def dfs(root, subRoot):
            if not root and not subRoot:
                return True
            if not root or not subRoot:
                return False
            else:
                return isSambleTree(root, subRoot) or dfs(root.left, subRoot) or dfs(root.right, subRoot)

        # æ³•2
        def dfs2(root, subRoot):
            if not root:
                return False
            if root.val == subRoot.val:
                if isSambleTree(root, subRoot):
                    return True
        
            return dfs2(root.left, subRoot) or dfs2(root.right, subRoot)
        
        return dfs2(root, subRoot)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 589. N å‰æ ‘çš„å‰åºéå†
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ª N å‰æ ‘ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„ å‰åºéå† ã€‚N å‰æ ‘ åœ¨è¾“å…¥ä¸­æŒ‰å±‚åºéå†è¿›è¡Œåºåˆ—åŒ–è¡¨ç¤ºï¼Œæ¯ç»„å­èŠ‚ç‚¹ç”±ç©ºå€¼ null åˆ†éš”ï¼ˆè¯·å‚è§ç¤ºä¾‹ï¼‰ã€‚
è¿›é˜¶ï¼šé€’å½’æ³•å¾ˆç®€å•ï¼Œä½ å¯ä»¥ä½¿ç”¨è¿­ä»£æ³•å®Œæˆæ­¤é¢˜å—?
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šä¾æ¬¡éå†å³å¯ã€‚

    # ä»£ç 
    def preorder(self, root: 'Node') -> List[int]:
        res = []

        def dfs(root):
            nonlocal res
            if not root:
                return 
            res.append(root.val)
            for cl in root.children:
                dfs(cl)
        
        dfs(root)
        return res


#### 2. éé€’å½’
æ€è·¯ï¼š

## 590. N å‰æ ‘çš„ååºéå†
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ª N å‰æ ‘ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„ ååºéå† ã€‚N å‰æ ‘ åœ¨è¾“å…¥ä¸­æŒ‰å±‚åºéå†è¿›è¡Œåºåˆ—åŒ–è¡¨ç¤ºï¼Œæ¯ç»„å­èŠ‚ç‚¹ç”±ç©ºå€¼ null åˆ†éš”ï¼ˆè¯·å‚è§ç¤ºä¾‹ï¼‰ã€‚
è¿›é˜¶ï¼šé€’å½’æ³•å¾ˆç®€å•ï¼Œä½ å¯ä»¥ä½¿ç”¨è¿­ä»£æ³•å®Œæˆæ­¤é¢˜å—?
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šä¾æ¬¡éå†å³å¯ã€‚

    # ä»£ç 
    def postorder(self, root: 'Node') -> List[int]:

        res = []

        def dfs(root):
            nonlocal res
            if not root:
                return 
            for cl in root.children:
                dfs(cl)
            res.append(root.val)

        dfs(root)
        return res


#### 2. éé€’å½’
æ€è·¯ï¼š

## 617. åˆå¹¶äºŒå‰æ ‘
é¢˜ç›®ï¼šç»™å®šä¸¤ä¸ªäºŒå‰æ ‘ï¼Œæƒ³è±¡å½“ä½ å°†å®ƒä»¬ä¸­çš„ä¸€ä¸ªè¦†ç›–åˆ°å¦ä¸€ä¸ªä¸Šæ—¶ï¼Œä¸¤ä¸ªäºŒå‰æ ‘çš„ä¸€äº›èŠ‚ç‚¹ä¾¿ä¼šé‡å ã€‚
ä½ éœ€è¦å°†ä»–ä»¬åˆå¹¶ä¸ºä¸€ä¸ªæ–°çš„äºŒå‰æ ‘ã€‚åˆå¹¶çš„è§„åˆ™æ˜¯å¦‚æœä¸¤ä¸ªèŠ‚ç‚¹é‡å ï¼Œé‚£ä¹ˆå°†ä»–ä»¬çš„å€¼ç›¸åŠ ä½œä¸ºèŠ‚ç‚¹åˆå¹¶åçš„æ–°å€¼ï¼Œå¦åˆ™ä¸ä¸ºÂ NULL çš„èŠ‚ç‚¹å°†ç›´æ¥ä½œä¸ºæ–°äºŒå‰æ ‘çš„èŠ‚ç‚¹ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šä¾æ¬¡éå†å³å¯ã€‚

    # ä»£ç 
    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:

        def dfs(root1, root2):
            if root1 and root2:
                root = TreeNode(root1.val + root2.val)
                root.left = dfs(root1.left, root2.left)
                root.right = dfs(root1.right, root2.right)
            elif root1:
                root = TreeNode(root1.val)
                root.left = dfs(root1.left, None)
                root.right = dfs(root1.right, None)
            elif root2:
                root = TreeNode(root2.val)
                root.left = dfs(root2.left, None)
                root.right = dfs(root2.right, None)
            else:
                root = None
                return 
            return root

        return dfs(root1, root2)


#### 2. éé€’å½’
æ€è·¯ï¼š

## 637. äºŒå‰æ ‘çš„å±‚å¹³å‡å€¼
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªéç©ºäºŒå‰æ ‘, è¿”å›ä¸€ä¸ªç”±æ¯å±‚èŠ‚ç‚¹å¹³å‡å€¼ç»„æˆçš„æ•°ç»„ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šå±‚åºéå†ï¼Œæ±‚æ¯å±‚å¹³å‡å€¼å³å¯ã€‚

    # ä»£ç 
    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:

        res = []
        queue = [root]
        while queue:
            res.append(sum([q.val for q in queue]) / len([q.val for q in queue]))
            l1 = []
            for q in queue:
                if q.left:
                    l1.append(q.left)
                if q.right:
                    l1.append(q.right)
            queue = l1
        return res


#### 2. éé€’å½’
æ€è·¯ï¼š

## 653. ä¸¤æ•°ä¹‹å’Œ IV - è¾“å…¥ BST
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æœç´¢æ ‘ root å’Œä¸€ä¸ªç›®æ ‡ç»“æœ kï¼Œå¦‚æœ BST ä¸­å­˜åœ¨ä¸¤ä¸ªå…ƒç´ ä¸”å®ƒä»¬çš„å’Œç­‰äºç»™å®šçš„ç›®æ ‡ç»“æœï¼Œåˆ™è¿”å› trueã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šå±‚åºéå†ï¼Œæ±‚æ¯å±‚å¹³å‡å€¼å³å¯ã€‚

    # ä»£ç 
    def findTarget(self, root: TreeNode, k: int) -> bool:

        res = []

        def dfs(root):
            nonlocal res
            if not root:
                return
            dfs(root.left)
            res.append(root.val)
            dfs(root.right)

        dfs(root)

        l, r = 0, len(res)-1
        while l < r:
            if res[l] + res[r] == k:
                return True
            elif res[l] + res[r] > k:
                r -= 1
            else:
                l += 1
        return False

#### 2. éé€’å½’
æ€è·¯ï¼š

## 671. äºŒå‰æ ‘ä¸­ç¬¬äºŒå°çš„èŠ‚ç‚¹
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªéç©ºç‰¹æ®Šçš„äºŒå‰æ ‘ï¼Œæ¯ä¸ªèŠ‚ç‚¹éƒ½æ˜¯æ­£æ•°ï¼Œå¹¶ä¸”æ¯ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹æ•°é‡åªèƒ½ä¸ºÂ 2Â æˆ–Â 0ã€‚å¦‚æœä¸€ä¸ªèŠ‚ç‚¹æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹çš„è¯ï¼Œé‚£ä¹ˆè¯¥èŠ‚ç‚¹çš„å€¼ç­‰äºä¸¤ä¸ªå­èŠ‚ç‚¹ä¸­è¾ƒå°çš„ä¸€ä¸ªã€‚
æ›´æ­£å¼åœ°è¯´ï¼Œroot.val = min(root.left.val, root.right.val) æ€»æˆç«‹ã€‚ç»™å‡ºè¿™æ ·çš„ä¸€ä¸ªäºŒå‰æ ‘ï¼Œä½ éœ€è¦è¾“å‡ºæ‰€æœ‰èŠ‚ç‚¹ä¸­çš„ç¬¬äºŒå°çš„å€¼ã€‚å¦‚æœç¬¬äºŒå°çš„å€¼ä¸å­˜åœ¨çš„è¯ï¼Œè¾“å‡º -1 ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: å‰åºéå†ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸ç­‰äºæ ¹èŠ‚ç‚¹çš„å€¼è¿”å›å³å¯ã€‚

    # ä»£ç 
    def findSecondMinimumValue(self, root: TreeNode) -> int:
        min_v = root.val

        def dfs(root):
            if not root:
                return float('inf')
            if root.val != min_v:
                return root.val
            else:
                return min(dfs(root.left), dfs(root.right))

        return dfs(root) if dfs(root) != float('inf') else -1

#### 2. éé€’å½’
æ€è·¯ï¼š

## 700. äºŒå‰æœç´¢æ ‘ä¸­çš„æœç´¢
é¢˜ç›®ï¼šç»™å®šäºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰çš„æ ¹èŠ‚ç‚¹å’Œä¸€ä¸ªå€¼ã€‚ ä½ éœ€è¦åœ¨BSTä¸­æ‰¾åˆ°èŠ‚ç‚¹å€¼ç­‰äºç»™å®šå€¼çš„èŠ‚ç‚¹ã€‚ è¿”å›ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„å­æ ‘ã€‚ å¦‚æœèŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œåˆ™è¿”å› NULLã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: å‰åºéå†ï¼Œåˆ¤æ–­å½“å‰èŠ‚ç‚¹å’Œç»™å®šå€¼çš„å¤§å°ï¼Œè‹¥å¤§åˆ™éå†å·¦å­æ ‘ï¼Œå¦åˆ™å³å­æ ‘ã€‚

    # ä»£ç 
    def searchBST(self, root: TreeNode, val: int) -> TreeNode:

        def dfs(root):
            if not root:
                return -1
            if root.val == val:
                return root
            elif root.val > val:
                return dfs(root.left)
            else:
                return dfs(root.right)

        return dfs(root) if dfs(root)!= -1 else None

#### 2. éé€’å½’
æ€è·¯ï¼š

## 703. æ•°æ®æµä¸­çš„ç¬¬ K å¤§å…ƒç´ 
é¢˜ç›®ï¼šè®¾è®¡ä¸€ä¸ªæ‰¾åˆ°æ•°æ®æµä¸­ç¬¬ k å¤§å…ƒç´ çš„ç±»ï¼ˆclassï¼‰ã€‚æ³¨æ„æ˜¯æ’åºåçš„ç¬¬ k å¤§å…ƒç´ ï¼Œä¸æ˜¯ç¬¬ k ä¸ªä¸åŒçš„å…ƒç´ ã€‚
è¯·å®ç° KthLargestÂ ç±»ï¼š
KthLargest(int k, int[] nums) ä½¿ç”¨æ•´æ•° k å’Œæ•´æ•°æµ nums åˆå§‹åŒ–å¯¹è±¡ã€‚
int add(int val) å°† val æ’å…¥æ•°æ®æµ nums åï¼Œè¿”å›å½“å‰æ•°æ®æµä¸­ç¬¬ k å¤§çš„å…ƒç´ ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: 

    # ä»£ç 
    

#### 2. éé€’å½’
æ€è·¯ï¼š

## 783. äºŒå‰æœç´¢æ ‘èŠ‚ç‚¹æœ€å°è·ç¦»
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å› æ ‘ä¸­ä»»æ„ä¸¤ä¸åŒèŠ‚ç‚¹å€¼ä¹‹é—´çš„æœ€å°å·®å€¼ ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: ä¸­åºéå†ï¼Œè®°å½•æœ€å°å·®å€¼å³å¯ã€‚

    # ä»£ç 
    def minDiffInBST(self, root: TreeNode) -> int:

        min_v = float('inf')
        pre = None

        def dfs(root):
            nonlocal min_v, pre
            if not root:
                return
            dfs(root.left)
            if pre and abs(pre.val - root.val) < min_v:
                min_v = abs(pre.val - root.val)
            pre = root
            dfs(root.right)
        
        dfs(root)
        return min_v

#### 2. éé€’å½’
æ€è·¯ï¼š

## 872. å¶å­ç›¸ä¼¼çš„æ ‘
é¢˜ç›®ï¼šè¯·è€ƒè™‘ä¸€æ£µäºŒå‰æ ‘ä¸Šæ‰€æœ‰çš„å¶å­ï¼Œè¿™äº›å¶å­çš„å€¼æŒ‰ä»å·¦åˆ°å³çš„é¡ºåºæ’åˆ—å½¢æˆä¸€ä¸ª å¶å€¼åºåˆ— ã€‚
ä¸¾ä¸ªä¾‹å­ï¼Œå¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œç»™å®šä¸€æ£µå¶å€¼åºåˆ—ä¸ºÂ (6, 7, 4, 9, 8)Â çš„æ ‘ã€‚å¦‚æœæœ‰ä¸¤æ£µäºŒå‰æ ‘çš„å¶å€¼åºåˆ—æ˜¯ç›¸åŒï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±è®¤ä¸ºå®ƒä»¬æ˜¯Â å¶ç›¸ä¼¼Â çš„ã€‚
å¦‚æœç»™å®šçš„ä¸¤ä¸ªæ ¹ç»“ç‚¹åˆ†åˆ«ä¸ºÂ root1 å’ŒÂ root2Â çš„æ ‘æ˜¯å¶ç›¸ä¼¼çš„ï¼Œåˆ™è¿”å›Â trueï¼›å¦åˆ™è¿”å› false ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: ä¸­åºéå†ï¼Œè®°å½•æœ€å°å·®å€¼å³å¯ã€‚

    # ä»£ç 
    def leafSimilar(self, root1: TreeNode, root2: TreeNode) -> bool:

        def dfs(root, res):
            if not root:
                return
            if not root.left and not root.right:
                res.append(root.val) 

            dfs(root.left, res)
            dfs(root.right, res)

        res1, res2 = [], []
        dfs(root1, res1)
        dfs(root2, res2)
        return res1 == res2

#### 2. éé€’å½’
æ€è·¯ï¼š

## 897. é€’å¢é¡ºåºæœç´¢æ ‘
é¢˜ç›®ï¼šç»™ä½ ä¸€æ£µäºŒå‰æœç´¢æ ‘ï¼Œè¯·ä½  æŒ‰ä¸­åºéå† å°†å…¶é‡æ–°æ’åˆ—ä¸ºä¸€æ£µé€’å¢é¡ºåºæœç´¢æ ‘ï¼Œä½¿æ ‘ä¸­æœ€å·¦è¾¹çš„èŠ‚ç‚¹æˆä¸ºæ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œå¹¶ä¸”æ¯ä¸ªèŠ‚ç‚¹æ²¡æœ‰å·¦å­èŠ‚ç‚¹ï¼Œåªæœ‰ä¸€ä¸ªå³å­èŠ‚ç‚¹ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: ä¸­åºéå†ï¼Œç„¶åæ„å»ºé€’å¢æ ‘å³å¯ã€‚

    # ä»£ç 
    def increasingBST(self, root: TreeNode) -> TreeNode:

        res = []

        def dfs(root):
            nonlocal res
            if not root:
                return
            dfs(root.left)
            res.append(root.val)
            dfs(root.right)

        dfs(root)
        if not res:
            return None
        main_node = TreeNode(0)
        res_node = main_node
        for re in res:
            tmp = TreeNode(re)
            main_node.left = None
            main_node.right = tmp
            main_node = main_node.right

        return res_node.right

#### 2. éé€’å½’
æ€è·¯ï¼š

## 938. äºŒå‰æœç´¢æ ‘çš„èŒƒå›´å’Œ
é¢˜ç›®ï¼šç»™å®šäºŒå‰æœç´¢æ ‘çš„æ ¹ç»“ç‚¹ rootï¼Œè¿”å›å€¼ä½äºèŒƒå›´ [low, high] ä¹‹é—´çš„æ‰€æœ‰ç»“ç‚¹çš„å€¼çš„å’Œã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: ä¸­åºéå†ï¼Œå€¼åœ¨ç»™å®šèŒƒå›´çš„æ±‚å’Œå³å¯ã€‚

    # ä»£ç 
    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:

        res = []

        def dfs(root):
            if not root:
                return 
            dfs(root.left)
            if root.val >= low and root.val <=high:
                res.append(root.val)
            dfs(root.right)
        
        dfs(root)
        return sum(res)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 965. å•å€¼äºŒå‰æ ‘
é¢˜ç›®ï¼šå¦‚æœäºŒå‰æ ‘æ¯ä¸ªèŠ‚ç‚¹éƒ½å…·æœ‰ç›¸åŒçš„å€¼ï¼Œé‚£ä¹ˆè¯¥äºŒå‰æ ‘å°±æ˜¯å•å€¼äºŒå‰æ ‘ã€‚åªæœ‰ç»™å®šçš„æ ‘æ˜¯å•å€¼äºŒå‰æ ‘æ—¶ï¼Œæ‰è¿”å› trueï¼›å¦åˆ™è¿”å› falseã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: å‰åºéå†ï¼ŒæŠŠæ‰€æœ‰å€¼å­˜å…¥æ•°ç»„ï¼Œç„¶ååˆ¤æ–­æ•°ç»„æ˜¯å¦åªåŒ…å«åŒä¸€ä¸ªæ•°å³å¯ã€‚

    # ä»£ç 
    def isUnivalTree(self, root: TreeNode) -> bool:
        val = root.val

        def dfs(root):
            if not root:
                return True
            if root.val != val:
                return False
            else:
                return dfs(root.left) and dfs(root.right)
        
        return dfs(root)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 993. äºŒå‰æ ‘çš„å ‚å…„å¼ŸèŠ‚ç‚¹
é¢˜ç›®ï¼šåœ¨äºŒå‰æ ‘ä¸­ï¼Œæ ¹èŠ‚ç‚¹ä½äºæ·±åº¦ 0 å¤„ï¼Œæ¯ä¸ªæ·±åº¦ä¸º k çš„èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ä½äºæ·±åº¦ k+1 å¤„ã€‚å¦‚æœäºŒå‰æ ‘çš„ä¸¤ä¸ªèŠ‚ç‚¹æ·±åº¦ç›¸åŒï¼Œä½† çˆ¶èŠ‚ç‚¹ä¸åŒ ï¼Œåˆ™å®ƒä»¬æ˜¯ä¸€å¯¹å ‚å…„å¼ŸèŠ‚ç‚¹ã€‚
æˆ‘ä»¬ç»™å‡ºäº†å…·æœ‰å”¯ä¸€å€¼çš„äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œä»¥åŠæ ‘ä¸­ä¸¤ä¸ªä¸åŒèŠ‚ç‚¹çš„å€¼ x å’Œ y ã€‚åªæœ‰ä¸å€¼ x å’Œ y å¯¹åº”çš„èŠ‚ç‚¹æ˜¯å ‚å…„å¼ŸèŠ‚ç‚¹æ—¶ï¼Œæ‰è¿”å› true ã€‚å¦åˆ™ï¼Œè¿”å› falseã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: å‰åºéå†ï¼Œè®°å½•å½“å‰èŠ‚ç‚¹çš„æ·±åº¦ï¼Œå’Œå½“å‰èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ã€‚

    # ä»£ç 
    def isCousins(self, root: TreeNode, x: int, y: int) -> bool:
        x_d, y_d, x_p, y_p = 0, 0, None, None

        def dfs(root, parent, x, y, depth):
            nonlocal x_d, x_p, y_d, y_p
            if not root:
                return
            if root.val == x:
                x_d = depth
                x_p = parent
            if root.val == y:
                y_d = depth
                y_p = parent
            dfs(root.left, root, x, y, depth+1)
            dfs(root.right, root, x, y, depth+1)
        
        dfs(root, None, x, y, depth=0)
        return x_d == y_d and x_p !=y_p

#### 2. éé€’å½’
æ€è·¯ï¼š

## 1022. ä»æ ¹åˆ°å¶çš„äºŒè¿›åˆ¶æ•°ä¹‹å’Œ
é¢˜ç›®ï¼šç»™å‡ºä¸€æ£µäºŒå‰æ ‘ï¼Œå…¶ä¸Šæ¯ä¸ªç»“ç‚¹çš„å€¼éƒ½æ˜¯Â 0Â æˆ–Â 1Â ã€‚æ¯ä¸€æ¡ä»æ ¹åˆ°å¶çš„è·¯å¾„éƒ½ä»£è¡¨ä¸€ä¸ªä»æœ€é«˜æœ‰æ•ˆä½å¼€å§‹çš„äºŒè¿›åˆ¶æ•°ã€‚ä¾‹å¦‚ï¼Œå¦‚æœè·¯å¾„ä¸ºÂ 0 -> 1 -> 1 -> 0 -> 1ï¼Œé‚£ä¹ˆå®ƒè¡¨ç¤ºäºŒè¿›åˆ¶æ•°Â 01101ï¼Œä¹Ÿå°±æ˜¯Â 13Â ã€‚å¯¹æ ‘ä¸Šçš„æ¯ä¸€ç‰‡å¶å­ï¼Œæˆ‘ä»¬éƒ½è¦æ‰¾å‡ºä»æ ¹åˆ°è¯¥å¶å­çš„è·¯å¾„æ‰€è¡¨ç¤ºçš„æ•°å­—ã€‚è¿”å›è¿™äº›æ•°å­—ä¹‹å’Œã€‚é¢˜ç›®æ•°æ®ä¿è¯ç­”æ¡ˆæ˜¯ä¸€ä¸ª 32 ä½ æ•´æ•°ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: éå†è®°å½•æ ¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ï¼Œç„¶åæ±‚å’Œå³å¯ã€‚

    # ä»£ç 
    def sumRootToLeaf(self, root: TreeNode) -> int:

        res = []

        def dfs(root, path):
            if not root:
                return
            path += str(root.val)
            if not root.left and not root.right:
                res.append(path)
            dfs(root.left, path)
            dfs(root.right, path)

        def getNum(s):
            sum = 0
            for i in range(len(s)):
                sum += (int(s[len(s) - i -1]) * pow(2, i))
            return sum

        dfs(root, '')
        sum = 0
        for re in res:
            sum += getNum(re)
        return sum

#### 2. éé€’å½’
æ€è·¯ï¼š

## 95. ä¸åŒçš„äºŒå‰æœç´¢æ ‘ II
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªæ•´æ•° n ï¼Œè¯·ä½ ç”Ÿæˆå¹¶è¿”å›æ‰€æœ‰ç”± n ä¸ªèŠ‚ç‚¹ç»„æˆä¸”èŠ‚ç‚¹å€¼ä» 1 åˆ° n äº’ä¸ç›¸åŒçš„ä¸åŒ äºŒå‰æœç´¢æ ‘ ã€‚å¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›ç­”æ¡ˆã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: ä»[1,...n] éå†ï¼Œä¸€æ¬¡å½“æ ¹ï¼Œå› ä¸ºæ˜¯äºŒå‰æœç´¢æ ‘ï¼Œå½“æ ¹èŠ‚ç‚¹å–iæ—¶ï¼Œ[1,...i] æ„æˆå·¦å­æ ‘ï¼Œ[i,...n] æ„æˆå³å­æ ‘ï¼Œå·¦å³å­æ ‘å†é€’å½’æ±‚è§£å³å¯ã€‚

    # ä»£ç 
    def generateTrees(self, n: int) -> List[TreeNode]:

        def dfs(s, e):
            res = []
            if s > e:
                return [None]
            for i in range(s, e+1):
                lefts = dfs(s, i-1)
                rights = dfs(i+1, e)
                for l in lefts:
                    for r in rights:
                        node = TreeNode(i)
                        node.left = l
                        node.right = r
                        res.append(node)
            return res
        return dfs(1, n)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 96. ä¸åŒçš„äºŒå‰æœç´¢æ ‘
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªæ•´æ•° n ï¼Œæ±‚æ°ç”± n ä¸ªèŠ‚ç‚¹ç»„æˆä¸”èŠ‚ç‚¹å€¼ä» 1 åˆ° n äº’ä¸ç›¸åŒçš„ äºŒå‰æœç´¢æ ‘ æœ‰å¤šå°‘ç§ï¼Ÿè¿”å›æ»¡è¶³é¢˜æ„çš„äºŒå‰æœç´¢æ ‘çš„ç§æ•°ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: è®°å¿†åŒ–æœç´¢ï¼Œæ€»çš„ç§æ•°=å·¦å­æ ‘ç§æ•°*å³å­æ ‘æ•°é‡ã€‚
    # ä»£ç 
    def numTrees(self, n: int) -> int:

        dic = {0: 1, 1: 2, 2: 2}

        def dfs(n):
            if n <= 0: return 1
            if n <= 2: return n
            if n in dic:
                return dic[n]
            dic[n] = sum([dfs(i-1) * dfs(n-i) for i in range(1, n+1)])
            return dic[n]

        return dfs(n)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 98. éªŒè¯äºŒå‰æœç´¢æ ‘
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œåˆ¤æ–­å…¶æ˜¯å¦æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„äºŒå‰æœç´¢æ ‘ã€‚æœ‰æ•ˆ äºŒå‰æœç´¢æ ‘å®šä¹‰å¦‚ä¸‹ï¼š
èŠ‚ç‚¹çš„å·¦å­æ ‘åªåŒ…å« å°äº å½“å‰èŠ‚ç‚¹çš„æ•°ã€‚èŠ‚ç‚¹çš„å³å­æ ‘åªåŒ…å« å¤§äº å½“å‰èŠ‚ç‚¹çš„æ•°ã€‚æ‰€æœ‰å·¦å­æ ‘å’Œå³å­æ ‘è‡ªèº«å¿…é¡»ä¹Ÿæ˜¯äºŒå‰æœç´¢æ ‘ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: ä¸­åºéå†ï¼Œå•è°ƒé€’å¢

    # ä»£ç 
    def isValidBST(self, root: TreeNode) -> bool:
        pre = None

        def dfs(root):
            nonlocal pre
            if not root:
                return True
            left = dfs(root.left)
            if pre and pre.val >= root.val:
                return False
            pre = root
            right = dfs(root.right)
            return left and right
        
        return dfs(root)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 99. æ¢å¤äºŒå‰æœç´¢æ ‘
é¢˜ç›®ï¼šç»™ä½ äºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¯¥æ ‘ä¸­çš„ä¸¤ä¸ªèŠ‚ç‚¹è¢«é”™è¯¯åœ°äº¤æ¢ã€‚è¯·åœ¨ä¸æ”¹å˜å…¶ç»“æ„çš„æƒ…å†µä¸‹ï¼Œæ¢å¤è¿™æ£µæ ‘ã€‚
è¿›é˜¶ï¼šä½¿ç”¨ O(n) ç©ºé—´å¤æ‚åº¦çš„è§£æ³•å¾ˆå®¹æ˜“å®ç°ã€‚ä½ èƒ½æƒ³å‡ºä¸€ä¸ªåªä½¿ç”¨å¸¸æ•°ç©ºé—´çš„è§£å†³æ–¹æ¡ˆå—ï¼Ÿ
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: ä¸­åºéå†ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªa>bçš„ï¼Œå–a,ç„¶åå–ç¬¬äºŒä¸ªa>bçš„å–b,æœ€åäº¤æ¢aå’Œbã€‚

    # ä»£ç 
    def recoverTree(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """

        firstNode = None
        secondNode = None
        pre = None

        def dfs(root):
            nonlocal pre, firstNode, secondNode
            if not root:
                return 
            
            dfs(root.left)
            if pre:
                if not firstNode and pre.val > root.val:
                    firstNode = pre
                    secondNode = root
                elif firstNode and pre.val > root.val:
                    secondNode = root
            pre = root
            dfs(root.right)

        dfs(root)
        if firstNode and secondNode:
            firstNode.val, secondNode.val = secondNode.val, firstNode.val

#### 2. éé€’å½’
æ€è·¯ï¼š

## 102. äºŒå‰æ ‘çš„å±‚åºéå†
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¯·ä½ è¿”å›å…¶æŒ‰ å±‚åºéå† å¾—åˆ°çš„èŠ‚ç‚¹å€¼ã€‚ ï¼ˆå³é€å±‚åœ°ï¼Œä»å·¦åˆ°å³è®¿é—®æ‰€æœ‰èŠ‚ç‚¹ï¼‰ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: 

#### 2. éé€’å½’
æ€è·¯ï¼šå±‚åºéå†ï¼Œéé€’å½’ã€‚

    # ä»£ç 
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        
        res = []
        queue = [root]

        while queue:
            res.append([q.val for q in queue])
            l = []
            for q in queue:
                if q.left:
                    l.append(q.left)
                if q.right:
                    l.append(q.right)
            queue = l
        
        return res

## 103. äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚åºéå†
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„é”¯é½¿å½¢å±‚åºéå†ã€‚ï¼ˆå³å…ˆä»å·¦å¾€å³ï¼Œå†ä»å³å¾€å·¦è¿›è¡Œä¸‹ä¸€å±‚éå†ï¼Œä»¥æ­¤ç±»æ¨ï¼Œå±‚ä¸å±‚ä¹‹é—´äº¤æ›¿è¿›è¡Œï¼‰ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: 

#### 2. éé€’å½’
æ€è·¯ï¼šå±‚åºéå†ï¼Œä½¿ç”¨å•ç‹¬éå†è®°å½•æ˜¯å¦éœ€è¦ç¿»è½¬ã€‚

    # ä»£ç 
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        res = []
        queue = [root]
        is_reverse = False
        while queue:
            tmp = [q.val for q in queue]
            if is_reverse:
                tmp.reverse()
                res.append(tmp)
                is_reverse = False
            else:
                res.append(tmp)
                is_reverse = True

            l = []
            for q in queue:
                if q.left:
                    l.append(q.left)
                if q.right:
                    l.append(q.right)
            queue = l
        
        return res


