# leetcodeé¢˜è§£
1. TOC
{:toc}

## 101. å¯¹ç§°äºŒå‰æ ‘
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ£€æŸ¥å®ƒæ˜¯å¦æ˜¯é•œåƒå¯¹ç§°çš„ã€‚
ä¾‹å¦‚ï¼ŒäºŒå‰æ ‘ [1,2,2,3,4,4,3] æ˜¯å¯¹ç§°çš„ã€‚ä½†æ˜¯ä¸‹é¢è¿™ä¸ª [1,2,2,null,3,null,3] åˆ™ä¸æ˜¯é•œåƒå¯¹ç§°çš„:

### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’

#### 2. éé€’å½’
æ€è·¯ï¼šåˆ¤æ–­æ ¹æ˜¯å¦ä¸ºç©ºï¼Œæ˜¯è¿”å›True, å¦åˆ¤æ–­å·¦å³ä¸¤ä¸ªå­©å­æ˜¯å¦ç›¸ç­‰ï¼Œæ˜¯ç»§ç»­åˆ¤æ–­å·¦å­©å­çš„å·¦èŠ‚ç‚¹å’Œå³å­©å­çš„å³èŠ‚ç‚¹æ˜¯å¦ç›¸ç­‰ï¼Œä»¥åŠå·¦å­©å­çš„å³èŠ‚ç‚¹å’Œå³å­©å­çš„å·¦èŠ‚ç‚¹æ˜¯å¦ç›¸ç­‰

    #é˜Ÿåˆ—ä»£ç 
    def getRes(root):
        if not root:
            return True
        queue = [(root.left, root.right)]
        while queue != []:
            left, right = queue.pop()
            if not left and not right:
                continue
            if left and right and left.val == right.val:
                queue.append((left.left, right.right))
                queue.append((left.right, right.left))
            else:
                return False
        return True
        
## 102. äºŒå‰æ ‘çš„å±‚åºéå†
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¯·ä½ è¿”å›å…¶æŒ‰ å±‚åºéå† å¾—åˆ°çš„èŠ‚ç‚¹å€¼ã€‚ ï¼ˆå³é€å±‚åœ°ï¼Œä»å·¦åˆ°å³è®¿é—®æ‰€æœ‰èŠ‚ç‚¹ï¼‰ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1ã€é€’å½’

#### 2. éé€’å½’
æ€è·¯ï¼šè‹¥æ ¹ä¸ºç©ºï¼Œè¿”å›[]ï¼Œè‹¥æ ¹ä¸ç©ºå°†æ ¹å…¥é˜Ÿåˆ—queueï¼Œç„¶åä¾æ¬¡éå†é˜Ÿåˆ—ä¸­çš„èŠ‚ç‚¹å€¼å­˜å…¥resï¼Œç„¶åä¾æ¬¡éå†é˜Ÿåˆ—ä¸­çš„èŠ‚ç‚¹ï¼ŒæŠŠè¯¥èŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹ã€å³èŠ‚ç‚¹ä¾æ¬¡å…¥å­é˜Ÿåˆ—l1ï¼Œå°†å­é˜Ÿåˆ—l1èµ‹å€¼ç»™queue,è¿”å›resã€‚

    # ä»£ç 
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        res, queue = [], [root]
        while queue:
            res.append([q.val for q in queue])
            l1 = []
            for q in queue:
                if q.left:
                    l1.append(q.left)
                if q.right:
                    l1.append(q.right)
            queue = l1
        return res
        

## 100. ç›¸åŒçš„æ ‘
é¢˜ç›®ï¼šç»™ä½ ä¸¤æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ p å’Œ q ï¼Œç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥æ£€éªŒè¿™ä¸¤æ£µæ ‘æ˜¯å¦ç›¸åŒã€‚å¦‚æœä¸¤ä¸ªæ ‘åœ¨ç»“æ„ä¸Šç›¸åŒï¼Œå¹¶ä¸”èŠ‚ç‚¹å…·æœ‰ç›¸åŒçš„å€¼ï¼Œåˆ™è®¤ä¸ºå®ƒä»¬æ˜¯ç›¸åŒçš„ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
####1. é€’å½’
æ€è·¯ï¼šæ¯”è¾ƒæ ¹èŠ‚ç‚¹æ˜¯å¦ç›¸ç­‰ï¼Œç„¶åé€’å½’æ¯”è¾ƒå·¦å­æ ‘èŠ‚ç‚¹å’Œå³å­æ ‘èŠ‚ç‚¹æ˜¯å¦ç›¸ç­‰ã€‚

    # ä»£ç 
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        if not p and not q:
            return True
        elif not p or not q:
            return False
        elif p.val != q.val:
            return False
        else:
            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)

####2. éé€’å½’
æ€è·¯ï¼šåŒæ—¶éå†ä¸¤æ£µæ ‘ï¼Œä¾æ¬¡æ¯”è¾ƒèŠ‚ç‚¹å€¼ï¼Œè‹¥å½“å‰å·¦å­æ ‘æˆ–å³å­æ ‘ä¸ºç©ºæ—¶ä¹Ÿå…¥é˜Ÿåˆ—ã€‚

## 104. äºŒå‰æ ‘æœ€å¤§æ·±åº¦
ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾å‡ºå…¶æœ€å¤§æ·±åº¦ã€‚
äºŒå‰æ ‘çš„æ·±åº¦ä¸ºæ ¹èŠ‚ç‚¹åˆ°æœ€è¿œå¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°ã€‚è¯´æ˜: å¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
####1. é€’å½’
æ€è·¯ï¼šè‹¥æ ¹ä¸ºç©ºï¼Œè¿”å›0ï¼Œè‹¥æ ¹ä¸ç©ºï¼Œåˆ™æœ€å¤§æ·±åº¦ä¸ºå·¦å­æ ‘æœ€å¤§æ·±åº¦å’Œå³å­æ ‘æœ€å¤§æ·±åº¦å–æœ€å¤§å€¼+1

    # ä»£ç 
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        l = self.maxDepth(root.left)
        r = self.maxDepth(root.right)
        return max(l, r) + 1

### 2. éé€’å½’
æ€è·¯ï¼šäºŒå‰æ ‘å±‚æ¬¡éå†ï¼Œè¿”å›æ•°ç»„é•¿åº¦ã€‚

## 108. å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œå…¶ä¸­å…ƒç´ å·²ç»æŒ‰ å‡åº æ’åˆ—ï¼Œè¯·ä½ å°†å…¶è½¬æ¢ä¸ºä¸€æ£µ é«˜åº¦å¹³è¡¡ äºŒå‰æœç´¢æ ‘ã€‚
é«˜åº¦å¹³è¡¡ äºŒå‰æ ‘æ˜¯ä¸€æ£µæ»¡è¶³ã€Œæ¯ä¸ªèŠ‚ç‚¹çš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡ 1 ã€çš„äºŒå‰æ ‘ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šå–æ•°ç»„ä¸­é—´ä½ç½®åšæ ¹ï¼Œä¸­é—´ä½ç½®çš„å·¦è¾¹éƒ¨åˆ†æ„å»ºå·¦å­æ ‘ï¼Œå³è¾¹éƒ¨åˆ†æ„å»ºå³å­æ ‘ã€‚

    # ä»£ç 
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        def mark_tree(s, e):
            if s > e:
                return None
            mid = (s + e) // 2
            sub_tree = TreeNode(nums[mid])
            sub_tree.left = mark_tree(s, mid - 1)
            sub_tree.right = mark_tree(mid + 1, e)
            return sub_tree
        return mark_tree(0, len(nums) - 1)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 110. å¹³è¡¡äºŒå‰æ ‘
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œåˆ¤æ–­å®ƒæ˜¯å¦æ˜¯é«˜åº¦å¹³è¡¡çš„äºŒå‰æ ‘ã€‚
æœ¬é¢˜ä¸­ï¼Œä¸€æ£µé«˜åº¦å¹³è¡¡äºŒå‰æ ‘å®šä¹‰ä¸ºï¼š
ä¸€ä¸ªäºŒå‰æ ‘æ¯ä¸ªèŠ‚ç‚¹ çš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡ 1 
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šè‹¥æ ¹ä¸ºç©ºï¼Œè¿”å›True,åˆ¤æ–­æ ¹çš„å·¦å³å­æ ‘é«˜åº¦å·®ç»å¯¹å€¼æ˜¯å¦<=1ï¼Œå¦ï¼šè¿”å›False,ä¾æ¬¡åˆ¤æ–­æ ¹çš„å·¦å­æ ‘ã€å³å­æ ‘æ˜¯å¦æ˜¯å¹³è¡¡æ ‘

    # ä»£ç 
    def isBalanced(self, root: TreeNode) -> bool:
        def maxDepth(node):
            if not node:
                return 0
            l = maxDepth(node.left)
            r = maxDepth(node.right)
            return max(l, r) + 1

        if not root:
            return True
        return abs(maxDepth(root.left) - maxDepth(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 111. äºŒå‰æ ‘çš„æœ€å°æ·±åº¦
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾å‡ºå…¶æœ€å°æ·±åº¦ã€‚æœ€å°æ·±åº¦æ˜¯ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿‘å¶å­èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°é‡ã€‚è¯´æ˜ï¼šå¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šå±‚åºéå†äºŒå‰æ ‘ï¼Œè®°å½•æ·±åº¦ï¼Œé‡åˆ°æŸä¸ªèŠ‚ç‚¹æ²¡æœ‰å·¦å­æ ‘æˆ–å³å­æ ‘ç›´æ¥è¿”å›æ·±åº¦å³å¯ã€‚

    # ä»£ç 
    def minDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        queue = [root]
        depth = 1
        while queue:
            l1 = []
            for q in queue:
                if not q.left and not q.right:
                    return depth
                if q.left:
                    l1.append(q.left)
                if q.right:
                    l1.append(q.right)
            queue = l1
            depth += 1
        return depth

#### 2. éé€’å½’
æ€è·¯ï¼š

## 112. è·¯å¾„æ€»å’Œ
é¢˜ç›®ï¼šç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹Â root å’Œä¸€ä¸ªè¡¨ç¤ºç›®æ ‡å’Œçš„æ•´æ•°Â targetSum ï¼Œåˆ¤æ–­è¯¥æ ‘ä¸­æ˜¯å¦å­˜åœ¨ æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹ çš„è·¯å¾„ï¼Œè¿™æ¡è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹å€¼ç›¸åŠ ç­‰äºç›®æ ‡å’ŒÂ targetSum ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šæ·±åº¦ä¼˜å…ˆéå†ï¼Œåˆ¤æ–­å½“å‰èŠ‚ç‚¹æ˜¯å¦æ˜¯å¶å­ç»“ç‚¹å¹¶ä¸”è·¯å¾„å’Œæ˜¯å¦ç­‰äºç»™å®šå€¼ï¼Œè‹¥æ˜¯åˆ™è¿”å›true,å¦åˆ™è¿”å›false

    # ä»£ç 
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if not root:
            return targetSum == 0

        if not root.left and not root.right and root.val == targetSum:
            return True
        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 144. äºŒå‰æ ‘çš„å‰åºéå†
é¢˜ç›®ï¼šç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å›å®ƒèŠ‚ç‚¹å€¼çš„ å‰åº éå†ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šæ·±åº¦ä¼˜å…ˆéå†ï¼Œä¸€æ¬¡æ‰“å°èŠ‚ç‚¹å€¼

    # ä»£ç 
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        
        res = []

        def dfs(node):
            if not node:
                return None
            res.append(node.val)
            dfs(node.left)
            dfs(node.right)
        
        dfs(root)
        return res

#### 2. éé€’å½’
æ€è·¯ï¼š

## 144. äºŒå‰æ ‘çš„ååºéå†
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¿”å›å®ƒçš„ ååº éå†ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šæ·±åº¦ä¼˜å…ˆéå†ï¼Œä¸€æ¬¡æ‰“å°èŠ‚ç‚¹å€¼

    # ä»£ç 
    def postorderTraversal(self, root: TreeNode) -> List[int]:

        res = []

        def dfs(node):
            if not node:
                return
            dfs(node.left)
            dfs(node.right)
            res.append(node.val)
        
        dfs(root)
        return res

#### 2. éé€’å½’
æ€è·¯ï¼š

## 226. ç¿»è½¬äºŒå‰æ ‘
é¢˜ç›®ï¼šç¿»è½¬ä¸€æ£µäºŒå‰æ ‘ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šé€’å½’éå†æ ¹èŠ‚ç‚¹ï¼Œäº¤æ¢å·¦å³èŠ‚ç‚¹å€¼ï¼Œéå†å·¦å­æ ‘ï¼Œéå†ğŸˆ¶å³å­æ ‘ï¼Œè¿”å›æ ¹èŠ‚ç‚¹ã€‚

    # ä»£ç 
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return None
        root.left, root.right = root.right, root.left
        self.invertTree(root.left)
        self.invertTree(root.right)
        return root

#### 2. éé€’å½’
æ€è·¯ï¼š



## 235. äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æœç´¢æ ‘, æ‰¾åˆ°è¯¥æ ‘ä¸­ä¸¤ä¸ªæŒ‡å®šèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚
ç™¾åº¦ç™¾ç§‘ä¸­æœ€è¿‘å…¬å…±ç¥–å…ˆçš„å®šä¹‰ä¸ºï¼šâ€œå¯¹äºæœ‰æ ¹æ ‘ T çš„ä¸¤ä¸ªç»“ç‚¹ pã€qï¼Œæœ€è¿‘å…¬å…±ç¥–å…ˆè¡¨ç¤ºä¸ºä¸€ä¸ªç»“ç‚¹ xï¼Œæ»¡è¶³ x æ˜¯ pã€q çš„ç¥–å…ˆä¸” x çš„æ·±åº¦å°½å¯èƒ½å¤§ï¼ˆä¸€ä¸ªèŠ‚ç‚¹ä¹Ÿå¯ä»¥æ˜¯å®ƒè‡ªå·±çš„ç¥–å…ˆï¼‰ã€‚â€
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šç”±äºæ˜¯äºŒå‰æœç´¢æ ‘ï¼Œæœ€è¿‘å…¬å…±ç¥–å…ˆçš„å€¼ä¸€å®šåœ¨p,qå€¼çš„ä¸­é—´ï¼Œå› æ­¤å¯éå†äºŒå‰æœç´¢æ ‘ï¼Œå¯»æ‰¾åœ¨ä¸­é—´çš„èŠ‚ç‚¹ã€‚

    # ä»£ç 
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if p.val < root.val and q.val < root.val:
            return self.lowestCommonAncestor(root.left, p, q)
        elif p.val > root.val and q.val >root.val:
            return self.lowestCommonAncestor(root.right, p, q)
        else:
            return root

#### 2. éé€’å½’
æ€è·¯ï¼š

## 257. äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼ŒæŒ‰ ä»»æ„é¡ºåº ï¼Œè¿”å›æ‰€æœ‰ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ã€‚å¶å­èŠ‚ç‚¹ æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šæ·±åº¦ä¼˜å…ˆéå†ï¼Œéå†æ—¶è®°å½•å½“å‰è·¯å¾„å³å¯ã€‚

    # ä»£ç 
    def binaryTreePaths(self, root: TreeNode) -> List[str]:

        res = []
    
        def dfs(root, path):
            if not root:
                return
            if not root.left and not root.right:
                path += (str(root.val))
            else:
                path += (str(root.val) + '->')
            if not root.left and not root.right:
                res.append(path)
            dfs(root.left, path)
            dfs(root.right, path)
        
        dfs(root, '')
        return res

#### 2. éé€’å½’
æ€è·¯ï¼š

## 404. å·¦å¶å­ä¹‹å’Œ
é¢˜ç›®ï¼šè®¡ç®—ç»™å®šäºŒå‰æ ‘çš„æ‰€æœ‰å·¦å¶å­ä¹‹å’Œã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šæ·±åº¦ä¼˜å…ˆéå†ï¼Œéå†æ—¶è®°å½•å½“å‰è·¯å¾„å³å¯ã€‚

    # ä»£ç 
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        
        self.num = 0

        def dfs(root, flag):
            if not root:
                return
            if not root.left and not root.right and flag == 1:
                self.num += root.val
            dfs(root.left, 1)
            dfs(root.right, 0)
        
        dfs(root, 0)
        
        return self.num

#### 2. éé€’å½’
æ€è·¯ï¼š

## 501. äºŒå‰æœç´¢æ ‘ä¸­çš„ä¼—æ•°
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªæœ‰ç›¸åŒå€¼çš„äºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰ï¼Œæ‰¾å‡º BST ä¸­çš„æ‰€æœ‰ä¼—æ•°ï¼ˆå‡ºç°é¢‘ç‡æœ€é«˜çš„å…ƒç´ ï¼‰ã€‚
å‡å®š BST æœ‰å¦‚ä¸‹å®šä¹‰ï¼š
ç»“ç‚¹å·¦å­æ ‘ä¸­æ‰€å«ç»“ç‚¹çš„å€¼å°äºç­‰äºå½“å‰ç»“ç‚¹çš„å€¼
ç»“ç‚¹å³å­æ ‘ä¸­æ‰€å«ç»“ç‚¹çš„å€¼å¤§äºç­‰äºå½“å‰ç»“ç‚¹çš„å€¼
å·¦å­æ ‘å’Œå³å­æ ‘éƒ½æ˜¯äºŒå‰æœç´¢æ ‘
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šä¸­åºéå†ï¼Œè¾¹éå†è¾¹è®°å½•å½“å‰å‡ºç°æœ€å¤§å€¼å³å¯ã€‚

    # ä»£ç 
    def findMode(self, root: TreeNode) -> List[int]:

        self.res = []
        self.pre = None  # å‰ä¸€ä¸ªèŠ‚ç‚¹
        self.current_count = 0 # å½“å‰èŠ‚ç‚¹é‡å¤æ•°é‡
        self.max_count = 0 # å½“å‰æœ€å¤§æ•°é‡

        def dfs(root):
            if not root:
                return 
            dfs(root.left)
            if self.pre and self.pre.val == root.val:
                self.current_count += 1
            else:
                self.current_count = 1
            self.pre = root
            if self.current_count == self.max_count:
                self.res.append(root.val)
            elif self.current_count > self.max_count:
                self.max_count = self.current_count
                self.res.clear()
                self.res.append(root.val)

            dfs(root.right)
        
        dfs(root)
        return self.res

#### 2. éé€’å½’
æ€è·¯ï¼š

## 530. äºŒå‰æœç´¢æ ‘çš„æœ€å°ç»å¯¹å·®
é¢˜ç›®ï¼šç»™ä½ ä¸€æ£µæ‰€æœ‰èŠ‚ç‚¹ä¸ºéè´Ÿå€¼çš„äºŒå‰æœç´¢æ ‘ï¼Œè¯·ä½ è®¡ç®—æ ‘ä¸­ä»»æ„ä¸¤èŠ‚ç‚¹çš„å·®çš„ç»å¯¹å€¼çš„æœ€å°å€¼ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šä¸­åºéå†ï¼Œæ‹¿å½“å‰èŠ‚ç‚¹å’Œå‰ä¸€èŠ‚ç‚¹æ¯”è¾ƒæ±‚å‡ºæœ€å°å€¼å³å¯ã€‚

    # ä»£ç 
    def getMinimumDifference(self, root: TreeNode) -> int:

        value = float('inf')
        pre = None

        def dfs(root):
            nonlocal value, pre
            if not root:
                return 
            dfs(root.left)
            if pre and abs(pre.val - root.val) < value:
                value = abs(pre.val - root.val)
            pre = root
            dfs(root.right)

        dfs(root)
        return value

#### 2. éé€’å½’
æ€è·¯ï¼š

## 543. äºŒå‰æ ‘çš„ç›´å¾„
é¢˜ç›®ï¼šç»™å®šä¸€æ£µäºŒå‰æ ‘ï¼Œä½ éœ€è¦è®¡ç®—å®ƒçš„ç›´å¾„é•¿åº¦ã€‚ä¸€æ£µäºŒå‰æ ‘çš„ç›´å¾„é•¿åº¦æ˜¯ä»»æ„ä¸¤ä¸ªç»“ç‚¹è·¯å¾„é•¿åº¦ä¸­çš„æœ€å¤§å€¼ã€‚è¿™æ¡è·¯å¾„å¯èƒ½ç©¿è¿‡ä¹Ÿå¯èƒ½ä¸ç©¿è¿‡æ ¹ç»“ç‚¹ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šæ±‚ä»¥æ¯ä¸ªèŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„æœ€å¤§é«˜åº¦ï¼Œè®°å½•æœ€å¤§å€¼å³å¯ã€‚

    # ä»£ç 
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        max_v = 0

        def depth(root):
            nonlocal max_v
            if not root:
                return 0
            l = depth(root.left)
            r = depth(root.right)
            max_v = max(max_v, l+r+1)
            return max(l, r) + 1

        depth(root)
        return max_v-1

#### 2. éé€’å½’
æ€è·¯ï¼š

## 559. N å‰æ ‘çš„æœ€å¤§æ·±åº¦
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ª N å‰æ ‘ï¼Œæ‰¾åˆ°å…¶æœ€å¤§æ·±åº¦ã€‚æœ€å¤§æ·±åº¦æ˜¯æŒ‡ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿œå¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ€»æ•°ã€‚
N å‰æ ‘è¾“å…¥æŒ‰å±‚åºéå†åºåˆ—åŒ–è¡¨ç¤ºï¼Œæ¯ç»„å­èŠ‚ç‚¹ç”±ç©ºå€¼åˆ†éš”ï¼ˆè¯·å‚è§ç¤ºä¾‹ï¼‰ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šè‹¥æ ¹ä¸ºç©ºï¼Œè¿”å›é«˜åº¦ä¸º0ï¼Œè‹¥æ ¹çš„æ‰€æœ‰childrenå­èŠ‚ç‚¹ä¸ºç©ºï¼ˆæ ¹æ˜¯å¶å­èŠ‚ç‚¹ï¼‰ï¼Œè¿”å›é«˜åº¦ä¸º1ï¼›é€’å½’æ±‚å‡ºæ¯ä¸€ä¸ªå­èŠ‚ç‚¹æ ‘çš„é«˜åº¦ï¼Œå¾—å‡ºæœ€å¤§å€¼å³å¯ã€‚

    # ä»£ç 
    def maxDepth(self, root: 'Node') -> int:

        def dfs(root):
            nonlocal max_d
            if not root:
                return 0
            if not root.children:
                return 1
            height = []
            for cl in root.children:
                height.append(dfs(cl))
            return max(height) + 1

        max_d = dfs(root)
        return max_d

#### 2. éé€’å½’
æ€è·¯ï¼š

## 563. äºŒå‰æ ‘çš„å¡åº¦
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè®¡ç®— æ•´ä¸ªæ ‘ çš„å¡åº¦ ã€‚
ä¸€ä¸ªæ ‘çš„ èŠ‚ç‚¹çš„å¡åº¦ å®šä¹‰å³ä¸ºï¼Œè¯¥èŠ‚ç‚¹å·¦å­æ ‘çš„èŠ‚ç‚¹ä¹‹å’Œå’Œå³å­æ ‘èŠ‚ç‚¹ä¹‹å’Œçš„ å·®çš„ç»å¯¹å€¼ ã€‚å¦‚æœæ²¡æœ‰å·¦å­æ ‘çš„è¯ï¼Œå·¦å­æ ‘çš„èŠ‚ç‚¹ä¹‹å’Œä¸º 0 ï¼›æ²¡æœ‰å³å­æ ‘çš„è¯ä¹Ÿæ˜¯ä¸€æ ·ã€‚ç©ºç»“ç‚¹çš„å¡åº¦æ˜¯ 0 ã€‚
æ•´ä¸ªæ ‘ çš„å¡åº¦å°±æ˜¯å…¶æ‰€æœ‰èŠ‚ç‚¹çš„å¡åº¦ä¹‹å’Œã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šæ±‚ä»¥æŸä¸ªèŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„çš„æ ‘çš„å€¼æ€»å’Œï¼Œå³å·¦èŠ‚ç‚¹æ€»å’Œ+å³èŠ‚ç‚¹æ€»å’Œ+è‡ªèº«å€¼ï¼Œå…¶ä¸­ï¼Œå·¦èŠ‚ç‚¹æ€»å’Œå’Œå³èŠ‚ç‚¹æ€»å’Œå·®çš„ç»å¯¹å€¼å³ä¸ºå½“å‰èŠ‚ç‚¹çš„å¡åº¦ï¼Œå¯¹æ‰€æœ‰èŠ‚ç‚¹æ±‚å¡åº¦ç„¶ååšåŠ å’Œå³ä¸ºæ ‘çš„å¡åº¦ã€‚

    # ä»£ç 
    def findTilt(self, root: TreeNode) -> int:
        res = 0

        # æ±‚ä»¥æŸä¸ªèŠ‚ç‚¹ä¸ºæ ¹çš„æ€»å’Œ
        def getNodeSum(root):
            nonlocal res
            if not root:
                return 0
            ls = getNodeSum(root.left)
            rs = getNodeSum(root.right)
            res += abs(ls - rs)
            return ls+rs+root.val

        getNodeSum(root)

        return res

#### 2. éé€’å½’
æ€è·¯ï¼š

## 572. å¦ä¸€æ£µæ ‘çš„å­æ ‘
é¢˜ç›®ï¼šç»™ä½ ä¸¤æ£µäºŒå‰æ ‘ root å’Œ subRoot ã€‚æ£€éªŒ root ä¸­æ˜¯å¦åŒ…å«å’Œ subRoot å…·æœ‰ç›¸åŒç»“æ„å’ŒèŠ‚ç‚¹å€¼çš„å­æ ‘ã€‚å¦‚æœå­˜åœ¨ï¼Œè¿”å› true ï¼›å¦åˆ™ï¼Œè¿”å› false ã€‚
äºŒå‰æ ‘ tree çš„ä¸€æ£µå­æ ‘åŒ…æ‹¬ tree çš„æŸä¸ªèŠ‚ç‚¹å’Œè¿™ä¸ªèŠ‚ç‚¹çš„æ‰€æœ‰åä»£èŠ‚ç‚¹ã€‚tree ä¹Ÿå¯ä»¥çœ‹åšå®ƒè‡ªèº«çš„ä¸€æ£µå­æ ‘ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šéå†rootæ¯ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä»¥æ¯ä¸ªå­èŠ‚ç‚¹æ ‘ä¸ºæ ¹åˆ¤æ–­æ˜¯å¦æ˜¯ç›¸åŒçš„æ ‘ã€‚

    # ä»£ç 
    def isSubtree(self, root: TreeNode, subRoot: TreeNode) -> bool:

        # ä»¥p, q ä¸ºæ ¹èŠ‚ç‚¹çš„ä¸¤é¢—äºŒå‰æ ‘æ˜¯å¦ä¸ºç›¸åŒçš„æ ‘
        def isSambleTree(p, q):
            if not p and not q:
                return True
            elif not q or not p:
                return False
            elif p.val != q.val:
                return False
            else:
                return isSambleTree(p.left, q.left) and isSambleTree(p.right, q.right)
        
        # éå†rootæ ‘ï¼Œå¹¶åˆ¤æ–­æ˜¯å¦ä¸ºç›¸åŒçš„æ ‘
        def dfs(root, subRoot):
            if not root and not subRoot:
                return True
            if not root or not subRoot:
                return False
            else:
                return isSambleTree(root, subRoot) or dfs(root.left, subRoot) or dfs(root.right, subRoot)

        # æ³•2
        def dfs2(root, subRoot):
            if not root:
                return False
            if root.val == subRoot.val:
                if isSambleTree(root, subRoot):
                    return True
        
            return dfs2(root.left, subRoot) or dfs2(root.right, subRoot)
        
        return dfs2(root, subRoot)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 589. N å‰æ ‘çš„å‰åºéå†
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ª N å‰æ ‘ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„ å‰åºéå† ã€‚N å‰æ ‘ åœ¨è¾“å…¥ä¸­æŒ‰å±‚åºéå†è¿›è¡Œåºåˆ—åŒ–è¡¨ç¤ºï¼Œæ¯ç»„å­èŠ‚ç‚¹ç”±ç©ºå€¼ null åˆ†éš”ï¼ˆè¯·å‚è§ç¤ºä¾‹ï¼‰ã€‚
è¿›é˜¶ï¼šé€’å½’æ³•å¾ˆç®€å•ï¼Œä½ å¯ä»¥ä½¿ç”¨è¿­ä»£æ³•å®Œæˆæ­¤é¢˜å—?
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šä¾æ¬¡éå†å³å¯ã€‚

    # ä»£ç 
    def preorder(self, root: 'Node') -> List[int]:
        res = []

        def dfs(root):
            nonlocal res
            if not root:
                return 
            res.append(root.val)
            for cl in root.children:
                dfs(cl)
        
        dfs(root)
        return res


#### 2. éé€’å½’
æ€è·¯ï¼š

## 590. N å‰æ ‘çš„ååºéå†
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ª N å‰æ ‘ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„ ååºéå† ã€‚N å‰æ ‘ åœ¨è¾“å…¥ä¸­æŒ‰å±‚åºéå†è¿›è¡Œåºåˆ—åŒ–è¡¨ç¤ºï¼Œæ¯ç»„å­èŠ‚ç‚¹ç”±ç©ºå€¼ null åˆ†éš”ï¼ˆè¯·å‚è§ç¤ºä¾‹ï¼‰ã€‚
è¿›é˜¶ï¼šé€’å½’æ³•å¾ˆç®€å•ï¼Œä½ å¯ä»¥ä½¿ç”¨è¿­ä»£æ³•å®Œæˆæ­¤é¢˜å—?
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šä¾æ¬¡éå†å³å¯ã€‚

    # ä»£ç 
    def postorder(self, root: 'Node') -> List[int]:

        res = []

        def dfs(root):
            nonlocal res
            if not root:
                return 
            for cl in root.children:
                dfs(cl)
            res.append(root.val)

        dfs(root)
        return res


#### 2. éé€’å½’
æ€è·¯ï¼š

## 617. åˆå¹¶äºŒå‰æ ‘
é¢˜ç›®ï¼šç»™å®šä¸¤ä¸ªäºŒå‰æ ‘ï¼Œæƒ³è±¡å½“ä½ å°†å®ƒä»¬ä¸­çš„ä¸€ä¸ªè¦†ç›–åˆ°å¦ä¸€ä¸ªä¸Šæ—¶ï¼Œä¸¤ä¸ªäºŒå‰æ ‘çš„ä¸€äº›èŠ‚ç‚¹ä¾¿ä¼šé‡å ã€‚
ä½ éœ€è¦å°†ä»–ä»¬åˆå¹¶ä¸ºä¸€ä¸ªæ–°çš„äºŒå‰æ ‘ã€‚åˆå¹¶çš„è§„åˆ™æ˜¯å¦‚æœä¸¤ä¸ªèŠ‚ç‚¹é‡å ï¼Œé‚£ä¹ˆå°†ä»–ä»¬çš„å€¼ç›¸åŠ ä½œä¸ºèŠ‚ç‚¹åˆå¹¶åçš„æ–°å€¼ï¼Œå¦åˆ™ä¸ä¸ºÂ NULL çš„èŠ‚ç‚¹å°†ç›´æ¥ä½œä¸ºæ–°äºŒå‰æ ‘çš„èŠ‚ç‚¹ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šä¾æ¬¡éå†å³å¯ã€‚

    # ä»£ç 
    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:

        def dfs(root1, root2):
            if root1 and root2:
                root = TreeNode(root1.val + root2.val)
                root.left = dfs(root1.left, root2.left)
                root.right = dfs(root1.right, root2.right)
            elif root1:
                root = TreeNode(root1.val)
                root.left = dfs(root1.left, None)
                root.right = dfs(root1.right, None)
            elif root2:
                root = TreeNode(root2.val)
                root.left = dfs(root2.left, None)
                root.right = dfs(root2.right, None)
            else:
                root = None
                return 
            return root

        return dfs(root1, root2)


#### 2. éé€’å½’
æ€è·¯ï¼š

## 637. äºŒå‰æ ‘çš„å±‚å¹³å‡å€¼
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªéç©ºäºŒå‰æ ‘, è¿”å›ä¸€ä¸ªç”±æ¯å±‚èŠ‚ç‚¹å¹³å‡å€¼ç»„æˆçš„æ•°ç»„ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šå±‚åºéå†ï¼Œæ±‚æ¯å±‚å¹³å‡å€¼å³å¯ã€‚

    # ä»£ç 
    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:

        res = []
        queue = [root]
        while queue:
            res.append(sum([q.val for q in queue]) / len([q.val for q in queue]))
            l1 = []
            for q in queue:
                if q.left:
                    l1.append(q.left)
                if q.right:
                    l1.append(q.right)
            queue = l1
        return res


#### 2. éé€’å½’
æ€è·¯ï¼š

## 653. ä¸¤æ•°ä¹‹å’Œ IV - è¾“å…¥ BST
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æœç´¢æ ‘ root å’Œä¸€ä¸ªç›®æ ‡ç»“æœ kï¼Œå¦‚æœ BST ä¸­å­˜åœ¨ä¸¤ä¸ªå…ƒç´ ä¸”å®ƒä»¬çš„å’Œç­‰äºç»™å®šçš„ç›®æ ‡ç»“æœï¼Œåˆ™è¿”å› trueã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šå±‚åºéå†ï¼Œæ±‚æ¯å±‚å¹³å‡å€¼å³å¯ã€‚

    # ä»£ç 
    def findTarget(self, root: TreeNode, k: int) -> bool:

        res = []

        def dfs(root):
            nonlocal res
            if not root:
                return
            dfs(root.left)
            res.append(root.val)
            dfs(root.right)

        dfs(root)

        l, r = 0, len(res)-1
        while l < r:
            if res[l] + res[r] == k:
                return True
            elif res[l] + res[r] > k:
                r -= 1
            else:
                l += 1
        return False

#### 2. éé€’å½’
æ€è·¯ï¼š

## 671. äºŒå‰æ ‘ä¸­ç¬¬äºŒå°çš„èŠ‚ç‚¹
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªéç©ºç‰¹æ®Šçš„äºŒå‰æ ‘ï¼Œæ¯ä¸ªèŠ‚ç‚¹éƒ½æ˜¯æ­£æ•°ï¼Œå¹¶ä¸”æ¯ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹æ•°é‡åªèƒ½ä¸ºÂ 2Â æˆ–Â 0ã€‚å¦‚æœä¸€ä¸ªèŠ‚ç‚¹æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹çš„è¯ï¼Œé‚£ä¹ˆè¯¥èŠ‚ç‚¹çš„å€¼ç­‰äºä¸¤ä¸ªå­èŠ‚ç‚¹ä¸­è¾ƒå°çš„ä¸€ä¸ªã€‚
æ›´æ­£å¼åœ°è¯´ï¼Œroot.val = min(root.left.val, root.right.val) æ€»æˆç«‹ã€‚ç»™å‡ºè¿™æ ·çš„ä¸€ä¸ªäºŒå‰æ ‘ï¼Œä½ éœ€è¦è¾“å‡ºæ‰€æœ‰èŠ‚ç‚¹ä¸­çš„ç¬¬äºŒå°çš„å€¼ã€‚å¦‚æœç¬¬äºŒå°çš„å€¼ä¸å­˜åœ¨çš„è¯ï¼Œè¾“å‡º -1 ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: å‰åºéå†ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸ç­‰äºæ ¹èŠ‚ç‚¹çš„å€¼è¿”å›å³å¯ã€‚

    # ä»£ç 
    def findSecondMinimumValue(self, root: TreeNode) -> int:
        min_v = root.val

        def dfs(root):
            if not root:
                return float('inf')
            if root.val != min_v:
                return root.val
            else:
                return min(dfs(root.left), dfs(root.right))

        return dfs(root) if dfs(root) != float('inf') else -1

#### 2. éé€’å½’
æ€è·¯ï¼š

## 700. äºŒå‰æœç´¢æ ‘ä¸­çš„æœç´¢
é¢˜ç›®ï¼šç»™å®šäºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰çš„æ ¹èŠ‚ç‚¹å’Œä¸€ä¸ªå€¼ã€‚ ä½ éœ€è¦åœ¨BSTä¸­æ‰¾åˆ°èŠ‚ç‚¹å€¼ç­‰äºç»™å®šå€¼çš„èŠ‚ç‚¹ã€‚ è¿”å›ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„å­æ ‘ã€‚ å¦‚æœèŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œåˆ™è¿”å› NULLã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: å‰åºéå†ï¼Œåˆ¤æ–­å½“å‰èŠ‚ç‚¹å’Œç»™å®šå€¼çš„å¤§å°ï¼Œè‹¥å¤§åˆ™éå†å·¦å­æ ‘ï¼Œå¦åˆ™å³å­æ ‘ã€‚

    # ä»£ç 
    def searchBST(self, root: TreeNode, val: int) -> TreeNode:

        def dfs(root):
            if not root:
                return -1
            if root.val == val:
                return root
            elif root.val > val:
                return dfs(root.left)
            else:
                return dfs(root.right)

        return dfs(root) if dfs(root)!= -1 else None

#### 2. éé€’å½’
æ€è·¯ï¼š

## 703. æ•°æ®æµä¸­çš„ç¬¬ K å¤§å…ƒç´ 
é¢˜ç›®ï¼šè®¾è®¡ä¸€ä¸ªæ‰¾åˆ°æ•°æ®æµä¸­ç¬¬ k å¤§å…ƒç´ çš„ç±»ï¼ˆclassï¼‰ã€‚æ³¨æ„æ˜¯æ’åºåçš„ç¬¬ k å¤§å…ƒç´ ï¼Œä¸æ˜¯ç¬¬ k ä¸ªä¸åŒçš„å…ƒç´ ã€‚
è¯·å®ç° KthLargestÂ ç±»ï¼š
KthLargest(int k, int[] nums) ä½¿ç”¨æ•´æ•° k å’Œæ•´æ•°æµ nums åˆå§‹åŒ–å¯¹è±¡ã€‚
int add(int val) å°† val æ’å…¥æ•°æ®æµ nums åï¼Œè¿”å›å½“å‰æ•°æ®æµä¸­ç¬¬ k å¤§çš„å…ƒç´ ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: 

    # ä»£ç 
    

#### 2. éé€’å½’
æ€è·¯ï¼š

## 783. äºŒå‰æœç´¢æ ‘èŠ‚ç‚¹æœ€å°è·ç¦»
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å› æ ‘ä¸­ä»»æ„ä¸¤ä¸åŒèŠ‚ç‚¹å€¼ä¹‹é—´çš„æœ€å°å·®å€¼ ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: ä¸­åºéå†ï¼Œè®°å½•æœ€å°å·®å€¼å³å¯ã€‚

    # ä»£ç 
    def minDiffInBST(self, root: TreeNode) -> int:

        min_v = float('inf')
        pre = None

        def dfs(root):
            nonlocal min_v, pre
            if not root:
                return
            dfs(root.left)
            if pre and abs(pre.val - root.val) < min_v:
                min_v = abs(pre.val - root.val)
            pre = root
            dfs(root.right)
        
        dfs(root)
        return min_v

#### 2. éé€’å½’
æ€è·¯ï¼š

## 872. å¶å­ç›¸ä¼¼çš„æ ‘
é¢˜ç›®ï¼šè¯·è€ƒè™‘ä¸€æ£µäºŒå‰æ ‘ä¸Šæ‰€æœ‰çš„å¶å­ï¼Œè¿™äº›å¶å­çš„å€¼æŒ‰ä»å·¦åˆ°å³çš„é¡ºåºæ’åˆ—å½¢æˆä¸€ä¸ª å¶å€¼åºåˆ— ã€‚
ä¸¾ä¸ªä¾‹å­ï¼Œå¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œç»™å®šä¸€æ£µå¶å€¼åºåˆ—ä¸ºÂ (6, 7, 4, 9, 8)Â çš„æ ‘ã€‚å¦‚æœæœ‰ä¸¤æ£µäºŒå‰æ ‘çš„å¶å€¼åºåˆ—æ˜¯ç›¸åŒï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±è®¤ä¸ºå®ƒä»¬æ˜¯Â å¶ç›¸ä¼¼Â çš„ã€‚
å¦‚æœç»™å®šçš„ä¸¤ä¸ªæ ¹ç»“ç‚¹åˆ†åˆ«ä¸ºÂ root1 å’ŒÂ root2Â çš„æ ‘æ˜¯å¶ç›¸ä¼¼çš„ï¼Œåˆ™è¿”å›Â trueï¼›å¦åˆ™è¿”å› false ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: ä¸­åºéå†ï¼Œè®°å½•æœ€å°å·®å€¼å³å¯ã€‚

    # ä»£ç 
    def leafSimilar(self, root1: TreeNode, root2: TreeNode) -> bool:

        def dfs(root, res):
            if not root:
                return
            if not root.left and not root.right:
                res.append(root.val) 

            dfs(root.left, res)
            dfs(root.right, res)

        res1, res2 = [], []
        dfs(root1, res1)
        dfs(root2, res2)
        return res1 == res2

#### 2. éé€’å½’
æ€è·¯ï¼š

## 897. é€’å¢é¡ºåºæœç´¢æ ‘
é¢˜ç›®ï¼šç»™ä½ ä¸€æ£µäºŒå‰æœç´¢æ ‘ï¼Œè¯·ä½  æŒ‰ä¸­åºéå† å°†å…¶é‡æ–°æ’åˆ—ä¸ºä¸€æ£µé€’å¢é¡ºåºæœç´¢æ ‘ï¼Œä½¿æ ‘ä¸­æœ€å·¦è¾¹çš„èŠ‚ç‚¹æˆä¸ºæ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œå¹¶ä¸”æ¯ä¸ªèŠ‚ç‚¹æ²¡æœ‰å·¦å­èŠ‚ç‚¹ï¼Œåªæœ‰ä¸€ä¸ªå³å­èŠ‚ç‚¹ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: ä¸­åºéå†ï¼Œç„¶åæ„å»ºé€’å¢æ ‘å³å¯ã€‚

    # ä»£ç 
    def increasingBST(self, root: TreeNode) -> TreeNode:

        res = []

        def dfs(root):
            nonlocal res
            if not root:
                return
            dfs(root.left)
            res.append(root.val)
            dfs(root.right)

        dfs(root)
        if not res:
            return None
        main_node = TreeNode(0)
        res_node = main_node
        for re in res:
            tmp = TreeNode(re)
            main_node.left = None
            main_node.right = tmp
            main_node = main_node.right

        return res_node.right

#### 2. éé€’å½’
æ€è·¯ï¼š

## 938. äºŒå‰æœç´¢æ ‘çš„èŒƒå›´å’Œ
é¢˜ç›®ï¼šç»™å®šäºŒå‰æœç´¢æ ‘çš„æ ¹ç»“ç‚¹ rootï¼Œè¿”å›å€¼ä½äºèŒƒå›´ [low, high] ä¹‹é—´çš„æ‰€æœ‰ç»“ç‚¹çš„å€¼çš„å’Œã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: ä¸­åºéå†ï¼Œå€¼åœ¨ç»™å®šèŒƒå›´çš„æ±‚å’Œå³å¯ã€‚

    # ä»£ç 
    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:

        res = []

        def dfs(root):
            if not root:
                return 
            dfs(root.left)
            if root.val >= low and root.val <=high:
                res.append(root.val)
            dfs(root.right)
        
        dfs(root)
        return sum(res)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 965. å•å€¼äºŒå‰æ ‘
é¢˜ç›®ï¼šå¦‚æœäºŒå‰æ ‘æ¯ä¸ªèŠ‚ç‚¹éƒ½å…·æœ‰ç›¸åŒçš„å€¼ï¼Œé‚£ä¹ˆè¯¥äºŒå‰æ ‘å°±æ˜¯å•å€¼äºŒå‰æ ‘ã€‚åªæœ‰ç»™å®šçš„æ ‘æ˜¯å•å€¼äºŒå‰æ ‘æ—¶ï¼Œæ‰è¿”å› trueï¼›å¦åˆ™è¿”å› falseã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: å‰åºéå†ï¼ŒæŠŠæ‰€æœ‰å€¼å­˜å…¥æ•°ç»„ï¼Œç„¶ååˆ¤æ–­æ•°ç»„æ˜¯å¦åªåŒ…å«åŒä¸€ä¸ªæ•°å³å¯ã€‚

    # ä»£ç 
    def isUnivalTree(self, root: TreeNode) -> bool:
        val = root.val

        def dfs(root):
            if not root:
                return True
            if root.val != val:
                return False
            else:
                return dfs(root.left) and dfs(root.right)
        
        return dfs(root)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 993. äºŒå‰æ ‘çš„å ‚å…„å¼ŸèŠ‚ç‚¹
é¢˜ç›®ï¼šåœ¨äºŒå‰æ ‘ä¸­ï¼Œæ ¹èŠ‚ç‚¹ä½äºæ·±åº¦ 0 å¤„ï¼Œæ¯ä¸ªæ·±åº¦ä¸º k çš„èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ä½äºæ·±åº¦ k+1 å¤„ã€‚å¦‚æœäºŒå‰æ ‘çš„ä¸¤ä¸ªèŠ‚ç‚¹æ·±åº¦ç›¸åŒï¼Œä½† çˆ¶èŠ‚ç‚¹ä¸åŒ ï¼Œåˆ™å®ƒä»¬æ˜¯ä¸€å¯¹å ‚å…„å¼ŸèŠ‚ç‚¹ã€‚
æˆ‘ä»¬ç»™å‡ºäº†å…·æœ‰å”¯ä¸€å€¼çš„äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œä»¥åŠæ ‘ä¸­ä¸¤ä¸ªä¸åŒèŠ‚ç‚¹çš„å€¼ x å’Œ y ã€‚åªæœ‰ä¸å€¼ x å’Œ y å¯¹åº”çš„èŠ‚ç‚¹æ˜¯å ‚å…„å¼ŸèŠ‚ç‚¹æ—¶ï¼Œæ‰è¿”å› true ã€‚å¦åˆ™ï¼Œè¿”å› falseã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: å‰åºéå†ï¼Œè®°å½•å½“å‰èŠ‚ç‚¹çš„æ·±åº¦ï¼Œå’Œå½“å‰èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ã€‚

    # ä»£ç 
    def isCousins(self, root: TreeNode, x: int, y: int) -> bool:
        x_d, y_d, x_p, y_p = 0, 0, None, None

        def dfs(root, parent, x, y, depth):
            nonlocal x_d, x_p, y_d, y_p
            if not root:
                return
            if root.val == x:
                x_d = depth
                x_p = parent
            if root.val == y:
                y_d = depth
                y_p = parent
            dfs(root.left, root, x, y, depth+1)
            dfs(root.right, root, x, y, depth+1)
        
        dfs(root, None, x, y, depth=0)
        return x_d == y_d and x_p !=y_p

#### 2. éé€’å½’
æ€è·¯ï¼š

## 1022. ä»æ ¹åˆ°å¶çš„äºŒè¿›åˆ¶æ•°ä¹‹å’Œ
é¢˜ç›®ï¼šç»™å‡ºä¸€æ£µäºŒå‰æ ‘ï¼Œå…¶ä¸Šæ¯ä¸ªç»“ç‚¹çš„å€¼éƒ½æ˜¯Â 0Â æˆ–Â 1Â ã€‚æ¯ä¸€æ¡ä»æ ¹åˆ°å¶çš„è·¯å¾„éƒ½ä»£è¡¨ä¸€ä¸ªä»æœ€é«˜æœ‰æ•ˆä½å¼€å§‹çš„äºŒè¿›åˆ¶æ•°ã€‚ä¾‹å¦‚ï¼Œå¦‚æœè·¯å¾„ä¸ºÂ 0 -> 1 -> 1 -> 0 -> 1ï¼Œé‚£ä¹ˆå®ƒè¡¨ç¤ºäºŒè¿›åˆ¶æ•°Â 01101ï¼Œä¹Ÿå°±æ˜¯Â 13Â ã€‚å¯¹æ ‘ä¸Šçš„æ¯ä¸€ç‰‡å¶å­ï¼Œæˆ‘ä»¬éƒ½è¦æ‰¾å‡ºä»æ ¹åˆ°è¯¥å¶å­çš„è·¯å¾„æ‰€è¡¨ç¤ºçš„æ•°å­—ã€‚è¿”å›è¿™äº›æ•°å­—ä¹‹å’Œã€‚é¢˜ç›®æ•°æ®ä¿è¯ç­”æ¡ˆæ˜¯ä¸€ä¸ª 32 ä½ æ•´æ•°ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: éå†è®°å½•æ ¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ï¼Œç„¶åæ±‚å’Œå³å¯ã€‚

    # ä»£ç 
    def sumRootToLeaf(self, root: TreeNode) -> int:

        res = []

        def dfs(root, path):
            if not root:
                return
            path += str(root.val)
            if not root.left and not root.right:
                res.append(path)
            dfs(root.left, path)
            dfs(root.right, path)

        def getNum(s):
            sum = 0
            for i in range(len(s)):
                sum += (int(s[len(s) - i -1]) * pow(2, i))
            return sum

        dfs(root, '')
        sum = 0
        for re in res:
            sum += getNum(re)
        return sum

#### 2. éé€’å½’
æ€è·¯ï¼š

## 95. ä¸åŒçš„äºŒå‰æœç´¢æ ‘ II
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªæ•´æ•° n ï¼Œè¯·ä½ ç”Ÿæˆå¹¶è¿”å›æ‰€æœ‰ç”± n ä¸ªèŠ‚ç‚¹ç»„æˆä¸”èŠ‚ç‚¹å€¼ä» 1 åˆ° n äº’ä¸ç›¸åŒçš„ä¸åŒ äºŒå‰æœç´¢æ ‘ ã€‚å¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›ç­”æ¡ˆã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: ä»[1,...n] éå†ï¼Œä¸€æ¬¡å½“æ ¹ï¼Œå› ä¸ºæ˜¯äºŒå‰æœç´¢æ ‘ï¼Œå½“æ ¹èŠ‚ç‚¹å–iæ—¶ï¼Œ[1,...i] æ„æˆå·¦å­æ ‘ï¼Œ[i,...n] æ„æˆå³å­æ ‘ï¼Œå·¦å³å­æ ‘å†é€’å½’æ±‚è§£å³å¯ã€‚

    # ä»£ç 
    def generateTrees(self, n: int) -> List[TreeNode]:

        def dfs(s, e):
            res = []
            if s > e:
                return [None]
            for i in range(s, e+1):
                lefts = dfs(s, i-1)
                rights = dfs(i+1, e)
                for l in lefts:
                    for r in rights:
                        node = TreeNode(i)
                        node.left = l
                        node.right = r
                        res.append(node)
            return res
        return dfs(1, n)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 96. ä¸åŒçš„äºŒå‰æœç´¢æ ‘
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªæ•´æ•° n ï¼Œæ±‚æ°ç”± n ä¸ªèŠ‚ç‚¹ç»„æˆä¸”èŠ‚ç‚¹å€¼ä» 1 åˆ° n äº’ä¸ç›¸åŒçš„ äºŒå‰æœç´¢æ ‘ æœ‰å¤šå°‘ç§ï¼Ÿè¿”å›æ»¡è¶³é¢˜æ„çš„äºŒå‰æœç´¢æ ‘çš„ç§æ•°ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: è®°å¿†åŒ–æœç´¢ï¼Œæ€»çš„ç§æ•°=å·¦å­æ ‘ç§æ•°*å³å­æ ‘æ•°é‡ã€‚
    # ä»£ç 
    def numTrees(self, n: int) -> int:

        dic = {0: 1, 1: 2, 2: 2}

        def dfs(n):
            if n <= 0: return 1
            if n <= 2: return n
            if n in dic:
                return dic[n]
            dic[n] = sum([dfs(i-1) * dfs(n-i) for i in range(1, n+1)])
            return dic[n]

        return dfs(n)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 98. éªŒè¯äºŒå‰æœç´¢æ ‘
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œåˆ¤æ–­å…¶æ˜¯å¦æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„äºŒå‰æœç´¢æ ‘ã€‚æœ‰æ•ˆ äºŒå‰æœç´¢æ ‘å®šä¹‰å¦‚ä¸‹ï¼š
èŠ‚ç‚¹çš„å·¦å­æ ‘åªåŒ…å« å°äº å½“å‰èŠ‚ç‚¹çš„æ•°ã€‚èŠ‚ç‚¹çš„å³å­æ ‘åªåŒ…å« å¤§äº å½“å‰èŠ‚ç‚¹çš„æ•°ã€‚æ‰€æœ‰å·¦å­æ ‘å’Œå³å­æ ‘è‡ªèº«å¿…é¡»ä¹Ÿæ˜¯äºŒå‰æœç´¢æ ‘ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: ä¸­åºéå†ï¼Œå•è°ƒé€’å¢

    # ä»£ç 
    def isValidBST(self, root: TreeNode) -> bool:
        pre = None

        def dfs(root):
            nonlocal pre
            if not root:
                return True
            left = dfs(root.left)
            if pre and pre.val >= root.val:
                return False
            pre = root
            right = dfs(root.right)
            return left and right
        
        return dfs(root)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 99. æ¢å¤äºŒå‰æœç´¢æ ‘
é¢˜ç›®ï¼šç»™ä½ äºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¯¥æ ‘ä¸­çš„ä¸¤ä¸ªèŠ‚ç‚¹è¢«é”™è¯¯åœ°äº¤æ¢ã€‚è¯·åœ¨ä¸æ”¹å˜å…¶ç»“æ„çš„æƒ…å†µä¸‹ï¼Œæ¢å¤è¿™æ£µæ ‘ã€‚
è¿›é˜¶ï¼šä½¿ç”¨ O(n) ç©ºé—´å¤æ‚åº¦çš„è§£æ³•å¾ˆå®¹æ˜“å®ç°ã€‚ä½ èƒ½æƒ³å‡ºä¸€ä¸ªåªä½¿ç”¨å¸¸æ•°ç©ºé—´çš„è§£å†³æ–¹æ¡ˆå—ï¼Ÿ
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: ä¸­åºéå†ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªa>bçš„ï¼Œå–a,ç„¶åå–ç¬¬äºŒä¸ªa>bçš„å–b,æœ€åäº¤æ¢aå’Œbã€‚

    # ä»£ç 
    def recoverTree(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """

        firstNode = None
        secondNode = None
        pre = None

        def dfs(root):
            nonlocal pre, firstNode, secondNode
            if not root:
                return 
            
            dfs(root.left)
            if pre:
                if not firstNode and pre.val > root.val:
                    firstNode = pre
                    secondNode = root
                elif firstNode and pre.val > root.val:
                    secondNode = root
            pre = root
            dfs(root.right)

        dfs(root)
        if firstNode and secondNode:
            firstNode.val, secondNode.val = secondNode.val, firstNode.val

#### 2. éé€’å½’
æ€è·¯ï¼š

## 102. äºŒå‰æ ‘çš„å±‚åºéå†
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¯·ä½ è¿”å›å…¶æŒ‰ å±‚åºéå† å¾—åˆ°çš„èŠ‚ç‚¹å€¼ã€‚ ï¼ˆå³é€å±‚åœ°ï¼Œä»å·¦åˆ°å³è®¿é—®æ‰€æœ‰èŠ‚ç‚¹ï¼‰ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: 

#### 2. éé€’å½’
æ€è·¯ï¼šå±‚åºéå†ï¼Œéé€’å½’ã€‚

    # ä»£ç 
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        
        res = []
        queue = [root]

        while queue:
            res.append([q.val for q in queue])
            l = []
            for q in queue:
                if q.left:
                    l.append(q.left)
                if q.right:
                    l.append(q.right)
            queue = l
        
        return res

## 103. äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚åºéå†
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„é”¯é½¿å½¢å±‚åºéå†ã€‚ï¼ˆå³å…ˆä»å·¦å¾€å³ï¼Œå†ä»å³å¾€å·¦è¿›è¡Œä¸‹ä¸€å±‚éå†ï¼Œä»¥æ­¤ç±»æ¨ï¼Œå±‚ä¸å±‚ä¹‹é—´äº¤æ›¿è¿›è¡Œï¼‰ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: 

#### 2. éé€’å½’
æ€è·¯ï¼šå±‚åºéå†ï¼Œä½¿ç”¨å•ç‹¬éå†è®°å½•æ˜¯å¦éœ€è¦ç¿»è½¬ã€‚

    # ä»£ç 
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        res = []
        queue = [root]
        is_reverse = False
        while queue:
            tmp = [q.val for q in queue]
            if is_reverse:
                tmp.reverse()
                res.append(tmp)
                is_reverse = False
            else:
                res.append(tmp)
                is_reverse = True

            l = []
            for q in queue:
                if q.left:
                    l.append(q.left)
                if q.right:
                    l.append(q.right)
            queue = l
        
        return res
        
## 105. ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘
é¢˜ç›®ï¼šç»™å®šä¸€æ£µæ ‘çš„å‰åºéå† preorder ä¸ä¸­åºéå†  inorderã€‚è¯·æ„é€ äºŒå‰æ ‘å¹¶è¿”å›å…¶æ ¹èŠ‚ç‚¹ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: æ ¹æ®å‰åºæ‰¾åˆ°æ ¹èŠ‚ç‚¹ï¼Œç„¶åé€’å½’æ„å»ºå·¦å­æ ‘å’Œå³å­æ ‘

    # æ„é€ äºŒå‰æ ‘
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:

        def dfs(preorder, inorder):
            if not preorder or not inorder:
                return
            root = TreeNode(preorder[0])
            index = inorder.index(preorder[0])
            root.left = dfs(preorder[1:index+1], inorder[0:index])
            root.right = dfs(preorder[index+1:], inorder[index+1:])
            return root

        return dfs(preorder, inorder)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 106. ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘
é¢˜ç›®ï¼šæ ¹æ®ä¸€æ£µæ ‘çš„ä¸­åºéå†ä¸ååºéå†æ„é€ äºŒå‰æ ‘ã€‚
æ³¨æ„:ä½ å¯ä»¥å‡è®¾æ ‘ä¸­æ²¡æœ‰é‡å¤çš„å…ƒç´ ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: æ ¹æ®ååºæ‰¾åˆ°æ ¹èŠ‚ç‚¹ï¼Œç„¶åé€’å½’æ„å»ºå·¦å­æ ‘å’Œå³å­æ ‘

    # æ„é€ äºŒå‰æ ‘
    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:

        def dfs(inorder, postorder):
            if not inorder or not postorder:
                return 
            index = inorder.index(postorder[-1])
            root = TreeNode(postorder[-1])
            root.left = dfs(inorder[0:index], postorder[0:index])
            root.right = dfs(inorder[index+1:], postorder[index:len(postorder)-1])
            return root
        
        return dfs(inorder, postorder)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 107. äºŒå‰æ ‘çš„å±‚åºéå† II
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼è‡ªåº•å‘ä¸Šçš„å±‚åºéå†ã€‚ ï¼ˆå³æŒ‰ä»å¶å­èŠ‚ç‚¹æ‰€åœ¨å±‚åˆ°æ ¹èŠ‚ç‚¹æ‰€åœ¨çš„å±‚ï¼Œé€å±‚ä»å·¦å‘å³éå†ï¼‰
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: å±‚åºéå†ï¼Œå°†ç»“æœç¿»è½¬å³å¯ã€‚

    # å±‚é¡ºåºéå†
    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []

        res = []
        queue = [root]
        while queue:
            res.append([q.val for q in queue])
            l = []
            for q in queue:
                if q.left:
                    l.append(q.left)
                if q.right:
                    l.append(q.right)
            queue= l

        res.reverse()

        return res
#### 2. éé€’å½’
æ€è·¯ï¼š

## 109. æœ‰åºé“¾è¡¨è½¬æ¢äºŒå‰æœç´¢æ ‘
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªå•é“¾è¡¨ï¼Œå…¶ä¸­çš„å…ƒç´ æŒ‰å‡åºæ’åºï¼Œå°†å…¶è½¬æ¢ä¸ºé«˜åº¦å¹³è¡¡çš„äºŒå‰æœç´¢æ ‘ã€‚
æœ¬é¢˜ä¸­ï¼Œä¸€ä¸ªé«˜åº¦å¹³è¡¡äºŒå‰æ ‘æ˜¯æŒ‡ä¸€ä¸ªäºŒå‰æ ‘æ¯ä¸ªèŠ‚ç‚¹Â çš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡ 1ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: æœ‰åºé“¾è¡¨å¿«æ…¢æŒ‡é’ˆæ‰¾ä¸­ç‚¹ï¼Œç„¶åæ„å»ºæ ‘å³å¯ã€‚

    # å±‚é¡ºåºéå†
    def sortedListToBST(self, head: ListNode) -> TreeNode:

        def findMid(head, tail):
            fast = head
            slow = head
            while fast != tail and fast.next != tail:
                slow = slow.next
                fast = fast.next.next
            return slow
        
        def dfs(head, tail):
            if head == tail:
                return None
            node = findMid(head, tail)
            root= TreeNode(node.val)
            root.left = dfs(head, node)
            root.right = dfs(node.next, tail)
            return root

        return dfs(head, None)
#### 2. éé€’å½’
æ€è·¯ï¼š

## 113. è·¯å¾„æ€»å’Œ II
é¢˜ç›®ï¼šç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root å’Œä¸€ä¸ªæ•´æ•°ç›®æ ‡å’Œ targetSum ï¼Œæ‰¾å‡ºæ‰€æœ‰ ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹ è·¯å¾„æ€»å’Œç­‰äºç»™å®šç›®æ ‡å’Œçš„è·¯å¾„ã€‚
å¶å­èŠ‚ç‚¹ æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: æ·±åº¦ä¼˜å…ˆéå†ï¼Œéå†åˆ°å¶å­èŠ‚ç‚¹æ—¶åˆ¤æ–­å³å¯ã€‚

    # å±‚é¡ºåºéå†
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:

        res = []
        sub_res = []
        def dfs(root):
            nonlocal res, sub_res
            if not root:
                return 
            sub_res.append(root.val)
            if not root.left and not root.right:
                if sum(sub_res) == targetSum:
                    res.append([s for s in sub_res])
            dfs(root.left)
            dfs(root.right)
            sub_res.pop()

        dfs(root)
        return res
#### 2. éé€’å½’
æ€è·¯ï¼š

## 114. äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨
é¢˜ç›®ï¼šç»™ä½ äºŒå‰æ ‘çš„æ ¹ç»“ç‚¹ root ï¼Œè¯·ä½ å°†å®ƒå±•å¼€ä¸ºä¸€ä¸ªå•é“¾è¡¨ï¼š
å±•å¼€åçš„å•é“¾è¡¨åº”è¯¥åŒæ ·ä½¿ç”¨ TreeNode ï¼Œå…¶ä¸­ right å­æŒ‡é’ˆæŒ‡å‘é“¾è¡¨ä¸­ä¸‹ä¸€ä¸ªç»“ç‚¹ï¼Œè€Œå·¦å­æŒ‡é’ˆå§‹ç»ˆä¸º null ã€‚
å±•å¼€åçš„å•é“¾è¡¨åº”è¯¥ä¸äºŒå‰æ ‘ å…ˆåºéå† é¡ºåºç›¸åŒã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: å…ˆåºéå†ï¼Œæ ¹å·¦å³ï¼Œå°†æ ¹èŠ‚ç‚¹çš„å³å­æ ‘ç§»åˆ°å·¦å­æ ‘çš„æœ€å³èŠ‚ç‚¹ï¼Œå°†å·¦å­æ ‘å˜ä¸ºæ ¹çš„å³å­æ ‘ï¼Œå°†æ ¹çš„å³å­æ ‘ç½®ä¸ºç©ºï¼Œç„¶åæ ¹èŠ‚ç‚¹å³ç§»å¾ªç¯åˆ¤æ–­ã€‚

    # å±‚é¡ºåºéå†
    def flatten(self, root: TreeNode) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        if not root:
            return 

        node = root

        while node:
            if node.left:
                sub_left = node.left
                tmp = sub_left
                while tmp.right:
                    tmp = tmp.right
                tmp.right = node.right
                node.right = sub_left
                node.left = None
            node = node.right
#### 2. éé€’å½’
æ€è·¯ï¼š

## 116. å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªÂ å®Œç¾äºŒå‰æ ‘Â ï¼Œå…¶æ‰€æœ‰å¶å­èŠ‚ç‚¹éƒ½åœ¨åŒä¸€å±‚ï¼Œæ¯ä¸ªçˆ¶èŠ‚ç‚¹éƒ½æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ã€‚äºŒå‰æ ‘å®šä¹‰å¦‚ä¸‹ï¼š
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
å¡«å……å®ƒçš„æ¯ä¸ª next æŒ‡é’ˆï¼Œè®©è¿™ä¸ªæŒ‡é’ˆæŒ‡å‘å…¶ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹ã€‚å¦‚æœæ‰¾ä¸åˆ°ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹ï¼Œåˆ™å°† next æŒ‡é’ˆè®¾ç½®ä¸º NULLã€‚
åˆå§‹çŠ¶æ€ä¸‹ï¼Œæ‰€æœ‰Â next æŒ‡é’ˆéƒ½è¢«è®¾ç½®ä¸º NULLã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: æ¯ä¸ªæ ¹èŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹nextåº”è¯¥æŒ‡å‘æ ¹èŠ‚ç‚¹çš„å³èŠ‚ç‚¹ï¼Œæ¯ä¸ªæ ¹èŠ‚ç‚¹çš„å³èŠ‚ç‚¹nextåº”è¯¥æŒ‡å‘å…¶çˆ¶èŠ‚ç‚¹çš„nextèŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹ã€‚

    # 
    def connect(self, root: 'Node') -> 'Node':

        def dfs(root):
            if not root:
                return
            if root.left:
                root.left.next = root.right
            if root.right:
                if root.next:
                    root.right.next = root.next.left
            dfs(root.left)
            dfs(root.right)

        dfs(root)
        return root
#### 2. éé€’å½’
æ€è·¯ï¼š

## 117. å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ II
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æ ‘
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
å¡«å……å®ƒçš„æ¯ä¸ª next æŒ‡é’ˆï¼Œè®©è¿™ä¸ªæŒ‡é’ˆæŒ‡å‘å…¶ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹ã€‚å¦‚æœæ‰¾ä¸åˆ°ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹ï¼Œåˆ™å°† next æŒ‡é’ˆè®¾ç½®ä¸º NULLã€‚
åˆå§‹çŠ¶æ€ä¸‹ï¼Œæ‰€æœ‰Â next æŒ‡é’ˆéƒ½è¢«è®¾ç½®ä¸º NULLã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: æ¯ä¸ªæ ¹èŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹nextåº”è¯¥æŒ‡å‘æ ¹èŠ‚ç‚¹çš„å³èŠ‚ç‚¹ï¼Œæ¯ä¸ªæ ¹èŠ‚ç‚¹çš„å³èŠ‚ç‚¹nextåº”è¯¥æŒ‡å‘å…¶çˆ¶èŠ‚ç‚¹çš„nextèŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹ã€‚

    # 
    
#### 2. éé€’å½’
æ€è·¯ï¼š

## 129. æ±‚æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹æ•°å­—ä¹‹å’Œ
ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œæ ‘ä¸­æ¯ä¸ªèŠ‚ç‚¹éƒ½å­˜æ”¾æœ‰ä¸€ä¸ª 0 åˆ° 9 ä¹‹é—´çš„æ•°å­—ã€‚
æ¯æ¡ä»æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹çš„è·¯å¾„éƒ½ä»£è¡¨ä¸€ä¸ªæ•°å­—ï¼š
ä¾‹å¦‚ï¼Œä»æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹çš„è·¯å¾„ 1 -> 2 -> 3 è¡¨ç¤ºæ•°å­— 123 ã€‚
è®¡ç®—ä»æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹ç”Ÿæˆçš„ æ‰€æœ‰æ•°å­—ä¹‹å’Œ ã€‚
å¶èŠ‚ç‚¹ æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: æ·±åº¦éå†ï¼Œç›´æ¥æ±‚å’Œå³å¯ã€‚

    # 
    def sumNumbers(self, root: TreeNode) -> int:

        res = 0
        def dfs(root, num):
            nonlocal res
            if not root:
                return
            if not root.left and not root.right:
                res += num
            if root.left:
                dfs(root.left, num * 10 + root.left.val)
            if root.right:
                dfs(root.right, num * 10 + root.right.val)
        dfs(root, root.val)
        return res
    
#### 2. éé€’å½’
æ€è·¯ï¼š

## 173. äºŒå‰æœç´¢æ ‘è¿­ä»£å™¨
å®ç°ä¸€ä¸ªäºŒå‰æœç´¢æ ‘è¿­ä»£å™¨ç±»BSTIterator ï¼Œè¡¨ç¤ºä¸€ä¸ªæŒ‰ä¸­åºéå†äºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰çš„è¿­ä»£å™¨ï¼š
BSTIterator(TreeNode root) åˆå§‹åŒ– BSTIterator ç±»çš„ä¸€ä¸ªå¯¹è±¡ã€‚BST çš„æ ¹èŠ‚ç‚¹ root ä¼šä½œä¸ºæ„é€ å‡½æ•°çš„ä¸€éƒ¨åˆ†ç»™å‡ºã€‚æŒ‡é’ˆåº”åˆå§‹åŒ–ä¸ºä¸€ä¸ªä¸å­˜åœ¨äº BST ä¸­çš„æ•°å­—ï¼Œä¸”è¯¥æ•°å­—å°äº BST ä¸­çš„ä»»ä½•å…ƒç´ ã€‚
boolean hasNext() å¦‚æœå‘æŒ‡é’ˆå³ä¾§éå†å­˜åœ¨æ•°å­—ï¼Œåˆ™è¿”å› true ï¼›å¦åˆ™è¿”å› false ã€‚
int next()å°†æŒ‡é’ˆå‘å³ç§»åŠ¨ï¼Œç„¶åè¿”å›æŒ‡é’ˆå¤„çš„æ•°å­—ã€‚
æ³¨æ„ï¼ŒæŒ‡é’ˆåˆå§‹åŒ–ä¸ºä¸€ä¸ªä¸å­˜åœ¨äº BST ä¸­çš„æ•°å­—ï¼Œæ‰€ä»¥å¯¹ next() çš„é¦–æ¬¡è°ƒç”¨å°†è¿”å› BST ä¸­çš„æœ€å°å…ƒç´ ã€‚
ä½ å¯ä»¥å‡è®¾Â next()Â è°ƒç”¨æ€»æ˜¯æœ‰æ•ˆçš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå½“è°ƒç”¨ next()Â æ—¶ï¼ŒBST çš„ä¸­åºéå†ä¸­è‡³å°‘å­˜åœ¨ä¸€ä¸ªä¸‹ä¸€ä¸ªæ•°å­—ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: æ±‚nextæ—¶æ„é€ å•è°ƒæ ˆã€‚

    # 
    class BSTIterator:

    def __init__(self, root: TreeNode):
        self.res = []
        while root:
            self.res.append(root)
            root = root.left


    def next(self) -> int:
        cur = self.res.pop()
        node = cur.right
        while node:
            self.res.append(node)
            node = node.left
        return cur.val


    def hasNext(self) -> bool:
        return len(self.res) > 0
    
#### 2. éé€’å½’
æ€è·¯ï¼š

## 199. äºŒå‰æ ‘çš„å³è§†å›¾
ç»™å®šä¸€ä¸ªäºŒå‰æ ‘çš„ æ ¹èŠ‚ç‚¹ rootï¼Œæƒ³è±¡è‡ªå·±ç«™åœ¨å®ƒçš„å³ä¾§ï¼ŒæŒ‰ç…§ä»é¡¶éƒ¨åˆ°åº•éƒ¨çš„é¡ºåºï¼Œè¿”å›ä»å³ä¾§æ‰€èƒ½çœ‹åˆ°çš„èŠ‚ç‚¹å€¼ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: å±‚æ¬¡éå†ï¼Œæ¯å±‚å–æœ€å³è¾¹èŠ‚ç‚¹ã€‚

    # 
    def rightSideView(self, root: TreeNode) -> List[int]:
        if not root:
            return []

        res = []
        queue = [root]
        while queue:
            res.append(queue[-1].val)
            l = []
            for q in queue:
                if q.left:
                    l.append(q.left)
                if q.right:
                    l.append(q.right)
            queue = l

        return res
    
#### 2. éé€’å½’
æ€è·¯ï¼š

## 222. å®Œå…¨äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°
ç»™ä½ ä¸€æ£µ å®Œå…¨äºŒå‰æ ‘ çš„æ ¹èŠ‚ç‚¹ root ï¼Œæ±‚å‡ºè¯¥æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°ã€‚
å®Œå…¨äºŒå‰æ ‘ çš„å®šä¹‰å¦‚ä¸‹ï¼šåœ¨å®Œå…¨äºŒå‰æ ‘ä¸­ï¼Œé™¤äº†æœ€åº•å±‚èŠ‚ç‚¹å¯èƒ½æ²¡å¡«æ»¡å¤–ï¼Œå…¶ä½™æ¯å±‚èŠ‚ç‚¹æ•°éƒ½è¾¾åˆ°æœ€å¤§å€¼ï¼Œå¹¶ä¸”æœ€ä¸‹é¢ä¸€å±‚çš„èŠ‚ç‚¹éƒ½é›†ä¸­åœ¨è¯¥å±‚æœ€å·¦è¾¹çš„è‹¥å¹²ä½ç½®ã€‚è‹¥æœ€åº•å±‚ä¸ºç¬¬ h å±‚ï¼Œåˆ™è¯¥å±‚åŒ…å« 1~Â 2hÂ ä¸ªèŠ‚ç‚¹ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: éå†æ ¹èŠ‚ç‚¹é¥¿å·¦å­æ ‘é«˜åº¦å’Œå³å­æ ‘é«˜åº¦ï¼Œè‹¥é«˜åº¦ç›¸åŒåˆ™è¡¨ç¤ºå·¦å­æ ‘è‚¯å®šæ˜¯æ»¡äºŒå‰æ ‘ï¼Œæ€»èŠ‚ç‚¹ä¸ªæ•°ä¸ºå·¦å­æ ‘æ»¡äºŒå‰æ ‘+é€’å½’å³å­æ ‘ï¼Œè‹¥ä¸æƒ³ç­‰ï¼Œåˆ™å³å­æ ‘è‚¯å®šæ˜¯äºŒå‰æ ‘ï¼Œæ€»èŠ‚ç‚¹ä¸ªæ•°ä¸ºå³å­æ ‘æ»¡äºŒå‰æ ‘+é€’å½’å·¦å­æ ‘

    # 
    def countNodes(self, root: TreeNode) -> int:
        if not root:
            return 0

        def getDepth(node):
            if not node:
                return 0
            return max(getDepth(node.left), getDepth(node.right)) + 1

        def dfs(root):
            if not root:
                return 0
            l_d, r_d = getDepth(root.left), getDepth(root.right)
            if l_d == r_d:
                return (1<<l_d) + dfs(root.right)
            else:
                return (1<<r_d) + dfs(root.left)
        
        return dfs(root)
    
#### 2. éé€’å½’
æ€è·¯ï¼š

## 230. äºŒå‰æœç´¢æ ‘ä¸­ç¬¬Kå°çš„å…ƒç´ 
ç»™å®šä¸€ä¸ªäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œå’Œä¸€ä¸ªæ•´æ•° k ï¼Œè¯·ä½ è®¾è®¡ä¸€ä¸ªç®—æ³•æŸ¥æ‰¾å…¶ä¸­ç¬¬ k ä¸ªæœ€å°å…ƒç´ ï¼ˆä» 1 å¼€å§‹è®¡æ•°ï¼‰ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: ä¸­åºéå†ï¼Œéå†åˆ°ç¬¬kä¸ªæ—¶ç»“æŸå³å¯ã€‚

    # 
    def kthSmallest(self, root: TreeNode, k: int) -> int:

        res = 0

        def dfs(root):
            nonlocal res, k
            if not root:
                return
            dfs(root.left)
            k -= 1
            if k == 0:
                res = root.val
                return
            dfs(root.right)

        dfs(root)

        return res
    
#### 2. éé€’å½’
æ€è·¯ï¼š

## 236. äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ
ç»™å®šä¸€ä¸ªäºŒå‰æ ‘, æ‰¾åˆ°è¯¥æ ‘ä¸­ä¸¤ä¸ªæŒ‡å®šèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚
ç™¾åº¦ç™¾ç§‘ä¸­æœ€è¿‘å…¬å…±ç¥–å…ˆçš„å®šä¹‰ä¸ºï¼šâ€œå¯¹äºæœ‰æ ¹æ ‘ T çš„ä¸¤ä¸ªèŠ‚ç‚¹ pã€qï¼Œæœ€è¿‘å…¬å…±ç¥–å…ˆè¡¨ç¤ºä¸ºä¸€ä¸ªèŠ‚ç‚¹ xï¼Œæ»¡è¶³ x æ˜¯ pã€q çš„ç¥–å…ˆä¸” x çš„æ·±åº¦å°½å¯èƒ½å¤§ï¼ˆä¸€ä¸ªèŠ‚ç‚¹ä¹Ÿå¯ä»¥æ˜¯å®ƒè‡ªå·±çš„ç¥–å…ˆï¼‰ã€‚â€
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: æœ€è¿‘å…¬å…±ç¥–å…ˆåªä¼šå‡ºç°åœ¨æƒ…å†µï¼Œä¸€æ˜¯åœ¨æ ¹èŠ‚ç‚¹çš„å·¦å­æ ‘å’Œå³å­æ ‘ä¸­ï¼Œåˆ™ä¸ºæ ¹ï¼ŒäºŒæ˜¯pæ˜¯qçš„æ ¹ï¼Œä¸‰æ˜¯qæ˜¯pçš„æ ¹ã€‚

    # 
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':

        def dfs(root):
            # nonlocal p, q
            if not root:
                return None
            if root == p or root == q:
                return root
            left = dfs(root.left)
            right = dfs(root.right)
            if not left:
                return right
            elif not right:
                return left
            elif not left and not right:
                return None
            else:
                return root

        return dfs(root)
    
#### 2. éé€’å½’
æ€è·¯ï¼š

## 331. éªŒè¯äºŒå‰æ ‘çš„å‰åºåºåˆ—åŒ–
åºåˆ—åŒ–äºŒå‰æ ‘çš„ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨å‰åºéå†ã€‚å½“æˆ‘ä»¬é‡åˆ°ä¸€ä¸ªéç©ºèŠ‚ç‚¹æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥è®°å½•ä¸‹è¿™ä¸ªèŠ‚ç‚¹çš„å€¼ã€‚å¦‚æœå®ƒæ˜¯ä¸€ä¸ªç©ºèŠ‚ç‚¹ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªæ ‡è®°å€¼è®°å½•ï¼Œ
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: 3##å˜ä¸º#ï¼Œæ ˆæœ€ååªå‰©ä¸€ä¸ª#ï¼Œè¿”å›trueï¼Œåä¹‹åå›false

    # 
    def isValidSerialization(self, preorder: str) -> bool:

        stack = []
        data = preorder.split(',')
        for s in data:
            stack.append(s)
            while len(stack) >= 3 and stack[-1] == '#' and stack[-2] == '#' and stack[-3] != '#':
                for i in range(3):
                    stack.pop()
                stack.append('#')
        return len(stack) == 1 and stack[0] == '#'
    
#### 2. éé€’å½’
æ€è·¯ï¼š

## 337. æ‰“å®¶åŠ«èˆ III
åœ¨ä¸Šæ¬¡æ‰“åŠ«å®Œä¸€æ¡è¡—é“ä¹‹åå’Œä¸€åœˆæˆ¿å±‹åï¼Œå°å·åˆå‘ç°äº†ä¸€ä¸ªæ–°çš„å¯è¡Œçªƒçš„åœ°åŒºã€‚è¿™ä¸ªåœ°åŒºåªæœ‰ä¸€ä¸ªå…¥å£ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºâ€œæ ¹â€ã€‚ é™¤äº†â€œæ ¹â€ä¹‹å¤–ï¼Œæ¯æ ‹æˆ¿å­æœ‰ä¸”åªæœ‰ä¸€ä¸ªâ€œçˆ¶â€œæˆ¿å­ä¸ä¹‹ç›¸è¿ã€‚ä¸€ç•ªä¾¦å¯Ÿä¹‹åï¼Œèªæ˜çš„å°å·æ„è¯†åˆ°â€œè¿™ä¸ªåœ°æ–¹çš„æ‰€æœ‰æˆ¿å±‹çš„æ’åˆ—ç±»ä¼¼äºä¸€æ£µäºŒå‰æ ‘â€ã€‚ å¦‚æœä¸¤ä¸ªç›´æ¥ç›¸è¿çš„æˆ¿å­åœ¨åŒä¸€å¤©æ™šä¸Šè¢«æ‰“åŠ«ï¼Œæˆ¿å±‹å°†è‡ªåŠ¨æŠ¥è­¦ã€‚
è®¡ç®—åœ¨ä¸è§¦åŠ¨è­¦æŠ¥çš„æƒ…å†µä¸‹ï¼Œå°å·ä¸€æ™šèƒ½å¤Ÿç›—å–çš„æœ€é«˜é‡‘é¢ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: é€’å½’ï¼Œå½“æ ¹èŠ‚ç‚¹ä¸å·æ—¶ï¼Œå·¦å³ä¸¤ä¸ªå­©å­å¯ä»¥å·ï¼Œå¯ä»¥ä¸å·ï¼Œå–å·å’Œä¸å·çš„æœ€å¤§å€¼ï¼Œå½“æ ¹èŠ‚ç‚¹å·æ—¶ï¼Œå·¦å³ä¸¤ä¸ªå­©å­éƒ½ä¸å·ã€‚

    # 
    def rob(self, root: TreeNode) -> int:

        def dfs(root):
            if not root:
                return 0, 0  # å·ï¼Œä¸å·
            left = dfs(root.left)
            right = dfs(root.right)
            # å·å½“å‰èŠ‚ç‚¹ï¼Œå…¶å·¦å³ä¸¤ä¸ªå­©å­éƒ½ä¸èƒ½å·
            v1 = root.val + left[1] + right[1]
            # ä¸å·å½“å‰èŠ‚ç‚¹ï¼Œåˆ™å·¦å³ä¸¤ä¸ªå­©å­å¯ä»¥å·ï¼Œå¯ä»¥ä¸å·ï¼Œå–å­©å­æœ€å¤§å€¼
            v2 = max(left[0], left[1]) + max(right[0], right[1])
            return v1, v2

        res = dfs(root)
        return max(res[0], res[1])
    
#### 2. éé€’å½’
æ€è·¯ï¼š

## 341. æ‰å¹³åŒ–åµŒå¥—åˆ—è¡¨è¿­ä»£å™¨
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªåµŒå¥—çš„æ•´æ•°åˆ—è¡¨ nestedList ã€‚æ¯ä¸ªå…ƒç´ è¦ä¹ˆæ˜¯ä¸€ä¸ªæ•´æ•°ï¼Œè¦ä¹ˆæ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼›è¯¥åˆ—è¡¨çš„å…ƒç´ ä¹Ÿå¯èƒ½æ˜¯æ•´æ•°æˆ–è€…æ˜¯å…¶ä»–åˆ—è¡¨ã€‚è¯·ä½ å®ç°ä¸€ä¸ªè¿­ä»£å™¨å°†å…¶æ‰å¹³åŒ–ï¼Œä½¿ä¹‹èƒ½å¤Ÿéå†è¿™ä¸ªåˆ—è¡¨ä¸­çš„æ‰€æœ‰æ•´æ•°ã€‚
å®ç°æ‰å¹³è¿­ä»£å™¨ç±» NestedIterator ï¼š
NestedIterator(List<NestedInteger> nestedList) ç”¨åµŒå¥—åˆ—è¡¨ nestedList åˆå§‹åŒ–è¿­ä»£å™¨ã€‚
int next() è¿”å›åµŒå¥—åˆ—è¡¨çš„ä¸‹ä¸€ä¸ªæ•´æ•°ã€‚
boolean hasNext() å¦‚æœä»ç„¶å­˜åœ¨å¾…è¿­ä»£çš„æ•´æ•°ï¼Œè¿”å› true ï¼›å¦åˆ™ï¼Œè¿”å› false ã€‚
ä½ çš„ä»£ç å°†ä¼šç”¨ä¸‹è¿°ä¼ªä»£ç æ£€æµ‹ï¼š
    
    # 
    initialize iterator with nestedList
    res = []
    while iterator.hasNext()
        append iterator.next() to the end of res
    return res

å¦‚æœ res ä¸é¢„æœŸçš„æ‰å¹³åŒ–åˆ—è¡¨åŒ¹é…ï¼Œé‚£ä¹ˆä½ çš„ä»£ç å°†ä¼šè¢«åˆ¤ä¸ºæ­£ç¡®ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: é€’å½’ï¼Œå°†NestedIntegeråˆ—è¡¨ä¸­çš„æ•´æ•°åŠ å…¥åˆ—è¡¨ï¼Œå°†NestedIntegeråˆ—è¡¨ä¸­çš„åˆ—è¡¨é€’å½’å‡ºæ•´æ•°åŠ å…¥åˆ—è¡¨ã€‚
    
    # 
    class NestedIterator:
        def __init__(self, nestedList: [NestedInteger]):
            self.res = []
            self.index = 0
            def dfs(nestedList):
                for n in nestedList:
                    if n.isInteger():
                        self.res.append(n.getInteger())
                    else:
                        tmp_list = n.getList()
                        for l in tmp_list:
                            if l.isInteger():
                                self.res.append(l.getInteger())
                            else:
                                dfs(l.getList())
    
            dfs(nestedList)
            self.length = len(self.res)
    
    
        def next(self) -> int:
            data = self.res[self.index]
            self.index += 1
            return data
    
    
        def hasNext(self) -> bool:
            return self.index < self.length                   
    
#### 2. éé€’å½’
æ€è·¯ï¼š
                                           
## 429. N å‰æ ‘çš„å±‚åºéå†
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ª N å‰æ ‘ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„å±‚åºéå†ã€‚ï¼ˆå³ä»å·¦åˆ°å³ï¼Œé€å±‚éå†ï¼‰ã€‚
æ ‘çš„åºåˆ—åŒ–è¾“å…¥æ˜¯ç”¨å±‚åºéå†ï¼Œæ¯ç»„å­èŠ‚ç‚¹éƒ½ç”± null å€¼åˆ†éš”ï¼ˆå‚è§ç¤ºä¾‹ï¼‰ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: äºŒå‰æ ‘å±‚æ¬¡éå†ï¼Œæ”¹é€ ä¸€ä¸‹å³å¯ã€‚

    # 
    def levelOrder(self, root: 'Node') -> List[List[int]]:

        if not root:
            return []

        res = []
        queue = [root]
        while queue:
            res.append([q.val for q in queue])
            l = []
            for q in queue:
                # if q.left:
                #     l.append(q.left)
                # if q.right:
                #     l.append(q.right)
                for c in q.children:
                    l.append(c)
            queue = l

        return res
    
#### 2. éé€’å½’
æ€è·¯ï¼š         
    
## 437. è·¯å¾„æ€»å’Œ III
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ rootÂ ï¼Œå’Œä¸€ä¸ªæ•´æ•° targetSum ï¼Œæ±‚è¯¥äºŒå‰æ ‘é‡ŒèŠ‚ç‚¹å€¼ä¹‹å’Œç­‰äº targetSum çš„ è·¯å¾„ çš„æ•°ç›®ã€‚
è·¯å¾„ ä¸éœ€è¦ä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œä¹Ÿä¸éœ€è¦åœ¨å¶å­èŠ‚ç‚¹ç»“æŸï¼Œä½†æ˜¯è·¯å¾„æ–¹å‘å¿…é¡»æ˜¯å‘ä¸‹çš„ï¼ˆåªèƒ½ä»çˆ¶èŠ‚ç‚¹åˆ°å­èŠ‚ç‚¹ï¼‰ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: å‰ç¼€å’Œ

    # 
    def pathSum(self, root: TreeNode, targetSum: int) -> int:

        if not root:
            return 0

        res = 0
        def dfs(root, preSum):
            nonlocal res
            if not root:
                return
            for i in range(len(preSum)):
                preSum[i] += root.val
            preSum.append(root.val)
            for i in preSum:
                if i == targetSum:
                    res += 1
            dfs(root.left, preSum[:])
            dfs(root.right, preSum[:])

        dfs(root, [])
        return res
    
#### 2. éé€’å½’
æ€è·¯ï¼š       
    
## 449. åºåˆ—åŒ–å’Œååºåˆ—åŒ–äºŒå‰æœç´¢æ ‘
é¢˜ç›®ï¼šåºåˆ—åŒ–æ˜¯å°†æ•°æ®ç»“æ„æˆ–å¯¹è±¡è½¬æ¢ä¸ºä¸€ç³»åˆ—ä½çš„è¿‡ç¨‹ï¼Œä»¥ä¾¿å®ƒå¯ä»¥å­˜å‚¨åœ¨æ–‡ä»¶æˆ–å†…å­˜ç¼“å†²åŒºä¸­ï¼Œæˆ–é€šè¿‡ç½‘ç»œè¿æ¥é“¾è·¯ä¼ è¾“ï¼Œä»¥ä¾¿ç¨ååœ¨åŒä¸€ä¸ªæˆ–å¦ä¸€ä¸ªè®¡ç®—æœºç¯å¢ƒä¸­é‡å»ºã€‚
è®¾è®¡ä¸€ä¸ªç®—æ³•æ¥åºåˆ—åŒ–å’Œååºåˆ—åŒ– äºŒå‰æœç´¢æ ‘ ã€‚ å¯¹åºåˆ—åŒ–/ååºåˆ—åŒ–ç®—æ³•çš„å·¥ä½œæ–¹å¼æ²¡æœ‰é™åˆ¶ã€‚ æ‚¨åªéœ€ç¡®ä¿äºŒå‰æœç´¢æ ‘å¯ä»¥åºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸²ï¼Œå¹¶ä¸”å¯ä»¥å°†è¯¥å­—ç¬¦ä¸²ååºåˆ—åŒ–ä¸ºæœ€åˆçš„äºŒå‰æœç´¢æ ‘ã€‚
ç¼–ç çš„å­—ç¬¦ä¸²åº”å°½å¯èƒ½ç´§å‡‘ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: åºåˆ—åŒ–å‰åºï¼Œååºåˆ—åŒ–æ—¶ç”±å‰åºå¾—åˆ°ä¸­åºï¼Œç„¶åå‰åºï¼Œä¸­åºæ„å»ºäºŒå‰æ ‘ã€‚

    # 
    def pathSum(self, root: TreeNode, targetSum: int) -> int:

        if not root:
            return 0

        res = 0
        def dfs(root, preSum):
            nonlocal res
            if not root:
                return
            for i in range(len(preSum)):
                preSum[i] += root.val
            preSum.append(root.val)
            for i in preSum:
                if i == targetSum:
                    res += 1
            dfs(root.left, preSum[:])
            dfs(root.right, preSum[:])

        dfs(root, [])
        return resclass Codec:

    def serialize(self, root: TreeNode) -> str:
        """Encodes a tree to a single string.
        """
        str1 = ''
        def dfs(root):
            nonlocal str1
            if not root:
                return
            str1 += ' ' + str(root.val)
            dfs(root.left)
            dfs(root.right)
        dfs(root)
        return str1
        

    def deserialize(self, data: str) -> TreeNode:
        """Decodes your encoded data to tree.
        """
        preOrder = []
        for d in data.split(' '):
            if d:
                preOrder.append(int(d))
        inOrder = [p for p in preOrder]
        inOrder.sort()

        # å‰åºã€ä¸­åºæ„å»ºäºŒå‰æ ‘
        def dfs(preOrder, inOrder):
            if not preOrder or not inOrder:
                return
            root = TreeNode(preOrder[0])
            index = inOrder.index(preOrder[0])
            root.left = dfs(preOrder[1:index+1], inOrder[0:index])
            root.right = dfs(preOrder[index+1:], inOrder[index+1:])
            return root

        return dfs(preOrder, inOrder)
    
#### 2. éé€’å½’
æ€è·¯ï¼š   
    
## 997. æ‰¾åˆ°å°é•‡çš„æ³•å®˜
é¢˜ç›®ï¼šåœ¨ä¸€ä¸ªå°é•‡é‡Œï¼ŒæŒ‰ä» 1 åˆ° n ä¸º n ä¸ªäººè¿›è¡Œç¼–å·ã€‚ä¼ è¨€ç§°ï¼Œè¿™äº›äººä¸­æœ‰ä¸€ä¸ªæ˜¯å°é•‡ä¸Šçš„ç§˜å¯†æ³•å®˜ã€‚
å¦‚æœå°é•‡çš„æ³•å®˜çœŸçš„å­˜åœ¨ï¼Œé‚£ä¹ˆï¼š
å°é•‡çš„æ³•å®˜ä¸ç›¸ä¿¡ä»»ä½•äººã€‚
æ¯ä¸ªäººï¼ˆé™¤äº†å°é•‡æ³•å®˜å¤–ï¼‰éƒ½ä¿¡ä»»å°é•‡çš„æ³•å®˜ã€‚
åªæœ‰ä¸€ä¸ªäººåŒæ—¶æ»¡è¶³æ¡ä»¶ 1 å’Œæ¡ä»¶ 2 ã€‚
ç»™å®šæ•°ç»„Â trustï¼Œè¯¥æ•°ç»„ç”±ä¿¡ä»»å¯¹ trust[i] = [a, b]Â ç»„æˆï¼Œè¡¨ç¤ºç¼–å·ä¸º a çš„äººä¿¡ä»»ç¼–å·ä¸º b çš„äººã€‚
å¦‚æœå°é•‡å­˜åœ¨ç§˜å¯†æ³•å®˜å¹¶ä¸”å¯ä»¥ç¡®å®šä»–çš„èº«ä»½ï¼Œè¯·è¿”å›è¯¥æ³•å®˜çš„ç¼–å·ã€‚å¦åˆ™ï¼Œè¿”å› -1ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: æœ‰å‘å›¾ï¼Œæ³•å®˜æ˜¯å‡ºåº¦ä¸º0ï¼Œå…¥åº¦ä¸ºn-1çš„èŠ‚ç‚¹ã€‚

    # 
    def findJudge(self, n: int, trust: List[List[int]]) -> int:

        # æ³•å®˜çš„å‡ºåº¦æ˜¯0ï¼Œå…¥åº¦æ˜¯n-1,ä¸”åªå­˜åœ¨ä¸€ä¸ªè¿™æ ·çš„èŠ‚ç‚¹
        in_degree = [0] * (n+1)
        out_degree = [0] * (n+1) 
        for a, b in trust:
            out_degree[a] += 1
            in_degree[b] += 1
        for i in range(1, n+1):
            if in_degree[i] == n-1 and out_degree[i] == 0:
                return i
        return -1 
    
#### 2. éé€’å½’
æ€è·¯ï¼š    
    
## 1791. æ‰¾å‡ºæ˜Ÿå‹å›¾çš„ä¸­å¿ƒèŠ‚ç‚¹
é¢˜ç›®ï¼šæœ‰ä¸€ä¸ªæ— å‘çš„ æ˜Ÿå‹ å›¾ï¼Œç”± n ä¸ªç¼–å·ä» 1 åˆ° n çš„èŠ‚ç‚¹ç»„æˆã€‚æ˜Ÿå‹å›¾æœ‰ä¸€ä¸ª ä¸­å¿ƒ èŠ‚ç‚¹ï¼Œå¹¶ä¸”æ°æœ‰ n - 1 æ¡è¾¹å°†ä¸­å¿ƒèŠ‚ç‚¹ä¸å…¶ä»–æ¯ä¸ªèŠ‚ç‚¹è¿æ¥èµ·æ¥ã€‚
ç»™ä½ ä¸€ä¸ªäºŒç»´æ•´æ•°æ•°ç»„ edges ï¼Œå…¶ä¸­Â edges[i] = [ui, vi] è¡¨ç¤ºåœ¨èŠ‚ç‚¹ ui å’Œ vi ä¹‹é—´å­˜åœ¨ä¸€æ¡è¾¹ã€‚è¯·ä½ æ‰¾å‡ºå¹¶è¿”å›Â edges æ‰€è¡¨ç¤ºæ˜Ÿå‹å›¾çš„ä¸­å¿ƒèŠ‚ç‚¹ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: ä¾æ¬¡å°±å…¥åº¦ï¼Œä¸­å¿ƒèŠ‚ç‚¹å…¥åº¦ä¸ºn-1

    # 
    def findCenter(self, edges: List[List[int]]) -> int:

        n = len(edges) + 1
        in_degree = [0] * (n+1)
        for a, b in edges:
            in_degree[a] += 1
            in_degree[b] += 1
        for i in range(1, n+1):
            if in_degree[i] == n - 1:
                return i
        return -1
    
#### 2. éé€’å½’
æ€è·¯ï¼š    
    
## LCP 07. ä¼ é€’ä¿¡æ¯
é¢˜ç›®ï¼šå°æœ‹å‹ A åœ¨å’Œ ta çš„å°ä¼™ä¼´ä»¬ç©ä¼ ä¿¡æ¯æ¸¸æˆï¼Œæ¸¸æˆè§„åˆ™å¦‚ä¸‹ï¼š
æœ‰ n åç©å®¶ï¼Œæ‰€æœ‰ç©å®¶ç¼–å·åˆ†åˆ«ä¸º 0 ï½ n-1ï¼Œå…¶ä¸­å°æœ‹å‹ A çš„ç¼–å·ä¸º 0
æ¯ä¸ªç©å®¶éƒ½æœ‰å›ºå®šçš„è‹¥å¹²ä¸ªå¯ä¼ ä¿¡æ¯çš„å…¶ä»–ç©å®¶ï¼ˆä¹Ÿå¯èƒ½æ²¡æœ‰ï¼‰ã€‚ä¼ ä¿¡æ¯çš„å…³ç³»æ˜¯å•å‘çš„ï¼ˆæ¯”å¦‚ A å¯ä»¥å‘ B ä¼ ä¿¡æ¯ï¼Œä½† B ä¸èƒ½å‘ A ä¼ ä¿¡æ¯ï¼‰ã€‚
æ¯è½®ä¿¡æ¯å¿…é¡»éœ€è¦ä¼ é€’ç»™å¦ä¸€ä¸ªäººï¼Œä¸”ä¿¡æ¯å¯é‡å¤ç»è¿‡åŒä¸€ä¸ªäºº
ç»™å®šæ€»ç©å®¶æ•° nï¼Œä»¥åŠæŒ‰ [ç©å®¶ç¼–å·,å¯¹åº”å¯ä¼ é€’ç©å®¶ç¼–å·] å…³ç³»ç»„æˆçš„äºŒç»´æ•°ç»„ relationã€‚è¿”å›ä¿¡æ¯ä»å° A (ç¼–å· 0 ) ç»è¿‡ k è½®ä¼ é€’åˆ°ç¼–å·ä¸º n-1 çš„å°ä¼™ä¼´å¤„çš„æ–¹æ¡ˆæ•°ï¼›è‹¥ä¸èƒ½åˆ°è¾¾ï¼Œè¿”å› 0ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: æ·±åº¦ä¼˜å…ˆéå†ï¼Œå½“èµ°äº†kæ­¥ï¼Œä¸”å½“å‰èŠ‚ç‚¹åœ¨n-1æ—¶+1ã€‚

    # 
    def numWays(self, n: int, relation: List[List[int]], k: int) -> int:
        edages = {}
        for a, b in relation:
            if a not in edages:
                edages[a] = [b]
            else:
                edages[a].append(b)
        ways = 0

        print(edages)

        def dfs(index, steps):
            nonlocal n, k, ways, edages
            if steps == k :
                if index == n - 1:
                    ways += 1
                return
            if index in edages:
                for i in edages[index]:
                    dfs(i, steps + 1)
        
        dfs(0, 0)
        return ways
    
#### 2. éé€’å½’
æ€è·¯ï¼š    
    
## 207. è¯¾ç¨‹è¡¨
é¢˜ç›®ï¼šä½ è¿™ä¸ªå­¦æœŸå¿…é¡»é€‰ä¿® numCourses é—¨è¯¾ç¨‹ï¼Œè®°ä¸ºÂ 0Â åˆ°Â numCourses - 1 ã€‚
åœ¨é€‰ä¿®æŸäº›è¯¾ç¨‹ä¹‹å‰éœ€è¦ä¸€äº›å…ˆä¿®è¯¾ç¨‹ã€‚ å…ˆä¿®è¯¾ç¨‹æŒ‰æ•°ç»„Â prerequisites ç»™å‡ºï¼Œå…¶ä¸­Â prerequisites[i] = [ai, bi] ï¼Œè¡¨ç¤ºå¦‚æœè¦å­¦ä¹ è¯¾ç¨‹Â ai åˆ™ å¿…é¡» å…ˆå­¦ä¹ è¯¾ç¨‹Â  bi ã€‚
ä¾‹å¦‚ï¼Œå…ˆä¿®è¯¾ç¨‹å¯¹Â [0, 1] è¡¨ç¤ºï¼šæƒ³è¦å­¦ä¹ è¯¾ç¨‹ 0 ï¼Œä½ éœ€è¦å…ˆå®Œæˆè¯¾ç¨‹ 1 ã€‚
è¯·ä½ åˆ¤æ–­æ˜¯å¦å¯èƒ½å®Œæˆæ‰€æœ‰è¯¾ç¨‹çš„å­¦ä¹ ï¼Ÿå¦‚æœå¯ä»¥ï¼Œè¿”å› true ï¼›å¦åˆ™ï¼Œè¿”å› false ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: åˆ¤æ–­æ˜¯å¦ä¸ºæœ‰å‘æ— ç¯å›¾ã€‚

    # 
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:

        # åˆ¤æ–­è¯¾ç¨‹è¡¨æ˜¯ä¸æ˜¯æœ‰å‘æ— ç¯å›¾
        in_degree = [0] * numCourses # è®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„å…¥åº¦
        adjest = {} # é‚»æ¥çŸ©é˜µ
        for cur, pre in prerequisites:
            in_degree[cur] += 1
            if pre not in adjest:
                adjest[pre] = [cur]
            else:
                adjest[pre].append(cur)
        # æ‰¾åˆ°æ‰€æœ‰å…¥åº¦ä¸º0çš„èŠ‚ç‚¹ï¼ŒåŠ å…¥é˜Ÿåˆ—ï¼Œç„¶ååˆ é™¤å…¥åº¦ä¸º0çš„èŠ‚ç‚¹ï¼Œè¯¥èŠ‚ç‚¹çš„ä¸´æ¥èŠ‚ç‚¹å…¥åº¦-1
        queue = []
        for i in range(len(in_degree)):
            if in_degree[i] == 0:
                queue.append(i)
        
        while queue:
            pre = queue.pop(0)
            # åˆ é™¤å…¥åº¦ä¸º0çš„èŠ‚ç‚¹ï¼Œå³è¯¾ç¨‹æ•°-1
            numCourses -= 1
            if pre in adjest:
                for i in adjest[pre]:
                    in_degree[i] -= 1
                    if in_degree[i] == 0:
                        queue.append(i)

        return numCourses == 0
    
#### 2. éé€’å½’
æ€è·¯ï¼š    
     
## 210. è¯¾ç¨‹è¡¨ II
é¢˜ç›®ï¼šç°åœ¨ä½ æ€»å…±æœ‰ numCourses é—¨è¯¾éœ€è¦é€‰ï¼Œè®°ä¸ºÂ 0Â åˆ°Â numCourses - 1ã€‚ç»™ä½ ä¸€ä¸ªæ•°ç»„Â prerequisites ï¼Œå…¶ä¸­ prerequisites[i] = [ai, bi] ï¼Œè¡¨ç¤ºåœ¨é€‰ä¿®è¯¾ç¨‹ ai å‰ å¿…é¡» å…ˆé€‰ä¿®Â bi ã€‚
ä¾‹å¦‚ï¼Œæƒ³è¦å­¦ä¹ è¯¾ç¨‹ 0 ï¼Œä½ éœ€è¦å…ˆå®Œæˆè¯¾ç¨‹Â 1 ï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ªåŒ¹é…æ¥è¡¨ç¤ºï¼š[0,1] ã€‚
è¿”å›ä½ ä¸ºäº†å­¦å®Œæ‰€æœ‰è¯¾ç¨‹æ‰€å®‰æ’çš„å­¦ä¹ é¡ºåºã€‚å¯èƒ½ä¼šæœ‰å¤šä¸ªæ­£ç¡®çš„é¡ºåºï¼Œä½ åªè¦è¿”å› ä»»æ„ä¸€ç§ å°±å¯ä»¥äº†ã€‚å¦‚æœä¸å¯èƒ½å®Œæˆæ‰€æœ‰è¯¾ç¨‹ï¼Œè¿”å› ä¸€ä¸ªç©ºæ•°ç»„ ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: åˆ¤æ–­æ˜¯å¦ä¸ºæœ‰å‘æ— ç¯å›¾,å¹¶è®°å½•åˆ é™¤çš„å…¥åº¦ä¸º0çš„èŠ‚ç‚¹è¿”å›å³å¯ã€‚

    # 
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:

        in_degree = [0] * numCourses
        adjest = {}
        for cur, pre in prerequisites:
            in_degree[cur] += 1
            if pre not in adjest:
                adjest[pre] = [cur]
            else:
                adjest[pre].append(cur)
        queue = []
        for i in range(len(in_degree)):
            if in_degree[i] == 0:
                queue.append(i)

        res = []
        while queue:
            numCourses -= 1
            pre = queue.pop(0)
            res.append(pre)
            if pre in adjest:
                for i in adjest[pre]:
                    in_degree[i] -= 1
                    if in_degree[i] == 0:
                        queue.append(i)
        if numCourses == 0:
            return res
        else:
            return []
    
#### 2. éé€’å½’
æ€è·¯ï¼š     
    
## 53. æœ€å¤§å­åºå’Œ
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œæ‰¾åˆ°ä¸€ä¸ªå…·æœ‰æœ€å¤§å’Œçš„è¿ç»­å­æ•°ç»„ï¼ˆå­æ•°ç»„æœ€å°‘åŒ…å«ä¸€ä¸ªå…ƒç´ ï¼‰ï¼Œè¿”å›å…¶æœ€å¤§å’Œã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: å®šä¹‰dp[i]è¡¨ç¤ºä»¥iä¸ºç»“å°¾çš„æœ€å¤§å­åºå’Œï¼Œdp[i] = max(dp[i] + nums[i], nums[i])

    # 
    def maxSubArray(self, nums: List[int]) -> int:

        dp = [0] * len(nums)
        dp[0] = nums[0]
        for i in range(1, len(nums)):
            dp[i] = max(dp[i-1]+nums[i], nums[i])
        return max(dp)
    
#### 2. éé€’å½’
æ€è·¯ï¼š  
    
## 70. çˆ¬æ¥¼æ¢¯
é¢˜ç›®ï¼šå‡è®¾ä½ æ­£åœ¨çˆ¬æ¥¼æ¢¯ã€‚éœ€è¦ n é˜¶ä½ æ‰èƒ½åˆ°è¾¾æ¥¼é¡¶ã€‚
æ¯æ¬¡ä½ å¯ä»¥çˆ¬ 1 æˆ– 2 ä¸ªå°é˜¶ã€‚ä½ æœ‰å¤šå°‘ç§ä¸åŒçš„æ–¹æ³•å¯ä»¥çˆ¬åˆ°æ¥¼é¡¶å‘¢ï¼Ÿ
æ³¨æ„ï¼šç»™å®š n æ˜¯ä¸€ä¸ªæ­£æ•´æ•°ã€‚
#### 1. é€’å½’
æ€è·¯: å®šä¹‰dp[i]è¡¨ç¤ºä»¥içº§é˜¶æ¢¯çš„çˆ¬æ³•æ€»å’Œï¼Œdp[i] = dp[i-1] + dp[i-2]

    # 
    def climbStairs(self, n: int) -> int:
        if n == 1:
            return 1
        dp = [0] * (n+1)
        dp[1] = 1
        dp[2] = 2
        for i in range(3, n+1):
            dp[i] = dp[i-1] + dp[i-2]
        return dp[n]
    
#### 2. éé€’å½’
æ€è·¯ï¼š  
    
## 118. æ¨è¾‰ä¸‰è§’
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªéè´Ÿæ•´æ•° numRowsï¼Œç”Ÿæˆã€Œæ¨è¾‰ä¸‰è§’ã€çš„å‰ numRows è¡Œã€‚
åœ¨ã€Œæ¨è¾‰ä¸‰è§’ã€ä¸­ï¼Œæ¯ä¸ªæ•°æ˜¯å®ƒå·¦ä¸Šæ–¹å’Œå³ä¸Šæ–¹çš„æ•°çš„å’Œã€‚
#### 1. é€’å½’
æ€è·¯: dp,åŠ¨æ€è§„åˆ’

    # 
    def generate(self, numRows: int) -> List[List[int]]:
        dp = []
        temp = []
        for i in range(numRows):
            temp = [1] * (i+1)
            for j in range(1, i):
                temp[j] = dp[i-1][j-1] + dp[i-1][j]
            dp.append(temp)
        return dp
    
#### 2. éé€’å½’
æ€è·¯ï¼š  
    
## 119. æ¨è¾‰ä¸‰è§’ II
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªéè´Ÿç´¢å¼• rowIndexï¼Œè¿”å›ã€Œæ¨è¾‰ä¸‰è§’ã€çš„ç¬¬ rowIndex è¡Œã€‚
åœ¨ã€Œæ¨è¾‰ä¸‰è§’ã€ä¸­ï¼Œæ¯ä¸ªæ•°æ˜¯å®ƒå·¦ä¸Šæ–¹å’Œå³ä¸Šæ–¹çš„æ•°çš„å’Œã€‚
#### 1. é€’å½’
æ€è·¯: dp,åŠ¨æ€è§„åˆ’

    # 
    def getRow(self, rowIndex: int) -> List[int]:
        dp = []
        for i in range(rowIndex+1):
            temp = [1] * (i+1)
            for j in range(1, i):
                temp[j] = dp[i-1][j-1] + dp[i-1][j]
            dp.append(temp)
        return dp[rowIndex]
    
#### 2. éé€’å½’
æ€è·¯ï¼š  
    
## 121. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªæ•°ç»„ prices ï¼Œå®ƒçš„ç¬¬Â i ä¸ªå…ƒç´ Â prices[i] è¡¨ç¤ºä¸€æ”¯ç»™å®šè‚¡ç¥¨ç¬¬ i å¤©çš„ä»·æ ¼ã€‚
ä½ åªèƒ½é€‰æ‹© æŸä¸€å¤© ä¹°å…¥è¿™åªè‚¡ç¥¨ï¼Œå¹¶é€‰æ‹©åœ¨ æœªæ¥çš„æŸä¸€ä¸ªä¸åŒçš„æ—¥å­ å–å‡ºè¯¥è‚¡ç¥¨ã€‚è®¾è®¡ä¸€ä¸ªç®—æ³•æ¥è®¡ç®—ä½ æ‰€èƒ½è·å–çš„æœ€å¤§åˆ©æ¶¦ã€‚
è¿”å›ä½ å¯ä»¥ä»è¿™ç¬”äº¤æ˜“ä¸­è·å–çš„æœ€å¤§åˆ©æ¶¦ã€‚å¦‚æœä½ ä¸èƒ½è·å–ä»»ä½•åˆ©æ¶¦ï¼Œè¿”å› 0 ã€‚
#### 1. é€’å½’
æ€è·¯: dp,åŠ¨æ€è§„åˆ’ï¼Œdp[i]è¡¨ç¤ºç¬¬iå¤©è·å¾—çš„æœ€å¤§åˆ©æ¶¦ï¼Œdp[i] = max(dp[i-1], prices[i] - minPirce),å…¶ä¸­minPriceè¡¨ç¤ºå‰i-1å¤©çš„æœ€ä½ä»·æ ¼

    # 
    def maxProfit(self, prices: List[int]) -> int:

        dp = [0] * len(prices)
        dp[0] = 0
        minPirce = prices[0]
        for i in range(1, len(prices)):
            dp[i] = max(dp[i-1], prices[i] - minPirce) 
            minPirce = min(minPirce, prices[i])
        return dp[-1]
        return dp[rowIndex]
    
#### 2. éé€’å½’
æ€è·¯ï¼š  
    
## 338. æ¯”ç‰¹ä½è®¡æ•°
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªæ•´æ•° n ï¼Œå¯¹äº 0 <= i <= n ä¸­çš„æ¯ä¸ª i ï¼Œè®¡ç®—å…¶äºŒè¿›åˆ¶è¡¨ç¤ºä¸­ 1 çš„ä¸ªæ•° ï¼Œè¿”å›ä¸€ä¸ªé•¿åº¦ä¸º n + 1 çš„æ•°ç»„ ans ä½œä¸ºç­”æ¡ˆã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: iä¸ºå¶æ•°ï¼Œ1çš„ä¸ªæ•°=i/2çš„1çš„ä¸ªæ•°ï¼Œi ä¸ºå¥‡æ•°ï¼Œ1çš„ä¸ªæ•°=i-1çš„ä¸ªæ•°ã€‚

    # 
    def countBits(self, n: int) -> List[int]:
        # dpå®ç°
        dp = [0] * (n+1)
        for i in range(n+1):
            if i % 2 == 0:
                dp[i] = dp[i // 2]
            else:
                dp[i] = dp[i-1] + 1
        return dp
    
#### 2. éé€’å½’
æ€è·¯ï¼š  
    
## 392. åˆ¤æ–­å­åºåˆ—
é¢˜ç›®ï¼šç»™å®šå­—ç¬¦ä¸² s å’Œ t ï¼Œåˆ¤æ–­ s æ˜¯å¦ä¸º t çš„å­åºåˆ—ã€‚
å­—ç¬¦ä¸²çš„ä¸€ä¸ªå­åºåˆ—æ˜¯åŸå§‹å­—ç¬¦ä¸²åˆ é™¤ä¸€äº›ï¼ˆä¹Ÿå¯ä»¥ä¸åˆ é™¤ï¼‰å­—ç¬¦è€Œä¸æ”¹å˜å‰©ä½™å­—ç¬¦ç›¸å¯¹ä½ç½®å½¢æˆçš„æ–°å­—ç¬¦ä¸²ã€‚ï¼ˆä¾‹å¦‚ï¼Œ"ace"æ˜¯"abcde"çš„ä¸€ä¸ªå­åºåˆ—ï¼Œè€Œ"aec"ä¸æ˜¯ï¼‰ã€‚
è¿›é˜¶ï¼š
å¦‚æœæœ‰å¤§é‡è¾“å…¥çš„ Sï¼Œç§°ä½œ S1, S2, ... , Sk å…¶ä¸­ k >= 10äº¿ï¼Œä½ éœ€è¦ä¾æ¬¡æ£€æŸ¥å®ƒä»¬æ˜¯å¦ä¸º T çš„å­åºåˆ—ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä½ ä¼šæ€æ ·æ”¹å˜ä»£ç ï¼Ÿ
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: éå†Tï¼Œçœ‹æ¯ä¸ªå­—ç¬¦æ˜¯å¦åœ¨Sä¸­ï¼Œè‹¥åœ¨åˆ™ç»§ç»­éå†ï¼Œæœ€åçœ‹Sæ˜¯å¦å·²éå†å®Œï¼Œéå†å®Œè¿”å›true,å¦åˆ™è¿”å›false.

    # 
    def isSubsequence(self, s: str, t: str) -> bool:

        index = 0
        for i in t:
            if index == len(s):
                return True
            if i == s[index]:
                index += 1
        if index == len(s):
            return True
        else:
            return False
    
#### 2. éé€’å½’
æ€è·¯ï¼š  
    
## 509. æ–æ³¢é‚£å¥‘æ•°
é¢˜ç›®ï¼šæ–æ³¢é‚£å¥‘æ•°ï¼Œé€šå¸¸ç”¨Â F(n) è¡¨ç¤ºï¼Œå½¢æˆçš„åºåˆ—ç§°ä¸º æ–æ³¢é‚£å¥‘æ•°åˆ— ã€‚è¯¥æ•°åˆ—ç”±Â 0 å’Œ 1 å¼€å§‹ï¼Œåé¢çš„æ¯ä¸€é¡¹æ•°å­—éƒ½æ˜¯å‰é¢ä¸¤é¡¹æ•°å­—çš„å’Œã€‚ä¹Ÿå°±æ˜¯ï¼š
F(0) = 0ï¼ŒF(1)Â = 1
F(n) = F(n - 1) + F(n - 2)ï¼Œå…¶ä¸­ n > 1
ç»™ä½  n ï¼Œè¯·è®¡ç®— F(n) ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: dp[i] è¡¨ç¤ºiçš„æ•°å’Œï¼Œdp[i] = dp[i-1] + dp[i-2]

    # 
    def fib(self, n: int) -> int:
        if n <= 0:
            return 0
        dp = [0] * (n+1)
        dp[1] = 1
        for i in range(2, n+1):
            dp[i] = dp[i-1]+ dp[i-2]
        return dp[n]
                 
#### 2. éé€’å½’
æ€è·¯ï¼š  
                 
## 746. ä½¿ç”¨æœ€å°èŠ±è´¹çˆ¬æ¥¼æ¢¯
é¢˜ç›®ï¼šæ•°ç»„çš„æ¯ä¸ªä¸‹æ ‡ä½œä¸ºä¸€ä¸ªé˜¶æ¢¯ï¼Œç¬¬ i ä¸ªé˜¶æ¢¯å¯¹åº”ç€ä¸€ä¸ªéè´Ÿæ•°çš„ä½“åŠ›èŠ±è´¹å€¼Â cost[i]ï¼ˆä¸‹æ ‡ä» 0 å¼€å§‹ï¼‰ã€‚
æ¯å½“ä½ çˆ¬ä¸Šä¸€ä¸ªé˜¶æ¢¯ä½ éƒ½è¦èŠ±è´¹å¯¹åº”çš„ä½“åŠ›å€¼ï¼Œä¸€æ—¦æ”¯ä»˜äº†ç›¸åº”çš„ä½“åŠ›å€¼ï¼Œä½ å°±å¯ä»¥é€‰æ‹©å‘ä¸Šçˆ¬ä¸€ä¸ªé˜¶æ¢¯æˆ–è€…çˆ¬ä¸¤ä¸ªé˜¶æ¢¯ã€‚
è¯·ä½ æ‰¾å‡ºè¾¾åˆ°æ¥¼å±‚é¡¶éƒ¨çš„æœ€ä½èŠ±è´¹ã€‚åœ¨å¼€å§‹æ—¶ï¼Œä½ å¯ä»¥é€‰æ‹©ä»ä¸‹æ ‡ä¸º 0 æˆ– 1 çš„å…ƒç´ ä½œä¸ºåˆå§‹é˜¶æ¢¯ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: dp[i] è¡¨ç¤ºåˆ°è¾¾içº§é˜¶æ¢¯çš„æœ€å°èŠ±è´¹ï¼Œåˆ™dp[i] = min(dp[i-1], dp[i-2]) + cost[i]

    # 
    def minCostClimbingStairs(self, cost: List[int]) -> int:

        n = len(cost)
        dp = [0] * n
        dp[0] = cost[0]
        dp[1] = cost[1]
        for i in range(2, len(cost)):
            dp[i] = min(dp[i-1], dp[i-2]) + cost[i]
        return min(dp[n-1], dp[n-2])
                 
#### 2. éé€’å½’
æ€è·¯ï¼š  
    
    
## 1025. é™¤æ•°åšå¼ˆ
é¢˜ç›®ï¼šçˆ±ä¸½ä¸å’Œé²å‹ƒä¸€èµ·ç©æ¸¸æˆï¼Œä»–ä»¬è½®æµè¡ŒåŠ¨ã€‚çˆ±ä¸½ä¸å…ˆæ‰‹å¼€å±€ã€‚
æœ€åˆï¼Œé»‘æ¿ä¸Šæœ‰ä¸€ä¸ªæ•°å­—Â NÂ ã€‚åœ¨æ¯ä¸ªç©å®¶çš„å›åˆï¼Œç©å®¶éœ€è¦æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š
é€‰å‡ºä»»ä¸€Â xï¼Œæ»¡è¶³Â 0 < x < N ä¸”Â N % x == 0Â ã€‚
ç”¨ N - xÂ æ›¿æ¢é»‘æ¿ä¸Šçš„æ•°å­— N ã€‚
å¦‚æœç©å®¶æ— æ³•æ‰§è¡Œè¿™äº›æ“ä½œï¼Œå°±ä¼šè¾“æ‰æ¸¸æˆã€‚
åªæœ‰åœ¨çˆ±ä¸½ä¸åœ¨æ¸¸æˆä¸­å–å¾—èƒœåˆ©æ—¶æ‰è¿”å›Â Trueï¼Œå¦åˆ™è¿”å› Falseã€‚å‡è®¾ä¸¤ä¸ªç©å®¶éƒ½ä»¥æœ€ä½³çŠ¶æ€å‚ä¸æ¸¸æˆã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: å…ˆæ‰‹ï¼Œå¶èµ¢å¥‡è¾“ã€‚
    
    # 
    def divisorGame(self, n: int) -> bool:
        return n % 2 == 0
                 
#### 2. éé€’å½’
æ€è·¯ï¼š 
    
## 1137. ç¬¬ N ä¸ªæ³°æ³¢é‚£å¥‘æ•°
é¢˜ç›®ï¼šæ³°æ³¢é‚£å¥‘åºåˆ—Â TnÂ å®šä¹‰å¦‚ä¸‹ï¼šÂ 
T0 = 0, T1 = 1, T2 = 1, ä¸”åœ¨ n >= 0Â çš„æ¡ä»¶ä¸‹ Tn+3 = Tn + Tn+1 + Tn+2
ç»™ä½ æ•´æ•°Â nï¼Œè¯·è¿”å›ç¬¬ n ä¸ªæ³°æ³¢é‚£å¥‘æ•°Â Tn çš„å€¼ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: å…ˆæ‰‹ï¼Œå¶èµ¢å¥‡è¾“ã€‚
    
    # 
    def tribonacci(self, n: int) -> int:
        if n <= 0:
            return 0
        elif n <= 2:
            return 1
        dp = [0] * (n+1)
        dp[1] = 1
        dp[2] = 1
        for i in range(3, n+1):
            dp[i] = dp[i-1] + dp[i-2] + dp[i-3]
        return dp[-1]
                 
#### 2. éé€’å½’
æ€è·¯ï¼š 
    
## 1646. è·å–ç”Ÿæˆæ•°ç»„ä¸­çš„æœ€å¤§å€¼
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªæ•´æ•° n ã€‚æŒ‰ä¸‹è¿°è§„åˆ™ç”Ÿæˆä¸€ä¸ªé•¿åº¦ä¸º n + 1 çš„æ•°ç»„ nums ï¼š
nums[0] = 0
nums[1] = 1
å½“ 2 <= 2 * i <= n æ—¶ï¼Œnums[2 * i] = nums[i]
å½“ 2 <= 2 * i + 1 <= n æ—¶ï¼Œnums[2 * i + 1] = nums[i] + nums[i + 1]
è¿”å›ç”Ÿæˆæ•°ç»„ nums ä¸­çš„ æœ€å¤§ å€¼ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: æŒ‰ç…§å…¬å¼è®¡ç®—å³å¯ã€‚
    
    # 
    def getMaximumGenerated(self, n: int) -> int:
        if n == 0:
            return 0
        nums = [0] * (n+1)
        nums[1] = 1
        for i in range(1, n+1):
            if 2 * i  >= 2 and 2 * i <= n:
                nums[2 * i] = nums[i]
            if 2 * i + 1  >= 2 and 2 * i + 1 <= n:
                nums[2 * i + 1] = nums[i] + nums[i + 1]
        return max(nums)
                 
#### 2. éé€’å½’
æ€è·¯ï¼š 

## 5. æœ€é•¿å›æ–‡å­ä¸²
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² sï¼Œæ‰¾åˆ° s ä¸­æœ€é•¿çš„å›æ–‡å­ä¸²ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: dp[i][j] è¡¨ç¤º[i][j]å­—ç¬¦ä¸²æ˜¯å¦æ˜¯å›æ–‡ä¸²ï¼Œdp[i][j] = dp[i+1][j-1] && s[i] == s[j], j - i >= 2
    
    # 
    def longestPalindrome(self, s: str) -> str:

        n = len(s)
        dp = [[False for _ in range(n)] for _ in range(n)]
        # dp[i][j]è¡¨ç¤º[i, j]çš„å­—ç¬¦ä¸²æ˜¯å¦æ˜¯å›æ–‡ä¸²
        # dp[i][j] = dp[i+1][j-1] && s[i] == s[j], j - i >= 2
        for i in range(n):
            dp[i][i] = True

        start, end = 0, 0
        max_len = 0
        for j in range(n):
            for i in range(j):
                if j - i >= 2:
                    if dp[i+1][j-1] and s[i] == s[j]:
                        dp[i][j] = True
                        if j - i + 1 > max_len:
                            max_len = j - i + 1
                            start, end = i, j
                elif j - i == 1:
                    if s[i] == s[j]:
                        dp[i][j] = True
                        if j - i + 1 > max_len:
                            max_len = j - i + 1
                            start, end = i, j
        return s[start:end+1]
                 
#### 2. éé€’å½’
æ€è·¯ï¼š 

## 45. è·³è·ƒæ¸¸æˆ II
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªéè´Ÿæ•´æ•°æ•°ç»„Â nums ï¼Œä½ æœ€åˆä½äºæ•°ç»„çš„ç¬¬ä¸€ä¸ªä½ç½®ã€‚
æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ ä»£è¡¨ä½ åœ¨è¯¥ä½ç½®å¯ä»¥è·³è·ƒçš„æœ€å¤§é•¿åº¦ã€‚
ä½ çš„ç›®æ ‡æ˜¯ä½¿ç”¨æœ€å°‘çš„è·³è·ƒæ¬¡æ•°åˆ°è¾¾æ•°ç»„çš„æœ€åä¸€ä¸ªä½ç½®ã€‚
å‡è®¾ä½ æ€»æ˜¯å¯ä»¥åˆ°è¾¾æ•°ç»„çš„æœ€åä¸€ä¸ªä½ç½®ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: dp[i]è¡¨ç¤ºè·³åˆ°iä½ç½®å¤„æ‰€éœ€çš„æœ€å°æ­¥æ•°ï¼Œdp[i] = min(dp[i], dp[j] + 1), å…¶ä¸­0<=j<iã€‚
    
    # 
    def jump(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [math.inf] * n  # dp[i] è¡¨ç¤ºè·³åˆ°iä½ç½®éœ€è¦çš„æœ€å°æ¬¡æ•°
        dp[0] = 0
        for i in range(1, n):
            for j in range(i):
                if i - j <= nums[j]:
                    dp[i] =  min(dp[i], dp[j] + 1)  # jæ˜¯[0, i-1]åˆ°è¾¾iä½ç½®æœ€å°çš„æ¬¡æ•°
        # print(dp)
        return dp[-1]
                 
#### 2. éé€’å½’
æ€è·¯ï¼š 
                                   
## 55. è·³è·ƒæ¸¸æˆ
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªéè´Ÿæ•´æ•°æ•°ç»„ nums ï¼Œä½ æœ€åˆä½äºæ•°ç»„çš„ ç¬¬ä¸€ä¸ªä¸‹æ ‡ ã€‚
æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ ä»£è¡¨ä½ åœ¨è¯¥ä½ç½®å¯ä»¥è·³è·ƒçš„æœ€å¤§é•¿åº¦ã€‚
åˆ¤æ–­ä½ æ˜¯å¦èƒ½å¤Ÿåˆ°è¾¾æœ€åä¸€ä¸ªä¸‹æ ‡ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: dp[i]è¡¨ç¤ºåœ¨iä½ç½®å¤„èƒ½è·³çš„æœ€å¤§è·ç¦»ï¼Œdp[i] = max(dp[i-1], i+nums[i]), dp[i-1] >= i, å¦åˆ™ dp[i] = dp[i-1]
    
    # 
    def canJump(self, nums: List[int]) -> bool:
        n = len(nums)
        dp = [0] * n
        dp[0] = nums[0]
        for i in range(1, n):
            if dp[i-1] >= i:
                dp[i] = max(dp[i-1], i + nums[i])
            else:
                dp[i] = dp[i-1]  # å‰é¢èƒ½è·³çš„æœ€å¤§è·ç¦»éƒ½è·³ä¸åˆ°å½“å‰ä½ç½®ï¼Œé‚£ä¹ˆå½“å‰ä½ç½®èƒ½è·³å¤§çš„æœ€å¤§è·ç¦»å–å‰ä¸€èƒ½è·³åˆ°çš„æœ€å¤§è·ç¦»ã€‚
        # print(dp)
        return dp[-1] >= len(nums) - 1
                 
#### 2. éé€’å½’
æ€è·¯ï¼š 

## 62. ä¸åŒè·¯å¾„
é¢˜ç›®ï¼šä¸€ä¸ªæœºå™¨äººä½äºä¸€ä¸ª m x nÂ ç½‘æ ¼çš„å·¦ä¸Šè§’ ï¼ˆèµ·å§‹ç‚¹åœ¨ä¸‹å›¾ä¸­æ ‡è®°ä¸º â€œStartâ€ ï¼‰ã€‚
æœºå™¨äººæ¯æ¬¡åªèƒ½å‘ä¸‹æˆ–è€…å‘å³ç§»åŠ¨ä¸€æ­¥ã€‚æœºå™¨äººè¯•å›¾è¾¾åˆ°ç½‘æ ¼çš„å³ä¸‹è§’ï¼ˆåœ¨ä¸‹å›¾ä¸­æ ‡è®°ä¸º â€œFinishâ€ ï¼‰ã€‚
é—®æ€»å…±æœ‰å¤šå°‘æ¡ä¸åŒçš„è·¯å¾„ï¼Ÿ
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: dp[i][j]è¡¨ç¤ºåˆ°è¾¾[i, j]ä½ç½®æ—¶çš„è·¯å¾„æ•°ï¼Œdp[i][j] = dp[i-1][j] + dp[i][j-1]
    
    # 
    def uniquePaths(self, m: int, n: int) -> int:

        # i>0 j and j>0 dp[i][j] = dp[i-1][j] + dp[i][j-1]
        dp = [[0 for _ in range(n)] for _ in range(m)]
        dp[0][0] = 1
        for i in range(m):
            for j in range(n):
                if i == 0:
                    dp[i][j] = 1
                elif j == 0:
                    dp[i][j] = 1
                else:
                    dp[i][j] = dp[i-1][j] + dp[i][j-1]
        return dp[m-1][n-1]
                 
#### 2. éé€’å½’
æ€è·¯ï¼š
    
## 63. ä¸åŒè·¯å¾„ II
é¢˜ç›®ï¼šä¸€ä¸ªæœºå™¨äººä½äºä¸€ä¸ª m x n ç½‘æ ¼çš„å·¦ä¸Šè§’ ï¼ˆèµ·å§‹ç‚¹åœ¨ä¸‹å›¾ä¸­æ ‡è®°ä¸ºâ€œStartâ€ ï¼‰ã€‚
æœºå™¨äººæ¯æ¬¡åªèƒ½å‘ä¸‹æˆ–è€…å‘å³ç§»åŠ¨ä¸€æ­¥ã€‚æœºå™¨äººè¯•å›¾è¾¾åˆ°ç½‘æ ¼çš„å³ä¸‹è§’ï¼ˆåœ¨ä¸‹å›¾ä¸­æ ‡è®°ä¸ºâ€œFinishâ€ï¼‰ã€‚
ç°åœ¨è€ƒè™‘ç½‘æ ¼ä¸­æœ‰éšœç¢ç‰©ã€‚é‚£ä¹ˆä»å·¦ä¸Šè§’åˆ°å³ä¸‹è§’å°†ä¼šæœ‰å¤šå°‘æ¡ä¸åŒçš„è·¯å¾„ï¼Ÿ
ç½‘æ ¼ä¸­çš„éšœç¢ç‰©å’Œç©ºä½ç½®åˆ†åˆ«ç”¨ 1 å’Œ 0 æ¥è¡¨ç¤ºã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: dp[i][j]è¡¨ç¤ºåˆ°è¾¾[i, j]ä½ç½®æ—¶çš„è·¯å¾„æ•°ï¼Œå½“ç½‘æ ¼ä¸º1æ—¶ï¼Œåˆ°è¾¾è¯¥ç½‘æ ¼çš„è·¯å¾„æ•°ä¸º0ï¼Œå¦åˆ™ä¸ºdp[i][j] = dp[i-1][j] + dp[i][j-1]
    
    # 
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        if obstacleGrid[0][0] == 1:
            return 0
        m = len(obstacleGrid)
        n = len(obstacleGrid[0])
        dp = [[0 for _ in range(n)] for _ in range(m)]
        dp[0][0] = 1
        for i in range(m):
            for j in range(n):
                if obstacleGrid[i][j] == 1:
                    dp[i][j] = 0
                elif i == 0 and j == 0:
                    dp[i][j] = 1
                elif i == 0:
                    dp[i][j] = dp[i][j-1]
                elif j == 0:
                    dp[i][j] = dp[i-1][j]
                else:
                    dp[i][j] = dp[i-1][j] + dp[i][j-1]
        return dp[m-1][n-1]
                 
#### 2. éé€’å½’
æ€è·¯ï¼š
    
## 64. æœ€å°è·¯å¾„å’Œ
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªåŒ…å«éè´Ÿæ•´æ•°çš„ m x n ç½‘æ ¼ grid ï¼Œè¯·æ‰¾å‡ºä¸€æ¡ä»å·¦ä¸Šè§’åˆ°å³ä¸‹è§’çš„è·¯å¾„ï¼Œä½¿å¾—è·¯å¾„ä¸Šçš„æ•°å­—æ€»å’Œä¸ºæœ€å°ã€‚
è¯´æ˜ï¼šæ¯æ¬¡åªèƒ½å‘ä¸‹æˆ–è€…å‘å³ç§»åŠ¨ä¸€æ­¥ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: dp[i][j]è¡¨ç¤ºåˆ°è¾¾[i, j]ä½ç½®æ—¶çš„æœ€å°è·¯å¾„å’Œï¼Œdp[i][j] = min(dp[i-1][j] + dp[i][j-1]) + grid[i][j]
    
    # 
    def minPathSum(self, grid: List[List[int]]) -> int:

        # i>j and j>0 dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
        # dp[i][j] è¡¨ç¤ºåˆ°è¾¾[i][j]ä½ç½®çš„æœ€å°è·¯å¾„å’Œ
        m = len(grid)
        n = len(grid[0])
        dp = [[0 for _ in range(n)] for _ in range(m)]
        dp[0][0] = grid[0][0]

        for i in range(m):
            for j in range(n):
                if i == 0 and j == 0:
                    dp[i][j] = grid[i][j]
                elif i == 0:
                    dp[i][j] = dp[i][j-1] + grid[i][j]
                elif j == 0:
                    dp[i][j] = dp[i-1][j] + grid[i][j]
                else:
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
        return dp[m-1][n-1]
                 
#### 2. éé€’å½’
æ€è·¯ï¼š

## 91. è§£ç æ–¹æ³•
é¢˜ç›®ï¼šä¸€æ¡åŒ…å«å­—æ¯Â A-Z çš„æ¶ˆæ¯é€šè¿‡ä»¥ä¸‹æ˜ å°„è¿›è¡Œäº† ç¼–ç  ï¼š
'A' -> 1
'B' -> 2
...
'Z' -> 26
è¦ è§£ç  å·²ç¼–ç çš„æ¶ˆæ¯ï¼Œæ‰€æœ‰æ•°å­—å¿…é¡»åŸºäºä¸Šè¿°æ˜ å°„çš„æ–¹æ³•ï¼Œåå‘æ˜ å°„å›å­—æ¯ï¼ˆå¯èƒ½æœ‰å¤šç§æ–¹æ³•ï¼‰ã€‚ä¾‹å¦‚ï¼Œ"11106" å¯ä»¥æ˜ å°„ä¸ºï¼š
"AAJF" ï¼Œå°†æ¶ˆæ¯åˆ†ç»„ä¸º (1 1 10 6)
"KJF" ï¼Œå°†æ¶ˆæ¯åˆ†ç»„ä¸º (11 10 6)
æ³¨æ„ï¼Œæ¶ˆæ¯ä¸èƒ½åˆ†ç»„ä¸ºÂ  (1 11 06) ï¼Œå› ä¸º "06" ä¸èƒ½æ˜ å°„ä¸º "F" ï¼Œè¿™æ˜¯ç”±äº "6" å’Œ "06" åœ¨æ˜ å°„ä¸­å¹¶ä¸ç­‰ä»·ã€‚
ç»™ä½ ä¸€ä¸ªåªå«æ•°å­—çš„ éç©º å­—ç¬¦ä¸² s ï¼Œè¯·è®¡ç®—å¹¶è¿”å› è§£ç  æ–¹æ³•çš„ æ€»æ•° ã€‚
é¢˜ç›®æ•°æ®ä¿è¯ç­”æ¡ˆè‚¯å®šæ˜¯ä¸€ä¸ª 32 ä½ çš„æ•´æ•°ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: dp[i]
    
    # 
    def numDecodings(self, s: str) -> int:
        if not s:
            return 0
        elif s[0] == '0':
            return 0
        m = len(s)
        dp = [0] * (m+1)
        dp[0] = 1
        dp[1] = 1
        for i in range(2, m+1):
            if s[i-1] == '0' and s[i-2] not in '12':
                return 0
            if s[i-2:i] in ['10', '20']:
                dp[i] = dp[i-2]
            elif '10' <= s[i-2:i] <= '26':
                dp[i] = dp[i-1] + dp[i-2]
            else:
                dp[i] = dp[i-1]
            
        print(dp)
        return dp[-1]
                 
#### 2. éé€’å½’
æ€è·¯ï¼š
    
## 97. äº¤é”™å­—ç¬¦ä¸²
é¢˜ç›®ï¼šç»™å®šä¸‰ä¸ªå­—ç¬¦ä¸²Â s1ã€s2ã€s3ï¼Œè¯·ä½ å¸®å¿™éªŒè¯Â s3Â æ˜¯å¦æ˜¯ç”±Â s1Â å’ŒÂ s2 äº¤é”™ ç»„æˆçš„ã€‚
ä¸¤ä¸ªå­—ç¬¦ä¸² s å’Œ t äº¤é”™ çš„å®šä¹‰ä¸è¿‡ç¨‹å¦‚ä¸‹ï¼Œå…¶ä¸­æ¯ä¸ªå­—ç¬¦ä¸²éƒ½ä¼šè¢«åˆ†å‰²æˆè‹¥å¹² éç©º å­å­—ç¬¦ä¸²ï¼š
s = s1 + s2 + ... + sn
t = t1 + t2 + ... + tm
|n - m| <= 1
äº¤é”™ æ˜¯ s1 + t1 + s2 + t2 + s3 + t3 + ... æˆ–è€… t1 + s1 + t2 + s2 + t3 + s3 + ...
æç¤ºï¼ša + b æ„å‘³ç€å­—ç¬¦ä¸² a å’Œ b è¿æ¥ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: dp[i][j]è¡¨ç¤ºs1çš„å‰iä¸ªå…ƒç´ å’Œs2çš„å‰jä¸ªå…ƒç´ æ˜¯å¦èƒ½æ„æˆs3å‰i+jå…ƒç´ ã€‚
    
    # 
    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:

        # dp[i][j]: s1çš„å‰iä¸ªå…ƒç´ å’Œs2çš„å‰jä¸ªå…ƒç´ æ˜¯å¦èƒ½æ„æˆs3å‰i+jå…ƒç´ 

        l1 = len(s1)
        l2 = len(s2)
        l3 = len(s3)
        if l1 + l2 != l3:
            return False

        dp = [[False for _ in range(l2+1)] for _ in range(l1+1)]
        dp[0][0] = True
        
        # print(dp)
        for i in range(l1 + 1):
            for j in range(l2 + 1):
                if i == 0 and j == 0:
                    dp[i][j] = True
                elif i == 0:
                    dp[i][j] = dp[i][j-1] and s2[j-1] == s3[i+j-1]
                elif j == 0:
                    dp[i][j] = dp[i-1][j] and s1[i-1] == s3[i+j-1]
                else:
                    dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i+j-1]) or (dp[i][j-1] and s2[j-1] == s3[i+j-1])
        # print(dp)
        return dp[-1][-1]
                 
#### 2. éé€’å½’
æ€è·¯ï¼š

## 120. ä¸‰è§’å½¢æœ€å°è·¯å¾„å’Œ
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªä¸‰è§’å½¢ triangle ï¼Œæ‰¾å‡ºè‡ªé¡¶å‘ä¸‹çš„æœ€å°è·¯å¾„å’Œã€‚
æ¯ä¸€æ­¥åªèƒ½ç§»åŠ¨åˆ°ä¸‹ä¸€è¡Œä¸­ç›¸é‚»çš„ç»“ç‚¹ä¸Šã€‚ç›¸é‚»çš„ç»“ç‚¹ åœ¨è¿™é‡ŒæŒ‡çš„æ˜¯ ä¸‹æ ‡ ä¸ ä¸Šä¸€å±‚ç»“ç‚¹ä¸‹æ ‡ ç›¸åŒæˆ–è€…ç­‰äº ä¸Šä¸€å±‚ç»“ç‚¹ä¸‹æ ‡ + 1 çš„ä¸¤ä¸ªç»“ç‚¹ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœæ­£ä½äºå½“å‰è¡Œçš„ä¸‹æ ‡ i ï¼Œé‚£ä¹ˆä¸‹ä¸€æ­¥å¯ä»¥ç§»åŠ¨åˆ°ä¸‹ä¸€è¡Œçš„ä¸‹æ ‡ i æˆ– i + 1 ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: dp[i][j] è¡¨ç¤ºä½ç½®[i][j]çš„æœ€å°è·¯å¾„å’Œ,dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]
    
    # 
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        m = len(triangle)
        n = len(triangle[-1])
        # dp[i][j] è¡¨ç¤ºä½ç½®[i][j]çš„æœ€å°è·¯å¾„å’Œ
        # dp[i][j] = min(dp[i][j-1], dp[i-1][j-1]) + triangle[i][j]

        dp = [[math.inf for _ in range(n)] for _ in range(m)]
        dp[0][0] = triangle[0][0]
        
        for i in range(m):
            for j in range(i+1):
                if i == 0 and j == 0:
                    dp[i][j] = triangle[0][0]
                elif i == 0:
                    dp[i][j] = triangle[0][0]
                elif j == 0:
                    dp[i][j] = dp[i-1][j] + triangle[i][j]
                else:
                    dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]
        # print(dp)
        return min(dp[-1])
                 
#### 2. éé€’å½’
æ€è·¯ï¼š

## 122. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº II
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªæ•°ç»„ prices ï¼Œå…¶ä¸­Â prices[i] æ˜¯ä¸€æ”¯ç»™å®šè‚¡ç¥¨ç¬¬ i å¤©çš„ä»·æ ¼ã€‚
è®¾è®¡ä¸€ä¸ªç®—æ³•æ¥è®¡ç®—ä½ æ‰€èƒ½è·å–çš„æœ€å¤§åˆ©æ¶¦ã€‚ä½ å¯ä»¥å°½å¯èƒ½åœ°å®Œæˆæ›´å¤šçš„äº¤æ˜“ï¼ˆå¤šæ¬¡ä¹°å–ä¸€æ”¯è‚¡ç¥¨ï¼‰ã€‚
æ³¨æ„ï¼šä½ ä¸èƒ½åŒæ—¶å‚ä¸å¤šç¬”äº¤æ˜“ï¼ˆä½ å¿…é¡»åœ¨å†æ¬¡è´­ä¹°å‰å‡ºå”®æ‰ä¹‹å‰çš„è‚¡ç¥¨ï¼‰ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: dp[i][j]: ç¬¬iå¤©çš„äº¤æ˜“çŠ¶æ€çš„æ”¶ç›Šï¼Œdp[i][0]æ‰‹ä¸­æœ‰è‚¡ç¥¨è·å–çš„æœ€å¤§æ”¶ç›Š,dp[i][1]æ‰‹ä¸­æ²¡è‚¡ç¥¨è·å–çš„æœ€å¤§æ”¶ç›Š
    
    # 
    def maxProfit(self, prices: List[int]) -> int:

        # dp[i][j]: ç¬¬iå¤©çš„äº¤æ˜“çŠ¶æ€çš„æ”¶ç›Šï¼Œdp[i][0]æ‰‹ä¸­æœ‰è‚¡ç¥¨è·å–çš„æœ€å¤§æ”¶ç›Š,dp[i][1]æ‰‹ä¸­æ²¡è‚¡ç¥¨è·å–çš„æœ€å¤§æ”¶ç›Š
        n = len(prices)
        dp = [[0 for _ in range(2)] for _ in range(n)]
        dp[0][0] = -prices[0]
        dp[0][1] = 0
        for i in range(n):
            if i == 0:
                dp[i][0] = -prices[i]
                dp[i][1] = 0
            else:
                dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i])
                dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])
        # print(dp)
        return dp[-1][1]
                 
#### 2. éé€’å½’
æ€è·¯ï¼š
    
## 139. å•è¯æ‹†åˆ†
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªéç©ºå­—ç¬¦ä¸² s å’Œä¸€ä¸ªåŒ…å«éç©ºå•è¯çš„åˆ—è¡¨ wordDictï¼Œåˆ¤å®šÂ s æ˜¯å¦å¯ä»¥è¢«ç©ºæ ¼æ‹†åˆ†ä¸ºä¸€ä¸ªæˆ–å¤šä¸ªåœ¨å­—å…¸ä¸­å‡ºç°çš„å•è¯ã€‚
è¯´æ˜ï¼š
æ‹†åˆ†æ—¶å¯ä»¥é‡å¤ä½¿ç”¨å­—å…¸ä¸­çš„å•è¯ã€‚
ä½ å¯ä»¥å‡è®¾å­—å…¸ä¸­æ²¡æœ‰é‡å¤çš„å•è¯ã€‚
    
ç¤ºä¾‹ 1ï¼š
è¾“å…¥: s = "leetcode", wordDict = ["leet", "code"]
è¾“å‡º: true
è§£é‡Š: è¿”å› true å› ä¸º "leetcode" å¯ä»¥è¢«æ‹†åˆ†æˆ "leet code"ã€‚
ç¤ºä¾‹ 2ï¼š
è¾“å…¥: s = "applepenapple", wordDict = ["apple", "pen"]
è¾“å‡º: true
è§£é‡Š: è¿”å› true å› ä¸º "applepenapple" å¯ä»¥è¢«æ‹†åˆ†æˆ "apple pen apple"ã€‚
Â     æ³¨æ„ä½ å¯ä»¥é‡å¤ä½¿ç”¨å­—å…¸ä¸­çš„å•è¯ã€‚
ç¤ºä¾‹ 3ï¼š
è¾“å…¥: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
è¾“å‡º: false
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: dp[i]: sçš„å‰iä¸ªå­—ç¬¦æ˜¯å¦èƒ½ç”¨wordDictå­—å…¸è¡¨ç¤º, ä»sèµ·ç‚¹â€œâ€å‡ºå‘,æŒ‰ç…§ wordDictè§„åˆ™è¿›è¡Œè·³è·ƒï¼Œèƒ½å¦è·³åˆ°ç»ˆç‚¹
    
    # 
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        n = len(s)
        # dp[i]: sçš„å‰iä¸ªå­—ç¬¦æ˜¯å¦èƒ½ç”¨wordDictå­—å…¸è¡¨ç¤º 
        # ä»sèµ·ç‚¹â€œâ€å‡ºå‘,æŒ‰ç…§ wordDictè§„åˆ™è¿›è¡Œè·³è·ƒï¼Œèƒ½å¦è·³åˆ°ç»ˆç‚¹
        # é¢˜è§£ï¼šhttps://leetcode-cn.com/problems/word-break/solution/python3-dong-tai-gui-hua-by-irruma/
        
        dp = [False] * (n+1)
        dp[0] = True
        for i in range(n):
            if dp[i]:  # æ¯æ¬¡ä»è·³åˆ°çš„ä½ç½®ç»§ç»­åˆ¤æ–­
                for j in range(i+1, n+1):
                    if s[i:j] in wordDict:
                        dp[j] = True
        # print(dp)
        return dp[-1]
                 
#### 2. éé€’å½’
æ€è·¯ï¼š
    
## 152. ä¹˜ç§¯æœ€å¤§å­æ•°ç»„
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œè¯·ä½ æ‰¾å‡ºæ•°ç»„ä¸­ä¹˜ç§¯æœ€å¤§çš„è¿ç»­å­æ•°ç»„ï¼ˆè¯¥å­æ•°ç»„ä¸­è‡³å°‘åŒ…å«ä¸€ä¸ªæ•°å­—ï¼‰ï¼Œå¹¶è¿”å›è¯¥å­æ•°ç»„æ‰€å¯¹åº”çš„ä¹˜ç§¯ã€‚
    
ç¤ºä¾‹ 1:
è¾“å…¥: [2,3,-2,4]
è¾“å‡º: 6
è§£é‡Š:Â å­æ•°ç»„ [2,3] æœ‰æœ€å¤§ä¹˜ç§¯ 6ã€‚
ç¤ºä¾‹ 2:
è¾“å…¥: [-2,0,-1]
è¾“å‡º: 0
è§£é‡Š:Â ç»“æœä¸èƒ½ä¸º 2, å› ä¸º [-2,-1] ä¸æ˜¯å­æ•°ç»„ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: dp[i]: è¡¨ç¤ºiä½ç½®å¤„çš„æœ€å¤§çŠ¶æ€(dp[i][0]æœ€å¤§å€¼ï¼Œdp[i][1]æœ€å°å€¼)ï¼Œç„¶åéå†æ¯ä¸ªä½ç½®å¤„çš„æœ€å¤§çŠ¶æ€ï¼Œæ‰¾åˆ°æœ€å¤§å€¼å³å¯ã€‚
    
    # 
    def maxProduct(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [[0 for _ in range(2)] for _ in range(n)]

        res = -math.inf
        for i in range(n):
            if i == 0:
                dp[i][0] = nums[i]  # å­˜å‚¨å½“å‰ä½ç½®æœ€å¤§å€¼
                dp[i][1] = nums[i]  # å­˜å‚¨å½“å‰ä½ç½®æœ€å°å€¼
            else:
                dp[i][0] = max(dp[i-1][0]*nums[i], dp[i-1][1]*nums[i], nums[i])
                dp[i][1] = min(dp[i-1][0]*nums[i], dp[i-1][1]*nums[i], nums[i])
            res = max(res, dp[i][0])
        # print(dp)
        return res
                 
#### 2. éé€’å½’
æ€è·¯ï¼š
    
## 198. æ‰“å®¶åŠ«èˆ
é¢˜ç›®ï¼šä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å°å·ï¼Œè®¡åˆ’å·çªƒæ²¿è¡—çš„æˆ¿å±‹ã€‚æ¯é—´æˆ¿å†…éƒ½è—æœ‰ä¸€å®šçš„ç°é‡‘ï¼Œå½±å“ä½ å·çªƒçš„å”¯ä¸€åˆ¶çº¦å› ç´ å°±æ˜¯ç›¸é‚»çš„æˆ¿å±‹è£…æœ‰ç›¸äº’è¿é€šçš„é˜²ç›—ç³»ç»Ÿï¼Œå¦‚æœä¸¤é—´ç›¸é‚»çš„æˆ¿å±‹åœ¨åŒä¸€æ™šä¸Šè¢«å°å·é—¯å…¥ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨æŠ¥è­¦ã€‚
ç»™å®šä¸€ä¸ªä»£è¡¨æ¯ä¸ªæˆ¿å±‹å­˜æ”¾é‡‘é¢çš„éè´Ÿæ•´æ•°æ•°ç»„ï¼Œè®¡ç®—ä½  ä¸è§¦åŠ¨è­¦æŠ¥è£…ç½®çš„æƒ…å†µä¸‹ ï¼Œä¸€å¤œä¹‹å†…èƒ½å¤Ÿå·çªƒåˆ°çš„æœ€é«˜é‡‘é¢ã€‚
ç¤ºä¾‹ 1ï¼š
è¾“å…¥ï¼š[1,2,3,1]
è¾“å‡ºï¼š4
è§£é‡Šï¼šå·çªƒ 1 å·æˆ¿å±‹ (é‡‘é¢ = 1) ï¼Œç„¶åå·çªƒ 3 å·æˆ¿å±‹ (é‡‘é¢ = 3)ã€‚
Â     å·çªƒåˆ°çš„æœ€é«˜é‡‘é¢ = 1 + 3 = 4 ã€‚
ç¤ºä¾‹ 2ï¼š
è¾“å…¥ï¼š[2,7,9,3,1]
è¾“å‡ºï¼š12
è§£é‡Šï¼šå·çªƒ 1 å·æˆ¿å±‹ (é‡‘é¢ = 2), å·çªƒ 3 å·æˆ¿å±‹ (é‡‘é¢ = 9)ï¼Œæ¥ç€å·çªƒ 5 å·æˆ¿å±‹ (é‡‘é¢ = 1)ã€‚
Â     å·çªƒåˆ°çš„æœ€é«˜é‡‘é¢ = 2 + 9 + 1 = 12 ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: dp[i]: ç¬¬iä¸ªæˆ¿é—´è·å¾—çš„æœ€å¤§é‡‘é¢,dp[i][0]->å·è·å¾—çš„æœ€å¤§åˆ©æ¶¦ï¼Œdp[i][1]->ä¸å·è·å¾—çš„æœ€å¤§åˆ©æ¶¦
    
    # 
    def rob(self, nums: List[int]) -> int:

        # dp[i]: ç¬¬iä¸ªæˆ¿é—´è·å¾—çš„æœ€å¤§é‡‘é¢,dp[i][0]->å·è·å¾—çš„æœ€å¤§åˆ©æ¶¦ï¼Œdp[i][1]->ä¸å·è·å¾—çš„æœ€å¤§åˆ©æ¶¦
        n = len(nums)
        dp = [[0 for _ in range(2)] for _ in range(n)]

        for i in range(n):
            if i == 0:
                dp[i][0] = nums[i]
                dp[i][1] = 0
            else:
                dp[i][0] = dp[i-1][1] + nums[i]
                dp[i][1] = max(dp[i-1][0], dp[i-1][1])
        print(dp)
        return max(dp[-1])
                 
#### 2. éé€’å½’
æ€è·¯ï¼š
    
## 213. æ‰“å®¶åŠ«èˆ II
é¢˜ç›®ï¼šä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å°å·ï¼Œè®¡åˆ’å·çªƒæ²¿è¡—çš„æˆ¿å±‹ï¼Œæ¯é—´æˆ¿å†…éƒ½è—æœ‰ä¸€å®šçš„ç°é‡‘ã€‚è¿™ä¸ªåœ°æ–¹æ‰€æœ‰çš„æˆ¿å±‹éƒ½ å›´æˆä¸€åœˆ ï¼Œè¿™æ„å‘³ç€ç¬¬ä¸€ä¸ªæˆ¿å±‹å’Œæœ€åä¸€ä¸ªæˆ¿å±‹æ˜¯ç´§æŒ¨ç€çš„ã€‚åŒæ—¶ï¼Œç›¸é‚»çš„æˆ¿å±‹è£…æœ‰ç›¸äº’è¿é€šçš„é˜²ç›—ç³»ç»Ÿï¼Œå¦‚æœä¸¤é—´ç›¸é‚»çš„æˆ¿å±‹åœ¨åŒä¸€æ™šä¸Šè¢«å°å·é—¯å…¥ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨æŠ¥è­¦ ã€‚
ç»™å®šä¸€ä¸ªä»£è¡¨æ¯ä¸ªæˆ¿å±‹å­˜æ”¾é‡‘é¢çš„éè´Ÿæ•´æ•°æ•°ç»„ï¼Œè®¡ç®—ä½  åœ¨ä¸è§¦åŠ¨è­¦æŠ¥è£…ç½®çš„æƒ…å†µä¸‹ ï¼Œä»Šæ™šèƒ½å¤Ÿå·çªƒåˆ°çš„æœ€é«˜é‡‘é¢ã€‚
ç¤ºä¾‹Â 1ï¼š
è¾“å…¥ï¼šnums = [2,3,2]
è¾“å‡ºï¼š3
è§£é‡Šï¼šä½ ä¸èƒ½å…ˆå·çªƒ 1 å·æˆ¿å±‹ï¼ˆé‡‘é¢ = 2ï¼‰ï¼Œç„¶åå·çªƒ 3 å·æˆ¿å±‹ï¼ˆé‡‘é¢ = 2ï¼‰, å› ä¸ºä»–ä»¬æ˜¯ç›¸é‚»çš„ã€‚
ç¤ºä¾‹ 2ï¼š
è¾“å…¥ï¼šnums = [1,2,3,1]
è¾“å‡ºï¼š4
è§£é‡Šï¼šä½ å¯ä»¥å…ˆå·çªƒ 1 å·æˆ¿å±‹ï¼ˆé‡‘é¢ = 1ï¼‰ï¼Œç„¶åå·çªƒ 3 å·æˆ¿å±‹ï¼ˆé‡‘é¢ = 3ï¼‰ã€‚
Â     å·çªƒåˆ°çš„æœ€é«˜é‡‘é¢ = 1 + 3 = 4 ã€‚
ç¤ºä¾‹ 3ï¼š
è¾“å…¥ï¼šnums = [0]
è¾“å‡ºï¼š0
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: dp[i]: ç¬¬iä¸ªæˆ¿é—´è·å¾—çš„æœ€å¤§é‡‘é¢,dp[i][0]->å·è·å¾—çš„æœ€å¤§åˆ©æ¶¦ï¼Œdp[i][1]->ä¸å·è·å¾—çš„æœ€å¤§åˆ©æ¶¦,åˆ†ä¸¤ç§æƒ…å†µï¼Œç¬¬ä¸€å¤©å·æ—¶ï¼Œæœ€åä¸€å¤©ä¸èƒ½å·ï¼Œæˆ–ç¬¬ä¸€å¤©ä¸å·æ—¶ï¼Œæœ€åä¸€å¤©å¯ä»¥å·ã€‚
    
    # 
    def rob(self, nums: List[int]) -> int:
        # dp[i]: ç¬¬iå¤©è·å¾—çš„æœ€å¤§åˆ©æ¶¦,dp[i][0]->å·è·å¾—çš„æœ€å¤§åˆ©æ¶¦,dp[i][1]->ä¸å·è·å¾—çš„æœ€å¤§åˆ©æ¶¦
        n  = len(nums)
        if n == 0:
            return 0
        elif n == 1:
            return nums[0]
        dp = [[0 for _ in range(2)] for _ in range(n)]
        max1, max2 = 0, 0
        for i in range(n):  # å½“ç¬¬ä¸€å®¶ä¸å·æ—¶è·å¾—çš„æœ€å¤§åˆ©æ¶¦
            if i == 0:
                dp[i][0] = 0
                dp[i][1] = 0
            else:
                dp[i][0] = dp[i-1][1] + nums[i]
                dp[i][1] = max(dp[i-1])
        max1 = max(dp[-1])
        for i in range(n-1):  # å½“ç¬¬ä¸€å®¶å·æ—¶è·å¾—çš„æœ€å¤§åˆ©æ¶¦, æœ€åä¸€å®¶ä¸èƒ½å·
            if i == 0:
                dp[i][0] = nums[i]
                dp[i][1] = 0
            else:
                dp[i][0] = dp[i-1][1] + nums[i]
                dp[i][1] = max(dp[i-1])
        max2 = max(dp[-2])
        return max(max1, max2)
                 
#### 2. éé€’å½’
æ€è·¯ï¼š

## 221. æœ€å¤§æ­£æ–¹å½¢
é¢˜ç›®ï¼šåœ¨ä¸€ä¸ªç”± '0' å’Œ '1' ç»„æˆçš„äºŒç»´çŸ©é˜µå†…ï¼Œæ‰¾åˆ°åªåŒ…å« '1' çš„æœ€å¤§æ­£æ–¹å½¢ï¼Œå¹¶è¿”å›å…¶é¢ç§¯ã€‚
ç¤ºä¾‹Â 1ï¼š
è¾“å…¥ï¼šmatrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
è¾“å‡ºï¼š4
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: dp[i][j]: è¡¨ç¤ºä»¥[i,j]ä½ç½®ä¸ºå³ä¸‹è§’çš„æ­£æ–¹å½¢çš„æœ€å°è¾¹é•¿ï¼Œè‹¥è¯¥ä½ç½®ä¸º0,åˆ™æœ€å°è¾¹é•¿ä¸º0,å³dp[i][j]=0ï¼›è‹¥ä¸º1åˆ™æœ€å°è¾¹é•¿ä¸ºå·¦è¾¹ï¼Œä¸Šè¾¹ï¼Œå·¦ä¸Šè§’çš„æœ€å°è¾¹çš„æœ€å°å€¼ï¼Œå³ dp[i][j] = min(dp[i-1][j],dp[i[j-1], dp[i-1][j-1]) + 1
    
    # 
    def maximalSquare(self, matrix: List[List[str]]) -> int:

        # dp[i][j]: è¡¨ç¤ºä»¥[i,j]ä½ç½®ä¸ºå³ä¸‹è§’çš„æ­£æ–¹å½¢çš„æœ€å°è¾¹é•¿ï¼Œè‹¥è¯¥ä½ç½®ä¸º0,åˆ™æœ€å°è¾¹é•¿ä¸º0,å³dp[i][j]=0ï¼›è‹¥ä¸º1åˆ™æœ€å°è¾¹é•¿ä¸ºå·¦è¾¹ï¼Œä¸Šè¾¹ï¼Œå·¦ä¸Šè§’çš„æœ€å°è¾¹çš„æœ€å°å€¼ï¼Œå³ dp[i][j] = min(dp[i-1][j],dp[i[j-1], dp[i-1][j-1]) + 1
        m = len(matrix)
        n = len(matrix[0])
        dp = [[0 for _ in range(n)] for _ in range(m)]

        maxL = 0
        for i in range(m):
            for j in range(n):
                if i == 0 and j == 0:
                    if matrix[i][j] == '1':
                        dp[i][j] = 1
                    else:
                        dp[i][j] = 0
                elif i == 0:
                    if matrix[i][j] == '1':
                        dp[i][j] = 1
                    else:
                        dp[i][j] = 0
                elif j == 0:
                    if matrix[i][j] == '1':
                        dp[i][j] = 1
                    else:
                        dp[i][j] = 0
                else:
                    if matrix[i][j] == '1':
                        dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
                    else:
                        dp[i][j] = 0
                    
                maxL = max(maxL, dp[i][j])
        # print(dp)
        return maxL * maxL
                 
#### 2. éé€’å½’
æ€è·¯ï¼š
    
## 241. ä¸ºè¿ç®—è¡¨è¾¾å¼è®¾è®¡ä¼˜å…ˆçº§
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªå«æœ‰æ•°å­—å’Œè¿ç®—ç¬¦çš„å­—ç¬¦ä¸²ï¼Œä¸ºè¡¨è¾¾å¼æ·»åŠ æ‹¬å·ï¼Œæ”¹å˜å…¶è¿ç®—ä¼˜å…ˆçº§ä»¥æ±‚å‡ºä¸åŒçš„ç»“æœã€‚ä½ éœ€è¦ç»™å‡ºæ‰€æœ‰å¯èƒ½çš„ç»„åˆçš„ç»“æœã€‚æœ‰æ•ˆçš„è¿ç®—ç¬¦å·åŒ…å« +,Â -Â ä»¥åŠÂ *Â ã€‚

ç¤ºä¾‹Â 1:
è¾“å…¥: "2-1-1"
è¾“å‡º: [0, 2]
è§£é‡Š: 
((2-1)-1) = 0 
(2-(1-1)) = 2
ç¤ºä¾‹Â 2:
è¾“å…¥: "2*3-4*5"
è¾“å‡º: [-34, -14, -10, -10, 10]
è§£é‡Š: 
(2*(3-(4*5))) = -34 
((2*3)-(4*5)) = -14 
((2*(3-4))*5) = -10 
(2*((3-4)*5)) = -10 
(((2*3)-4)*5) = 10
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: åˆ†æ²»ç®—æ³•ã€‚
    
    # 
    def diffWaysToCompute(self, expression: str) -> List[int]:
        if expression.isdigit():
            return [int(expression)]

        res = []
        # åˆ†æ²»ç®—æ³•: 
        for i, dig in enumerate(expression):
            if dig in ['+', '-', '*']:
                lefts = self.diffWaysToCompute(expression[0:i])
                rights = self.diffWaysToCompute(expression[i+1:])
                for l in lefts:
                    for r in rights:
                        if dig == '+':
                            res.append(l+r)
                        elif dig == '-':
                            res.append(l-r)
                        elif dig == '*':
                            res.append(l*r)
        return res
                 
#### 2. éé€’å½’
æ€è·¯ï¼š

## 264. ä¸‘æ•° II
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªæ•´æ•° n ï¼Œè¯·ä½ æ‰¾å‡ºå¹¶è¿”å›ç¬¬ n ä¸ª ä¸‘æ•° ã€‚
ä¸‘æ•° å°±æ˜¯åªåŒ…å«è´¨å› æ•° 2ã€3 å’Œ/æˆ– 5 çš„æ­£æ•´æ•°ã€‚
    
ç¤ºä¾‹ 1ï¼š
è¾“å…¥ï¼šn = 10
è¾“å‡ºï¼š12
è§£é‡Šï¼š[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] æ˜¯ç”±å‰ 10 ä¸ªä¸‘æ•°ç»„æˆçš„åºåˆ—ã€‚
ç¤ºä¾‹ 2ï¼š
è¾“å…¥ï¼šn = 1
è¾“å‡ºï¼š1
è§£é‡Šï¼š1 é€šå¸¸è¢«è§†ä¸ºä¸‘æ•°ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: dp[i]: ç¬¬iä¸ªä¸‘æ•°, dp[i] = min(2 * dp[index1], 3 * dp[index2], 5 * dp[index3])
    
    # 
    def nthUglyNumber(self, n: int) -> int:

        # dp[i]: ç¬¬iä¸ªä¸‘æ•°
        dp = [1] * n
        index1, index2, index3 = 0, 0, 0
        for i in range(n):
            if i == 0:
                dp[i] = 1
            else:
                dp[i] = min(2 * dp[index1], 3 * dp[index2], 5 * dp[index3])
                if 2 * dp[index1] == dp[i]:
                    index1 += 1
                if 3 * dp[index2] == dp[i]:
                    index2 += 1
                if 5 * dp[index3] == dp[i]:
                    index3 += 1
        print(dp)
        return dp[-1]
                 
#### 2. éé€’å½’
æ€è·¯ï¼š
    
## 279. å®Œå…¨å¹³æ–¹æ•°
é¢˜ç›®ï¼šç»™å®šæ­£æ•´æ•°Â nï¼Œæ‰¾åˆ°è‹¥å¹²ä¸ªå®Œå…¨å¹³æ–¹æ•°ï¼ˆæ¯”å¦‚Â 1, 4, 9, 16, ...ï¼‰ä½¿å¾—å®ƒä»¬çš„å’Œç­‰äº nã€‚ä½ éœ€è¦è®©ç»„æˆå’Œçš„å®Œå…¨å¹³æ–¹æ•°çš„ä¸ªæ•°æœ€å°‘ã€‚
ç»™ä½ ä¸€ä¸ªæ•´æ•° n ï¼Œè¿”å›å’Œä¸º n çš„å®Œå…¨å¹³æ–¹æ•°çš„ æœ€å°‘æ•°é‡ ã€‚
å®Œå…¨å¹³æ–¹æ•° æ˜¯ä¸€ä¸ªæ•´æ•°ï¼Œå…¶å€¼ç­‰äºå¦ä¸€ä¸ªæ•´æ•°çš„å¹³æ–¹ï¼›æ¢å¥è¯è¯´ï¼Œå…¶å€¼ç­‰äºä¸€ä¸ªæ•´æ•°è‡ªä¹˜çš„ç§¯ã€‚ä¾‹å¦‚ï¼Œ1ã€4ã€9 å’Œ 16 éƒ½æ˜¯å®Œå…¨å¹³æ–¹æ•°ï¼Œè€Œ 3 å’Œ 11 ä¸æ˜¯ã€‚
    
ç¤ºä¾‹ 1ï¼š
è¾“å…¥ï¼šn = 12
è¾“å‡ºï¼š3 
è§£é‡Šï¼š12 = 4 + 4 + 4
ç¤ºä¾‹ 2ï¼š
è¾“å…¥ï¼šn = 13
è¾“å‡ºï¼š2
è§£é‡Šï¼š13 = 4 + 9
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: dp[i]: è¡¨ç¤ºæ•°iæœ€å°‘å¯ä»¥ç”±å¤šå°‘ä¸ªå®Œå…¨å¹³æ–¹æ•°æ„æˆ
    
    # 
    def numSquares(self, n: int) -> int:

        # dp[i]: è¡¨ç¤ºæ•°iæœ€å°‘å¯ä»¥ç”±å¤šå°‘ä¸ªå®Œå…¨å¹³æ–¹æ•°æ„æˆ
        # dp[i] = min(dp[i], d[i - j*j] + 1)

        dp = [i for i in range(n+1)]

        for i in range(2, n+1):
            for j in range(1, int(i ** (0.5))  + 1):
                dp[i] = min(dp[i], dp[i - j * j] + 1)
        print(dp)
        return dp[-1] 
                 
#### 2. éé€’å½’
æ€è·¯ï¼š
    
## 300. æœ€é•¿é€’å¢å­åºåˆ—
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œæ‰¾åˆ°å…¶ä¸­æœ€é•¿ä¸¥æ ¼é€’å¢å­åºåˆ—çš„é•¿åº¦ã€‚
å­åºåˆ—æ˜¯ç”±æ•°ç»„æ´¾ç”Ÿè€Œæ¥çš„åºåˆ—ï¼Œåˆ é™¤ï¼ˆæˆ–ä¸åˆ é™¤ï¼‰æ•°ç»„ä¸­çš„å…ƒç´ è€Œä¸æ”¹å˜å…¶ä½™å…ƒç´ çš„é¡ºåºã€‚ä¾‹å¦‚ï¼Œ[3,6,2,7] æ˜¯æ•°ç»„ [0,3,1,6,2,2,7] çš„å­åºåˆ—ã€‚

ç¤ºä¾‹ 1ï¼š
è¾“å…¥ï¼šnums = [10,9,2,5,3,7,101,18]
è¾“å‡ºï¼š4
è§£é‡Šï¼šæœ€é•¿é€’å¢å­åºåˆ—æ˜¯ [2,3,7,101]ï¼Œå› æ­¤é•¿åº¦ä¸º 4 ã€‚
ç¤ºä¾‹ 2ï¼š
è¾“å…¥ï¼šnums = [0,1,0,3,2,3]
è¾“å‡ºï¼š4
ç¤ºä¾‹ 3ï¼š
è¾“å…¥ï¼šnums = [7,7,7,7,7,7,7]
è¾“å‡ºï¼š1
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: dp[i]:è¡¨ç¤ºä»¥[i]ä½ç½®ç»“å°¾çš„æœ€é•¿é€’å¢å­åºåˆ—
    
    # 
    def lengthOfLIS(self, nums: List[int]) -> int:

        # dp[i]:è¡¨ç¤ºä»¥[i]ä½ç½®ç»“å°¾çš„æœ€é•¿é€’å¢å­åºåˆ—
        # dp[i] = max(dp[i], d[j] + 1) , if nums[j] < nums[j] , 0 <= j < i

        n = len(nums)
        dp = [1] * n
        for i in range(n):
            for j in range(i):
                if nums[j] < nums[i]:
                    dp[i] = max(dp[i], dp[j] + 1)
        print(dp)
        return max(dp)
                 
#### 2. éé€’å½’
æ€è·¯ï¼š
    
## 309. æœ€ä½³ä¹°å–è‚¡ç¥¨æ—¶æœºå«å†·å†»æœŸ
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œå…¶ä¸­ç¬¬Â iÂ ä¸ªå…ƒç´ ä»£è¡¨äº†ç¬¬Â iÂ å¤©çš„è‚¡ç¥¨ä»·æ ¼ ã€‚â€‹
è®¾è®¡ä¸€ä¸ªç®—æ³•è®¡ç®—å‡ºæœ€å¤§åˆ©æ¶¦ã€‚åœ¨æ»¡è¶³ä»¥ä¸‹çº¦æŸæ¡ä»¶ä¸‹ï¼Œä½ å¯ä»¥å°½å¯èƒ½åœ°å®Œæˆæ›´å¤šçš„äº¤æ˜“ï¼ˆå¤šæ¬¡ä¹°å–ä¸€æ”¯è‚¡ç¥¨ï¼‰:
ä½ ä¸èƒ½åŒæ—¶å‚ä¸å¤šç¬”äº¤æ˜“ï¼ˆä½ å¿…é¡»åœ¨å†æ¬¡è´­ä¹°å‰å‡ºå”®æ‰ä¹‹å‰çš„è‚¡ç¥¨ï¼‰ã€‚
å–å‡ºè‚¡ç¥¨åï¼Œä½ æ— æ³•åœ¨ç¬¬äºŒå¤©ä¹°å…¥è‚¡ç¥¨ (å³å†·å†»æœŸä¸º 1 å¤©)ã€‚

ç¤ºä¾‹:
è¾“å…¥: [1,2,3,0,2]
è¾“å‡º: 3 
è§£é‡Š: å¯¹åº”çš„äº¤æ˜“çŠ¶æ€ä¸º: [ä¹°å…¥, å–å‡º, å†·å†»æœŸ, ä¹°å…¥, å–å‡º]
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: dp0: æ— è‚¡ç¥¨ä¸”éå†·å†»æœŸï¼Œdp1: æ— è‚¡ç¥¨ä¸”å†·å†»æœŸï¼Œdp2æœ‰è‚¡ç¥¨, dp0 = max(dp0, dp1), å½“å¤©æ— è‚¡ç¥¨ä¸”éå†·å†»æœŸï¼Œå¯èƒ½æ˜¯æ˜¨å¤©ä¹Ÿæ— è‚¡ç¥¨ä¸”éå†·å†»æœŸï¼Œæˆ–æ˜¨å¤©æ— è‚¡ç¥¨ä¸”å¤„äºå†·å†»æœŸï¼›dp1 = dp0 + prices, å½“å‰æ— è‚¡ç¥¨ä¸”å¤„äºå†·å†»æœŸï¼Œæ˜¯æ˜¨å¤©æœ‰è‚¡ç¥¨ä¸”å–æ‰äº†ï¼›dp2 = max(dp2, dp1-prices),å½“å¤©æœ‰è‚¡ç¥¨å¯èƒ½æ˜¨å¤©ä¹Ÿæœ‰è‚¡ç¥¨æˆ–æ˜¨å¤©å¤„äºéå†·å†»æœŸä»Šå¤©ä¹°å…¥
    
    # 
    def maxProfit(self, prices: List[int]) -> int:

        # dp0: æ— è‚¡ç¥¨ä¸”éå†·å†»æœŸï¼Œdp1: æ— è‚¡ç¥¨ä¸”å†·å†»æœŸï¼Œdp2æœ‰è‚¡ç¥¨
        # dp0 = max(dp0, dp1), å½“å¤©æ— è‚¡ç¥¨ä¸”éå†·å†»æœŸï¼Œå¯èƒ½æ˜¯æ˜¨å¤©ä¹Ÿæ— è‚¡ç¥¨ä¸”éå†·å†»æœŸï¼Œæˆ–æ˜¨å¤©æ— è‚¡ç¥¨ä¸”å¤„äºå†·å†»æœŸï¼›dp1 = dp0 + prices, å½“å‰æ— è‚¡ç¥¨ä¸”å¤„äºå†·å†»æœŸï¼Œæ˜¯æ˜¨å¤©æœ‰è‚¡ç¥¨ä¸”å–æ‰äº†ï¼›dp2 = max(dp2, dp1-prices),å½“å¤©æœ‰è‚¡ç¥¨å¯èƒ½æ˜¨å¤©ä¹Ÿæœ‰è‚¡ç¥¨æˆ–æ˜¨å¤©å¤„äºéå†·å†»æœŸä»Šå¤©ä¹°å…¥

        n = len(prices)
        dp0, dp1, dp2 = 0, 0, -prices[0]
        for i in range(1, n):
            new_dp0 = max(dp0, dp1)
            new_dp1 = dp2 + prices[i]
            new_dp2 = max(dp2, dp0-prices[i])
            dp0, dp1, dp2 = new_dp0, new_dp1, new_dp2
        print(dp0, dp1, dp2)
        return max(dp0, dp1)
                 
#### 2. éé€’å½’
æ€è·¯ï¼š
    
## 322. é›¶é’±å…‘æ¢
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ coins ï¼Œè¡¨ç¤ºä¸åŒé¢é¢çš„ç¡¬å¸ï¼›ä»¥åŠä¸€ä¸ªæ•´æ•° amount ï¼Œè¡¨ç¤ºæ€»é‡‘é¢ã€‚
è®¡ç®—å¹¶è¿”å›å¯ä»¥å‡‘æˆæ€»é‡‘é¢æ‰€éœ€çš„ æœ€å°‘çš„ç¡¬å¸ä¸ªæ•° ã€‚å¦‚æœæ²¡æœ‰ä»»ä½•ä¸€ç§ç¡¬å¸ç»„åˆèƒ½ç»„æˆæ€»é‡‘é¢ï¼Œè¿”å›Â -1 ã€‚
ä½ å¯ä»¥è®¤ä¸ºæ¯ç§ç¡¬å¸çš„æ•°é‡æ˜¯æ— é™çš„ã€‚

ç¤ºä¾‹Â 1ï¼š
è¾“å…¥ï¼šcoins = [1, 2, 5], amount = 11
è¾“å‡ºï¼š3 
è§£é‡Šï¼š11 = 5 + 5 + 1
ç¤ºä¾‹ 2ï¼š
è¾“å…¥ï¼šcoins = [2], amount = 3
è¾“å‡ºï¼š-1
ç¤ºä¾‹ 3ï¼š
è¾“å…¥ï¼šcoins = [1], amount = 0
è¾“å‡ºï¼š0
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: å®Œå…¨èƒŒåŒ…é—®é¢˜ï¼šdp[i] = min(dp[i], dp[i-coins[j] + 1]), å‡‘æˆiå…ƒç¡¬å¸éœ€è¦çš„æœ€å°‘ç¡¬å¸æ•°ï¼Œä¸ºå‡‘æˆi-coins[j] éœ€è¦çš„æœ€å°‘ç¡¬å¸æ•°+ä¸€æšcoins[j]ç¡¬å¸
    
    # 
    def coinChange(self, coins: List[int], amount: int) -> int:

        # å®Œå…¨èƒŒåŒ…é—®é¢˜ï¼šdp[i] = min(dp[i], dp[i-coins[j] + 1]), å‡‘æˆiå…ƒç¡¬å¸éœ€è¦çš„æœ€å°‘ç¡¬å¸æ•°ï¼Œä¸ºå‡‘æˆi-coins[j] éœ€è¦çš„æœ€å°‘ç¡¬å¸æ•°+ä¸€æšcoins[j]ç¡¬å¸
        n = len(coins)
        dp = [math.inf for _ in range(amount+1)]
        dp[0] = 0
        for i in range(1, amount+1):
            for j in range(n):
                if i - coins[j] >= 0:
                    dp[i] = min(dp[i], dp[i-coins[j]] + 1)
        print(dp)
        return dp[-1] if dp[-1] != math.inf else -1
                 
#### 2. éé€’å½’
æ€è·¯ï¼š
    
## 337. æ‰“å®¶åŠ«èˆ III
é¢˜ç›®ï¼šåœ¨ä¸Šæ¬¡æ‰“åŠ«å®Œä¸€æ¡è¡—é“ä¹‹åå’Œä¸€åœˆæˆ¿å±‹åï¼Œå°å·åˆå‘ç°äº†ä¸€ä¸ªæ–°çš„å¯è¡Œçªƒçš„åœ°åŒºã€‚è¿™ä¸ªåœ°åŒºåªæœ‰ä¸€ä¸ªå…¥å£ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºâ€œæ ¹â€ã€‚ é™¤äº†â€œæ ¹â€ä¹‹å¤–ï¼Œæ¯æ ‹æˆ¿å­æœ‰ä¸”åªæœ‰ä¸€ä¸ªâ€œçˆ¶â€œæˆ¿å­ä¸ä¹‹ç›¸è¿ã€‚ä¸€ç•ªä¾¦å¯Ÿä¹‹åï¼Œèªæ˜çš„å°å·æ„è¯†åˆ°â€œè¿™ä¸ªåœ°æ–¹çš„æ‰€æœ‰æˆ¿å±‹çš„æ’åˆ—ç±»ä¼¼äºä¸€æ£µäºŒå‰æ ‘â€ã€‚ å¦‚æœä¸¤ä¸ªç›´æ¥ç›¸è¿çš„æˆ¿å­åœ¨åŒä¸€å¤©æ™šä¸Šè¢«æ‰“åŠ«ï¼Œæˆ¿å±‹å°†è‡ªåŠ¨æŠ¥è­¦ã€‚
è®¡ç®—åœ¨ä¸è§¦åŠ¨è­¦æŠ¥çš„æƒ…å†µä¸‹ï¼Œå°å·ä¸€æ™šèƒ½å¤Ÿç›—å–çš„æœ€é«˜é‡‘é¢ã€‚

### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: åç»­éå†ï¼Œæ¯ä¸ªèŠ‚ç‚¹å¯ä»¥å·æˆ–ä¸å·ã€‚
    
    # 
    def rob(self, root: TreeNode) -> int:

        def dfs(root):
            if not root:
                return 0, 0  # å·ï¼Œä¸å·
            left = dfs(root.left)
            right = dfs(root.right)
            # å·å½“å‰èŠ‚ç‚¹ï¼Œå…¶å·¦å³ä¸¤ä¸ªå­©å­éƒ½ä¸èƒ½å·
            v1 = root.val + left[1] + right[1]
            # ä¸å·å½“å‰èŠ‚ç‚¹ï¼Œåˆ™å·¦å³ä¸¤ä¸ªå­©å­å¯ä»¥å·ï¼Œå¯ä»¥ä¸å·ï¼Œå–å­©å­æœ€å¤§å€¼
            v2 = max(left[0], left[1]) + max(right[0], right[1])
            return v1, v2

        res = dfs(root)
        return max(res[0], res[1])
                 
#### 2. éé€’å½’
æ€è·¯ï¼š
    
## 343. æ•´æ•°æ‹†åˆ†
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªæ­£æ•´æ•°Â nï¼Œå°†å…¶æ‹†åˆ†ä¸ºè‡³å°‘ä¸¤ä¸ªæ­£æ•´æ•°çš„å’Œï¼Œå¹¶ä½¿è¿™äº›æ•´æ•°çš„ä¹˜ç§¯æœ€å¤§åŒ–ã€‚ è¿”å›ä½ å¯ä»¥è·å¾—çš„æœ€å¤§ä¹˜ç§¯ã€‚

ç¤ºä¾‹ 1:
è¾“å…¥: 2
è¾“å‡º: 1
è§£é‡Š: 2 = 1 + 1, 1 Ã— 1 = 1ã€‚
ç¤ºä¾‹Â 2:
è¾“å…¥: 10
è¾“å‡º: 36
è§£é‡Š: 10 = 3 + 3 + 4, 3 Ã—Â 3 Ã—Â 4 = 36ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: æ•°å­¦ç†è®ºï¼Œè®°ä½å³å¯ã€‚
    
    # 
    def integerBreak(self, n: int) -> int:

        memo = {2: 1}

        def dfs(n):
            nonlocal memo 
            if n in memo:
                return memo[n]

            if n == 2:
                return 1

            # æ•°å­¦ç†è®ºï¼Œè®°ä½å³å¯ã€‚
            res = 0
            for i in range(1, n):
                res = max(res, max(i * dfs(n - i), i * (n - i)))
            memo[n] = res
            return res
        return dfs(n)
                 
#### 2. éé€’å½’
æ€è·¯ï¼š
