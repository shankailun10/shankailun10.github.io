# leetcodeé¢˜è§£
1. TOC
{:toc}

## 101. å¯¹ç§°äºŒå‰æ ‘
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ£€æŸ¥å®ƒæ˜¯å¦æ˜¯é•œåƒå¯¹ç§°çš„ã€‚
ä¾‹å¦‚ï¼ŒäºŒå‰æ ‘ [1,2,2,3,4,4,3] æ˜¯å¯¹ç§°çš„ã€‚ä½†æ˜¯ä¸‹é¢è¿™ä¸ª [1,2,2,null,3,null,3] åˆ™ä¸æ˜¯é•œåƒå¯¹ç§°çš„:

### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’

#### 2. éé€’å½’
æ€è·¯ï¼šåˆ¤æ–­æ ¹æ˜¯å¦ä¸ºç©ºï¼Œæ˜¯è¿”å›True, å¦åˆ¤æ–­å·¦å³ä¸¤ä¸ªå­©å­æ˜¯å¦ç›¸ç­‰ï¼Œæ˜¯ç»§ç»­åˆ¤æ–­å·¦å­©å­çš„å·¦èŠ‚ç‚¹å’Œå³å­©å­çš„å³èŠ‚ç‚¹æ˜¯å¦ç›¸ç­‰ï¼Œä»¥åŠå·¦å­©å­çš„å³èŠ‚ç‚¹å’Œå³å­©å­çš„å·¦èŠ‚ç‚¹æ˜¯å¦ç›¸ç­‰

    #é˜Ÿåˆ—ä»£ç 
    def getRes(root):
        if not root:
            return True
        queue = [(root.left, root.right)]
        while queue != []:
            left, right = queue.pop()
            if not left and not right:
                continue
            if left and right and left.val == right.val:
                queue.append((left.left, right.right))
                queue.append((left.right, right.left))
            else:
                return False
        return True
        
## 102. äºŒå‰æ ‘çš„å±‚åºéå†
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¯·ä½ è¿”å›å…¶æŒ‰ å±‚åºéå† å¾—åˆ°çš„èŠ‚ç‚¹å€¼ã€‚ ï¼ˆå³é€å±‚åœ°ï¼Œä»å·¦åˆ°å³è®¿é—®æ‰€æœ‰èŠ‚ç‚¹ï¼‰ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1ã€é€’å½’

#### 2. éé€’å½’
æ€è·¯ï¼šè‹¥æ ¹ä¸ºç©ºï¼Œè¿”å›[]ï¼Œè‹¥æ ¹ä¸ç©ºå°†æ ¹å…¥é˜Ÿåˆ—queueï¼Œç„¶åä¾æ¬¡éå†é˜Ÿåˆ—ä¸­çš„èŠ‚ç‚¹å€¼å­˜å…¥resï¼Œç„¶åä¾æ¬¡éå†é˜Ÿåˆ—ä¸­çš„èŠ‚ç‚¹ï¼ŒæŠŠè¯¥èŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹ã€å³èŠ‚ç‚¹ä¾æ¬¡å…¥å­é˜Ÿåˆ—l1ï¼Œå°†å­é˜Ÿåˆ—l1èµ‹å€¼ç»™queue,è¿”å›resã€‚

    # ä»£ç 
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        res, queue = [], [root]
        while queue:
            res.append([q.val for q in queue])
            l1 = []
            for q in queue:
                if q.left:
                    l1.append(q.left)
                if q.right:
                    l1.append(q.right)
            queue = l1
        return res
        

## 100. ç›¸åŒçš„æ ‘
é¢˜ç›®ï¼šç»™ä½ ä¸¤æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ p å’Œ q ï¼Œç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥æ£€éªŒè¿™ä¸¤æ£µæ ‘æ˜¯å¦ç›¸åŒã€‚å¦‚æœä¸¤ä¸ªæ ‘åœ¨ç»“æ„ä¸Šç›¸åŒï¼Œå¹¶ä¸”èŠ‚ç‚¹å…·æœ‰ç›¸åŒçš„å€¼ï¼Œåˆ™è®¤ä¸ºå®ƒä»¬æ˜¯ç›¸åŒçš„ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
####1. é€’å½’
æ€è·¯ï¼šæ¯”è¾ƒæ ¹èŠ‚ç‚¹æ˜¯å¦ç›¸ç­‰ï¼Œç„¶åé€’å½’æ¯”è¾ƒå·¦å­æ ‘èŠ‚ç‚¹å’Œå³å­æ ‘èŠ‚ç‚¹æ˜¯å¦ç›¸ç­‰ã€‚

    # ä»£ç 
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        if not p and not q:
            return True
        elif not p or not q:
            return False
        elif p.val != q.val:
            return False
        else:
            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)

####2. éé€’å½’
æ€è·¯ï¼šåŒæ—¶éå†ä¸¤æ£µæ ‘ï¼Œä¾æ¬¡æ¯”è¾ƒèŠ‚ç‚¹å€¼ï¼Œè‹¥å½“å‰å·¦å­æ ‘æˆ–å³å­æ ‘ä¸ºç©ºæ—¶ä¹Ÿå…¥é˜Ÿåˆ—ã€‚

## 104. äºŒå‰æ ‘æœ€å¤§æ·±åº¦
ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾å‡ºå…¶æœ€å¤§æ·±åº¦ã€‚
äºŒå‰æ ‘çš„æ·±åº¦ä¸ºæ ¹èŠ‚ç‚¹åˆ°æœ€è¿œå¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°ã€‚è¯´æ˜: å¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
####1. é€’å½’
æ€è·¯ï¼šè‹¥æ ¹ä¸ºç©ºï¼Œè¿”å›0ï¼Œè‹¥æ ¹ä¸ç©ºï¼Œåˆ™æœ€å¤§æ·±åº¦ä¸ºå·¦å­æ ‘æœ€å¤§æ·±åº¦å’Œå³å­æ ‘æœ€å¤§æ·±åº¦å–æœ€å¤§å€¼+1

    # ä»£ç 
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        l = self.maxDepth(root.left)
        r = self.maxDepth(root.right)
        return max(l, r) + 1

### 2. éé€’å½’
æ€è·¯ï¼šäºŒå‰æ ‘å±‚æ¬¡éå†ï¼Œè¿”å›æ•°ç»„é•¿åº¦ã€‚

## 108. å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œå…¶ä¸­å…ƒç´ å·²ç»æŒ‰ å‡åº æ’åˆ—ï¼Œè¯·ä½ å°†å…¶è½¬æ¢ä¸ºä¸€æ£µ é«˜åº¦å¹³è¡¡ äºŒå‰æœç´¢æ ‘ã€‚
é«˜åº¦å¹³è¡¡ äºŒå‰æ ‘æ˜¯ä¸€æ£µæ»¡è¶³ã€Œæ¯ä¸ªèŠ‚ç‚¹çš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡ 1 ã€çš„äºŒå‰æ ‘ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šå–æ•°ç»„ä¸­é—´ä½ç½®åšæ ¹ï¼Œä¸­é—´ä½ç½®çš„å·¦è¾¹éƒ¨åˆ†æ„å»ºå·¦å­æ ‘ï¼Œå³è¾¹éƒ¨åˆ†æ„å»ºå³å­æ ‘ã€‚

    # ä»£ç 
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        def mark_tree(s, e):
            if s > e:
                return None
            mid = (s + e) // 2
            sub_tree = TreeNode(nums[mid])
            sub_tree.left = mark_tree(s, mid - 1)
            sub_tree.right = mark_tree(mid + 1, e)
            return sub_tree
        return mark_tree(0, len(nums) - 1)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 110. å¹³è¡¡äºŒå‰æ ‘
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œåˆ¤æ–­å®ƒæ˜¯å¦æ˜¯é«˜åº¦å¹³è¡¡çš„äºŒå‰æ ‘ã€‚
æœ¬é¢˜ä¸­ï¼Œä¸€æ£µé«˜åº¦å¹³è¡¡äºŒå‰æ ‘å®šä¹‰ä¸ºï¼š
ä¸€ä¸ªäºŒå‰æ ‘æ¯ä¸ªèŠ‚ç‚¹ çš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡ 1 
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šè‹¥æ ¹ä¸ºç©ºï¼Œè¿”å›True,åˆ¤æ–­æ ¹çš„å·¦å³å­æ ‘é«˜åº¦å·®ç»å¯¹å€¼æ˜¯å¦<=1ï¼Œå¦ï¼šè¿”å›False,ä¾æ¬¡åˆ¤æ–­æ ¹çš„å·¦å­æ ‘ã€å³å­æ ‘æ˜¯å¦æ˜¯å¹³è¡¡æ ‘

    # ä»£ç 
    def isBalanced(self, root: TreeNode) -> bool:
        def maxDepth(node):
            if not node:
                return 0
            l = maxDepth(node.left)
            r = maxDepth(node.right)
            return max(l, r) + 1

        if not root:
            return True
        return abs(maxDepth(root.left) - maxDepth(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 111. äºŒå‰æ ‘çš„æœ€å°æ·±åº¦
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾å‡ºå…¶æœ€å°æ·±åº¦ã€‚æœ€å°æ·±åº¦æ˜¯ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿‘å¶å­èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°é‡ã€‚è¯´æ˜ï¼šå¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šå±‚åºéå†äºŒå‰æ ‘ï¼Œè®°å½•æ·±åº¦ï¼Œé‡åˆ°æŸä¸ªèŠ‚ç‚¹æ²¡æœ‰å·¦å­æ ‘æˆ–å³å­æ ‘ç›´æ¥è¿”å›æ·±åº¦å³å¯ã€‚

    # ä»£ç 
    def minDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        queue = [root]
        depth = 1
        while queue:
            l1 = []
            for q in queue:
                if not q.left and not q.right:
                    return depth
                if q.left:
                    l1.append(q.left)
                if q.right:
                    l1.append(q.right)
            queue = l1
            depth += 1
        return depth

#### 2. éé€’å½’
æ€è·¯ï¼š

## 112. è·¯å¾„æ€»å’Œ
é¢˜ç›®ï¼šç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹Â root å’Œä¸€ä¸ªè¡¨ç¤ºç›®æ ‡å’Œçš„æ•´æ•°Â targetSum ï¼Œåˆ¤æ–­è¯¥æ ‘ä¸­æ˜¯å¦å­˜åœ¨ æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹ çš„è·¯å¾„ï¼Œè¿™æ¡è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹å€¼ç›¸åŠ ç­‰äºç›®æ ‡å’ŒÂ targetSum ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šæ·±åº¦ä¼˜å…ˆéå†ï¼Œåˆ¤æ–­å½“å‰èŠ‚ç‚¹æ˜¯å¦æ˜¯å¶å­ç»“ç‚¹å¹¶ä¸”è·¯å¾„å’Œæ˜¯å¦ç­‰äºç»™å®šå€¼ï¼Œè‹¥æ˜¯åˆ™è¿”å›true,å¦åˆ™è¿”å›false

    # ä»£ç 
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if not root:
            return targetSum == 0

        if not root.left and not root.right and root.val == targetSum:
            return True
        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 144. äºŒå‰æ ‘çš„å‰åºéå†
é¢˜ç›®ï¼šç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å›å®ƒèŠ‚ç‚¹å€¼çš„ å‰åº éå†ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šæ·±åº¦ä¼˜å…ˆéå†ï¼Œä¸€æ¬¡æ‰“å°èŠ‚ç‚¹å€¼

    # ä»£ç 
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        
        res = []

        def dfs(node):
            if not node:
                return None
            res.append(node.val)
            dfs(node.left)
            dfs(node.right)
        
        dfs(root)
        return res

#### 2. éé€’å½’
æ€è·¯ï¼š

## 144. äºŒå‰æ ‘çš„ååºéå†
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¿”å›å®ƒçš„ ååº éå†ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šæ·±åº¦ä¼˜å…ˆéå†ï¼Œä¸€æ¬¡æ‰“å°èŠ‚ç‚¹å€¼

    # ä»£ç 
    def postorderTraversal(self, root: TreeNode) -> List[int]:

        res = []

        def dfs(node):
            if not node:
                return
            dfs(node.left)
            dfs(node.right)
            res.append(node.val)
        
        dfs(root)
        return res

#### 2. éé€’å½’
æ€è·¯ï¼š

## 226. ç¿»è½¬äºŒå‰æ ‘
é¢˜ç›®ï¼šç¿»è½¬ä¸€æ£µäºŒå‰æ ‘ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šé€’å½’éå†æ ¹èŠ‚ç‚¹ï¼Œäº¤æ¢å·¦å³èŠ‚ç‚¹å€¼ï¼Œéå†å·¦å­æ ‘ï¼Œéå†ğŸˆ¶å³å­æ ‘ï¼Œè¿”å›æ ¹èŠ‚ç‚¹ã€‚

    # ä»£ç 
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return None
        root.left, root.right = root.right, root.left
        self.invertTree(root.left)
        self.invertTree(root.right)
        return root

#### 2. éé€’å½’
æ€è·¯ï¼š



## 235. äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æœç´¢æ ‘, æ‰¾åˆ°è¯¥æ ‘ä¸­ä¸¤ä¸ªæŒ‡å®šèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚
ç™¾åº¦ç™¾ç§‘ä¸­æœ€è¿‘å…¬å…±ç¥–å…ˆçš„å®šä¹‰ä¸ºï¼šâ€œå¯¹äºæœ‰æ ¹æ ‘ T çš„ä¸¤ä¸ªç»“ç‚¹ pã€qï¼Œæœ€è¿‘å…¬å…±ç¥–å…ˆè¡¨ç¤ºä¸ºä¸€ä¸ªç»“ç‚¹ xï¼Œæ»¡è¶³ x æ˜¯ pã€q çš„ç¥–å…ˆä¸” x çš„æ·±åº¦å°½å¯èƒ½å¤§ï¼ˆä¸€ä¸ªèŠ‚ç‚¹ä¹Ÿå¯ä»¥æ˜¯å®ƒè‡ªå·±çš„ç¥–å…ˆï¼‰ã€‚â€
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šç”±äºæ˜¯äºŒå‰æœç´¢æ ‘ï¼Œæœ€è¿‘å…¬å…±ç¥–å…ˆçš„å€¼ä¸€å®šåœ¨p,qå€¼çš„ä¸­é—´ï¼Œå› æ­¤å¯éå†äºŒå‰æœç´¢æ ‘ï¼Œå¯»æ‰¾åœ¨ä¸­é—´çš„èŠ‚ç‚¹ã€‚

    # ä»£ç 
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if p.val < root.val and q.val < root.val:
            return self.lowestCommonAncestor(root.left, p, q)
        elif p.val > root.val and q.val >root.val:
            return self.lowestCommonAncestor(root.right, p, q)
        else:
            return root

#### 2. éé€’å½’
æ€è·¯ï¼š

## 257. äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼ŒæŒ‰ ä»»æ„é¡ºåº ï¼Œè¿”å›æ‰€æœ‰ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ã€‚å¶å­èŠ‚ç‚¹ æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šæ·±åº¦ä¼˜å…ˆéå†ï¼Œéå†æ—¶è®°å½•å½“å‰è·¯å¾„å³å¯ã€‚

    # ä»£ç 
    def binaryTreePaths(self, root: TreeNode) -> List[str]:

        res = []
    
        def dfs(root, path):
            if not root:
                return
            if not root.left and not root.right:
                path += (str(root.val))
            else:
                path += (str(root.val) + '->')
            if not root.left and not root.right:
                res.append(path)
            dfs(root.left, path)
            dfs(root.right, path)
        
        dfs(root, '')
        return res

#### 2. éé€’å½’
æ€è·¯ï¼š

## 404. å·¦å¶å­ä¹‹å’Œ
é¢˜ç›®ï¼šè®¡ç®—ç»™å®šäºŒå‰æ ‘çš„æ‰€æœ‰å·¦å¶å­ä¹‹å’Œã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šæ·±åº¦ä¼˜å…ˆéå†ï¼Œéå†æ—¶è®°å½•å½“å‰è·¯å¾„å³å¯ã€‚

    # ä»£ç 
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        
        self.num = 0

        def dfs(root, flag):
            if not root:
                return
            if not root.left and not root.right and flag == 1:
                self.num += root.val
            dfs(root.left, 1)
            dfs(root.right, 0)
        
        dfs(root, 0)
        
        return self.num

#### 2. éé€’å½’
æ€è·¯ï¼š

## 501. äºŒå‰æœç´¢æ ‘ä¸­çš„ä¼—æ•°
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªæœ‰ç›¸åŒå€¼çš„äºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰ï¼Œæ‰¾å‡º BST ä¸­çš„æ‰€æœ‰ä¼—æ•°ï¼ˆå‡ºç°é¢‘ç‡æœ€é«˜çš„å…ƒç´ ï¼‰ã€‚
å‡å®š BST æœ‰å¦‚ä¸‹å®šä¹‰ï¼š
ç»“ç‚¹å·¦å­æ ‘ä¸­æ‰€å«ç»“ç‚¹çš„å€¼å°äºç­‰äºå½“å‰ç»“ç‚¹çš„å€¼
ç»“ç‚¹å³å­æ ‘ä¸­æ‰€å«ç»“ç‚¹çš„å€¼å¤§äºç­‰äºå½“å‰ç»“ç‚¹çš„å€¼
å·¦å­æ ‘å’Œå³å­æ ‘éƒ½æ˜¯äºŒå‰æœç´¢æ ‘
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šä¸­åºéå†ï¼Œè¾¹éå†è¾¹è®°å½•å½“å‰å‡ºç°æœ€å¤§å€¼å³å¯ã€‚

    # ä»£ç 
    def findMode(self, root: TreeNode) -> List[int]:

        self.res = []
        self.pre = None  # å‰ä¸€ä¸ªèŠ‚ç‚¹
        self.current_count = 0 # å½“å‰èŠ‚ç‚¹é‡å¤æ•°é‡
        self.max_count = 0 # å½“å‰æœ€å¤§æ•°é‡

        def dfs(root):
            if not root:
                return 
            dfs(root.left)
            if self.pre and self.pre.val == root.val:
                self.current_count += 1
            else:
                self.current_count = 1
            self.pre = root
            if self.current_count == self.max_count:
                self.res.append(root.val)
            elif self.current_count > self.max_count:
                self.max_count = self.current_count
                self.res.clear()
                self.res.append(root.val)

            dfs(root.right)
        
        dfs(root)
        return self.res

#### 2. éé€’å½’
æ€è·¯ï¼š

## 530. äºŒå‰æœç´¢æ ‘çš„æœ€å°ç»å¯¹å·®
é¢˜ç›®ï¼šç»™ä½ ä¸€æ£µæ‰€æœ‰èŠ‚ç‚¹ä¸ºéè´Ÿå€¼çš„äºŒå‰æœç´¢æ ‘ï¼Œè¯·ä½ è®¡ç®—æ ‘ä¸­ä»»æ„ä¸¤èŠ‚ç‚¹çš„å·®çš„ç»å¯¹å€¼çš„æœ€å°å€¼ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šä¸­åºéå†ï¼Œæ‹¿å½“å‰èŠ‚ç‚¹å’Œå‰ä¸€èŠ‚ç‚¹æ¯”è¾ƒæ±‚å‡ºæœ€å°å€¼å³å¯ã€‚

    # ä»£ç 
    def getMinimumDifference(self, root: TreeNode) -> int:

        value = float('inf')
        pre = None

        def dfs(root):
            nonlocal value, pre
            if not root:
                return 
            dfs(root.left)
            if pre and abs(pre.val - root.val) < value:
                value = abs(pre.val - root.val)
            pre = root
            dfs(root.right)

        dfs(root)
        return value

#### 2. éé€’å½’
æ€è·¯ï¼š

## 543. äºŒå‰æ ‘çš„ç›´å¾„
é¢˜ç›®ï¼šç»™å®šä¸€æ£µäºŒå‰æ ‘ï¼Œä½ éœ€è¦è®¡ç®—å®ƒçš„ç›´å¾„é•¿åº¦ã€‚ä¸€æ£µäºŒå‰æ ‘çš„ç›´å¾„é•¿åº¦æ˜¯ä»»æ„ä¸¤ä¸ªç»“ç‚¹è·¯å¾„é•¿åº¦ä¸­çš„æœ€å¤§å€¼ã€‚è¿™æ¡è·¯å¾„å¯èƒ½ç©¿è¿‡ä¹Ÿå¯èƒ½ä¸ç©¿è¿‡æ ¹ç»“ç‚¹ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šæ±‚ä»¥æ¯ä¸ªèŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„æœ€å¤§é«˜åº¦ï¼Œè®°å½•æœ€å¤§å€¼å³å¯ã€‚

    # ä»£ç 
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        max_v = 0

        def depth(root):
            nonlocal max_v
            if not root:
                return 0
            l = depth(root.left)
            r = depth(root.right)
            max_v = max(max_v, l+r+1)
            return max(l, r) + 1

        depth(root)
        return max_v-1

#### 2. éé€’å½’
æ€è·¯ï¼š

## 559. N å‰æ ‘çš„æœ€å¤§æ·±åº¦
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ª N å‰æ ‘ï¼Œæ‰¾åˆ°å…¶æœ€å¤§æ·±åº¦ã€‚æœ€å¤§æ·±åº¦æ˜¯æŒ‡ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿œå¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ€»æ•°ã€‚
N å‰æ ‘è¾“å…¥æŒ‰å±‚åºéå†åºåˆ—åŒ–è¡¨ç¤ºï¼Œæ¯ç»„å­èŠ‚ç‚¹ç”±ç©ºå€¼åˆ†éš”ï¼ˆè¯·å‚è§ç¤ºä¾‹ï¼‰ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šè‹¥æ ¹ä¸ºç©ºï¼Œè¿”å›é«˜åº¦ä¸º0ï¼Œè‹¥æ ¹çš„æ‰€æœ‰childrenå­èŠ‚ç‚¹ä¸ºç©ºï¼ˆæ ¹æ˜¯å¶å­èŠ‚ç‚¹ï¼‰ï¼Œè¿”å›é«˜åº¦ä¸º1ï¼›é€’å½’æ±‚å‡ºæ¯ä¸€ä¸ªå­èŠ‚ç‚¹æ ‘çš„é«˜åº¦ï¼Œå¾—å‡ºæœ€å¤§å€¼å³å¯ã€‚

    # ä»£ç 
    def maxDepth(self, root: 'Node') -> int:

        def dfs(root):
            nonlocal max_d
            if not root:
                return 0
            if not root.children:
                return 1
            height = []
            for cl in root.children:
                height.append(dfs(cl))
            return max(height) + 1

        max_d = dfs(root)
        return max_d

#### 2. éé€’å½’
æ€è·¯ï¼š

## 563. äºŒå‰æ ‘çš„å¡åº¦
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè®¡ç®— æ•´ä¸ªæ ‘ çš„å¡åº¦ ã€‚
ä¸€ä¸ªæ ‘çš„ èŠ‚ç‚¹çš„å¡åº¦ å®šä¹‰å³ä¸ºï¼Œè¯¥èŠ‚ç‚¹å·¦å­æ ‘çš„èŠ‚ç‚¹ä¹‹å’Œå’Œå³å­æ ‘èŠ‚ç‚¹ä¹‹å’Œçš„ å·®çš„ç»å¯¹å€¼ ã€‚å¦‚æœæ²¡æœ‰å·¦å­æ ‘çš„è¯ï¼Œå·¦å­æ ‘çš„èŠ‚ç‚¹ä¹‹å’Œä¸º 0 ï¼›æ²¡æœ‰å³å­æ ‘çš„è¯ä¹Ÿæ˜¯ä¸€æ ·ã€‚ç©ºç»“ç‚¹çš„å¡åº¦æ˜¯ 0 ã€‚
æ•´ä¸ªæ ‘ çš„å¡åº¦å°±æ˜¯å…¶æ‰€æœ‰èŠ‚ç‚¹çš„å¡åº¦ä¹‹å’Œã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šæ±‚ä»¥æŸä¸ªèŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„çš„æ ‘çš„å€¼æ€»å’Œï¼Œå³å·¦èŠ‚ç‚¹æ€»å’Œ+å³èŠ‚ç‚¹æ€»å’Œ+è‡ªèº«å€¼ï¼Œå…¶ä¸­ï¼Œå·¦èŠ‚ç‚¹æ€»å’Œå’Œå³èŠ‚ç‚¹æ€»å’Œå·®çš„ç»å¯¹å€¼å³ä¸ºå½“å‰èŠ‚ç‚¹çš„å¡åº¦ï¼Œå¯¹æ‰€æœ‰èŠ‚ç‚¹æ±‚å¡åº¦ç„¶ååšåŠ å’Œå³ä¸ºæ ‘çš„å¡åº¦ã€‚

    # ä»£ç 
    def findTilt(self, root: TreeNode) -> int:
        res = 0

        # æ±‚ä»¥æŸä¸ªèŠ‚ç‚¹ä¸ºæ ¹çš„æ€»å’Œ
        def getNodeSum(root):
            nonlocal res
            if not root:
                return 0
            ls = getNodeSum(root.left)
            rs = getNodeSum(root.right)
            res += abs(ls - rs)
            return ls+rs+root.val

        getNodeSum(root)

        return res

#### 2. éé€’å½’
æ€è·¯ï¼š

## 572. å¦ä¸€æ£µæ ‘çš„å­æ ‘
é¢˜ç›®ï¼šç»™ä½ ä¸¤æ£µäºŒå‰æ ‘ root å’Œ subRoot ã€‚æ£€éªŒ root ä¸­æ˜¯å¦åŒ…å«å’Œ subRoot å…·æœ‰ç›¸åŒç»“æ„å’ŒèŠ‚ç‚¹å€¼çš„å­æ ‘ã€‚å¦‚æœå­˜åœ¨ï¼Œè¿”å› true ï¼›å¦åˆ™ï¼Œè¿”å› false ã€‚
äºŒå‰æ ‘ tree çš„ä¸€æ£µå­æ ‘åŒ…æ‹¬ tree çš„æŸä¸ªèŠ‚ç‚¹å’Œè¿™ä¸ªèŠ‚ç‚¹çš„æ‰€æœ‰åä»£èŠ‚ç‚¹ã€‚tree ä¹Ÿå¯ä»¥çœ‹åšå®ƒè‡ªèº«çš„ä¸€æ£µå­æ ‘ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šéå†rootæ¯ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä»¥æ¯ä¸ªå­èŠ‚ç‚¹æ ‘ä¸ºæ ¹åˆ¤æ–­æ˜¯å¦æ˜¯ç›¸åŒçš„æ ‘ã€‚

    # ä»£ç 
    def isSubtree(self, root: TreeNode, subRoot: TreeNode) -> bool:

        # ä»¥p, q ä¸ºæ ¹èŠ‚ç‚¹çš„ä¸¤é¢—äºŒå‰æ ‘æ˜¯å¦ä¸ºç›¸åŒçš„æ ‘
        def isSambleTree(p, q):
            if not p and not q:
                return True
            elif not q or not p:
                return False
            elif p.val != q.val:
                return False
            else:
                return isSambleTree(p.left, q.left) and isSambleTree(p.right, q.right)
        
        # éå†rootæ ‘ï¼Œå¹¶åˆ¤æ–­æ˜¯å¦ä¸ºç›¸åŒçš„æ ‘
        def dfs(root, subRoot):
            if not root and not subRoot:
                return True
            if not root or not subRoot:
                return False
            else:
                return isSambleTree(root, subRoot) or dfs(root.left, subRoot) or dfs(root.right, subRoot)

        # æ³•2
        def dfs2(root, subRoot):
            if not root:
                return False
            if root.val == subRoot.val:
                if isSambleTree(root, subRoot):
                    return True
        
            return dfs2(root.left, subRoot) or dfs2(root.right, subRoot)
        
        return dfs2(root, subRoot)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 589. N å‰æ ‘çš„å‰åºéå†
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ª N å‰æ ‘ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„ å‰åºéå† ã€‚N å‰æ ‘ åœ¨è¾“å…¥ä¸­æŒ‰å±‚åºéå†è¿›è¡Œåºåˆ—åŒ–è¡¨ç¤ºï¼Œæ¯ç»„å­èŠ‚ç‚¹ç”±ç©ºå€¼ null åˆ†éš”ï¼ˆè¯·å‚è§ç¤ºä¾‹ï¼‰ã€‚
è¿›é˜¶ï¼šé€’å½’æ³•å¾ˆç®€å•ï¼Œä½ å¯ä»¥ä½¿ç”¨è¿­ä»£æ³•å®Œæˆæ­¤é¢˜å—?
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šä¾æ¬¡éå†å³å¯ã€‚

    # ä»£ç 
    def preorder(self, root: 'Node') -> List[int]:
        res = []

        def dfs(root):
            nonlocal res
            if not root:
                return 
            res.append(root.val)
            for cl in root.children:
                dfs(cl)
        
        dfs(root)
        return res


#### 2. éé€’å½’
æ€è·¯ï¼š

## 590. N å‰æ ‘çš„ååºéå†
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ª N å‰æ ‘ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„ ååºéå† ã€‚N å‰æ ‘ åœ¨è¾“å…¥ä¸­æŒ‰å±‚åºéå†è¿›è¡Œåºåˆ—åŒ–è¡¨ç¤ºï¼Œæ¯ç»„å­èŠ‚ç‚¹ç”±ç©ºå€¼ null åˆ†éš”ï¼ˆè¯·å‚è§ç¤ºä¾‹ï¼‰ã€‚
è¿›é˜¶ï¼šé€’å½’æ³•å¾ˆç®€å•ï¼Œä½ å¯ä»¥ä½¿ç”¨è¿­ä»£æ³•å®Œæˆæ­¤é¢˜å—?
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šä¾æ¬¡éå†å³å¯ã€‚

    # ä»£ç 
    def postorder(self, root: 'Node') -> List[int]:

        res = []

        def dfs(root):
            nonlocal res
            if not root:
                return 
            for cl in root.children:
                dfs(cl)
            res.append(root.val)

        dfs(root)
        return res


#### 2. éé€’å½’
æ€è·¯ï¼š



