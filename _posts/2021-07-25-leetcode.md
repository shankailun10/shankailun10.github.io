# leetcode题解
1. TOC
{:toc}

## 101. 对称二叉树
题目：给定一个二叉树，检查它是否是镜像对称的。
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归

#### 2. 非递归
思路：判断根是否为空，是返回True, 否判断左右两个孩子是否相等，是继续判断左孩子的左节点和右孩子的右节点是否相等，以及左孩子的右节点和右孩子的左节点是否相等

    #队列代码
    def getRes(root):
        if not root:
            return True
        queue = [(root.left, root.right)]
        while queue != []:
            left, right = queue.pop()
            if not left and not right:
                continue
            if left and right and left.val == right.val:
                queue.append((left.left, right.right))
                queue.append((left.right, right.left))
            else:
                return False
        return True
        
## 102. 二叉树的层序遍历
题目：给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1、递归

#### 2. 非递归
思路：若根为空，返回[]，若根不空将根入队列queue，然后依次遍历队列中的节点值存入res，然后依次遍历队列中的节点，把该节点的左节点、右节点依次入子队列l1，将子队列l1赋值给queue,返回res。

    # 代码
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        res, queue = [], [root]
        while queue:
            res.append([q.val for q in queue])
            l1 = []
            for q in queue:
                if q.left:
                    l1.append(q.left)
                if q.right:
                    l1.append(q.right)
            queue = l1
        return res
        

## 100. 相同的树
题目：给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
### 两种方法：1、递归实现，2. 非递归实现(队列)
####1. 递归
思路：比较根节点是否相等，然后递归比较左子树节点和右子树节点是否相等。

    # 代码
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        if not p and not q:
            return True
        elif not p or not q:
            return False
        elif p.val != q.val:
            return False
        else:
            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)

####2. 非递归
思路：同时遍历两棵树，依次比较节点值，若当前左子树或右子树为空时也入队列。

## 104. 二叉树最大深度
给定一个二叉树，找出其最大深度。
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明: 叶子节点是指没有子节点的节点。
### 两种方法：1、递归实现，2. 非递归实现(队列)
####1. 递归
思路：若根为空，返回0，若根不空，则最大深度为左子树最大深度和右子树最大深度取最大值+1

    # 代码
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        l = self.maxDepth(root.left)
        r = self.maxDepth(root.right)
        return max(l, r) + 1

### 2. 非递归
思路：二叉树层次遍历，返回数组长度。

## 108. 将有序数组转换为二叉搜索树
题目：给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。
高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：取数组中间位置做根，中间位置的左边部分构建左子树，右边部分构建右子树。

    # 代码
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        def mark_tree(s, e):
            if s > e:
                return None
            mid = (s + e) // 2
            sub_tree = TreeNode(nums[mid])
            sub_tree.left = mark_tree(s, mid - 1)
            sub_tree.right = mark_tree(mid + 1, e)
            return sub_tree
        return mark_tree(0, len(nums) - 1)

#### 2. 非递归
思路：

## 110. 平衡二叉树
题目：给定一个二叉树，判断它是否是高度平衡的二叉树。
本题中，一棵高度平衡二叉树定义为：
一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：若根为空，返回True,判断根的左右子树高度差绝对值是否<=1，否：返回False,依次判断根的左子树、右子树是否是平衡树

    # 代码
    def isBalanced(self, root: TreeNode) -> bool:
        def maxDepth(node):
            if not node:
                return 0
            l = maxDepth(node.left)
            r = maxDepth(node.right)
            return max(l, r) + 1

        if not root:
            return True
        return abs(maxDepth(root.left) - maxDepth(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)

#### 2. 非递归
思路：

## 111. 二叉树的最小深度
题目：给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。说明：叶子节点是指没有子节点的节点。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：层序遍历二叉树，记录深度，遇到某个节点没有左子树或右子树直接返回深度即可。

    # 代码
    def minDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        queue = [root]
        depth = 1
        while queue:
            l1 = []
            for q in queue:
                if not q.left and not q.right:
                    return depth
                if q.left:
                    l1.append(q.left)
                if q.right:
                    l1.append(q.right)
            queue = l1
            depth += 1
        return depth

#### 2. 非递归
思路：

## 112. 路径总和
题目：给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：深度优先遍历，判断当前节点是否是叶子结点并且路径和是否等于给定值，若是则返回true,否则返回false

    # 代码
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if not root:
            return targetSum == 0

        if not root.left and not root.right and root.val == targetSum:
            return True
        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)

#### 2. 非递归
思路：

## 144. 二叉树的前序遍历
题目：给你二叉树的根节点 root ，返回它节点值的 前序 遍历。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：深度优先遍历，一次打印节点值

    # 代码
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        
        res = []

        def dfs(node):
            if not node:
                return None
            res.append(node.val)
            dfs(node.left)
            dfs(node.right)
        
        dfs(root)
        return res

#### 2. 非递归
思路：

## 144. 二叉树的后序遍历
题目：给定一个二叉树，返回它的 后序 遍历。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：深度优先遍历，一次打印节点值

    # 代码
    def postorderTraversal(self, root: TreeNode) -> List[int]:

        res = []

        def dfs(node):
            if not node:
                return
            dfs(node.left)
            dfs(node.right)
            res.append(node.val)
        
        dfs(root)
        return res

#### 2. 非递归
思路：

## 226. 翻转二叉树
题目：翻转一棵二叉树。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：递归遍历根节点，交换左右节点值，遍历左子树，遍历🈶右子树，返回根节点。

    # 代码
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return None
        root.left, root.right = root.right, root.left
        self.invertTree(root.left)
        self.invertTree(root.right)
        return root

#### 2. 非递归
思路：



## 235. 二叉搜索树的最近公共祖先
题目：给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：由于是二叉搜索树，最近公共祖先的值一定在p,q值的中间，因此可遍历二叉搜索树，寻找在中间的节点。

    # 代码
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if p.val < root.val and q.val < root.val:
            return self.lowestCommonAncestor(root.left, p, q)
        elif p.val > root.val and q.val >root.val:
            return self.lowestCommonAncestor(root.right, p, q)
        else:
            return root

#### 2. 非递归
思路：

## 257. 二叉树的所有路径
题目：给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。叶子节点 是指没有子节点的节点。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：深度优先遍历，遍历时记录当前路径即可。

    # 代码
    def binaryTreePaths(self, root: TreeNode) -> List[str]:

        res = []
    
        def dfs(root, path):
            if not root:
                return
            if not root.left and not root.right:
                path += (str(root.val))
            else:
                path += (str(root.val) + '->')
            if not root.left and not root.right:
                res.append(path)
            dfs(root.left, path)
            dfs(root.right, path)
        
        dfs(root, '')
        return res

#### 2. 非递归
思路：

## 404. 左叶子之和
题目：计算给定二叉树的所有左叶子之和。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：深度优先遍历，遍历时记录当前路径即可。

    # 代码
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        
        self.num = 0

        def dfs(root, flag):
            if not root:
                return
            if not root.left and not root.right and flag == 1:
                self.num += root.val
            dfs(root.left, 1)
            dfs(root.right, 0)
        
        dfs(root, 0)
        
        return self.num

#### 2. 非递归
思路：

## 501. 二叉搜索树中的众数
题目：给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。
假定 BST 有如下定义：
结点左子树中所含结点的值小于等于当前结点的值
结点右子树中所含结点的值大于等于当前结点的值
左子树和右子树都是二叉搜索树
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：中序遍历，边遍历边记录当前出现最大值即可。

    # 代码
    def findMode(self, root: TreeNode) -> List[int]:

        self.res = []
        self.pre = None  # 前一个节点
        self.current_count = 0 # 当前节点重复数量
        self.max_count = 0 # 当前最大数量

        def dfs(root):
            if not root:
                return 
            dfs(root.left)
            if self.pre and self.pre.val == root.val:
                self.current_count += 1
            else:
                self.current_count = 1
            self.pre = root
            if self.current_count == self.max_count:
                self.res.append(root.val)
            elif self.current_count > self.max_count:
                self.max_count = self.current_count
                self.res.clear()
                self.res.append(root.val)

            dfs(root.right)
        
        dfs(root)
        return self.res

#### 2. 非递归
思路：

## 530. 二叉搜索树的最小绝对差
题目：给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：中序遍历，拿当前节点和前一节点比较求出最小值即可。

    # 代码
    def getMinimumDifference(self, root: TreeNode) -> int:

        value = float('inf')
        pre = None

        def dfs(root):
            nonlocal value, pre
            if not root:
                return 
            dfs(root.left)
            if pre and abs(pre.val - root.val) < value:
                value = abs(pre.val - root.val)
            pre = root
            dfs(root.right)

        dfs(root)
        return value

#### 2. 非递归
思路：

## 543. 二叉树的直径
题目：给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：求以每个节点为根节点的最大高度，记录最大值即可。

    # 代码
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        max_v = 0

        def depth(root):
            nonlocal max_v
            if not root:
                return 0
            l = depth(root.left)
            r = depth(root.right)
            max_v = max(max_v, l+r+1)
            return max(l, r) + 1

        depth(root)
        return max_v-1

#### 2. 非递归
思路：

## 559. N 叉树的最大深度
题目：给定一个 N 叉树，找到其最大深度。最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。
N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：若根为空，返回高度为0，若根的所有children子节点为空（根是叶子节点），返回高度为1；递归求出每一个子节点树的高度，得出最大值即可。

    # 代码
    def maxDepth(self, root: 'Node') -> int:

        def dfs(root):
            nonlocal max_d
            if not root:
                return 0
            if not root.children:
                return 1
            height = []
            for cl in root.children:
                height.append(dfs(cl))
            return max(height) + 1

        max_d = dfs(root)
        return max_d

#### 2. 非递归
思路：

## 563. 二叉树的坡度
题目：给定一个二叉树，计算 整个树 的坡度 。
一个树的 节点的坡度 定义即为，该节点左子树的节点之和和右子树节点之和的 差的绝对值 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。
整个树 的坡度就是其所有节点的坡度之和。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：求以某个节点为根节点的的树的值总和，即左节点总和+右节点总和+自身值，其中，左节点总和和右节点总和差的绝对值即为当前节点的坡度，对所有节点求坡度然后做加和即为树的坡度。

    # 代码
    def findTilt(self, root: TreeNode) -> int:
        res = 0

        # 求以某个节点为根的总和
        def getNodeSum(root):
            nonlocal res
            if not root:
                return 0
            ls = getNodeSum(root.left)
            rs = getNodeSum(root.right)
            res += abs(ls - rs)
            return ls+rs+root.val

        getNodeSum(root)

        return res

#### 2. 非递归
思路：

## 572. 另一棵树的子树
题目：给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。
二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：遍历root每一个节点，以每个子节点树为根判断是否是相同的树。

    # 代码
    def isSubtree(self, root: TreeNode, subRoot: TreeNode) -> bool:

        # 以p, q 为根节点的两颗二叉树是否为相同的树
        def isSambleTree(p, q):
            if not p and not q:
                return True
            elif not q or not p:
                return False
            elif p.val != q.val:
                return False
            else:
                return isSambleTree(p.left, q.left) and isSambleTree(p.right, q.right)
        
        # 遍历root树，并判断是否为相同的树
        def dfs(root, subRoot):
            if not root and not subRoot:
                return True
            if not root or not subRoot:
                return False
            else:
                return isSambleTree(root, subRoot) or dfs(root.left, subRoot) or dfs(root.right, subRoot)

        # 法2
        def dfs2(root, subRoot):
            if not root:
                return False
            if root.val == subRoot.val:
                if isSambleTree(root, subRoot):
                    return True
        
            return dfs2(root.left, subRoot) or dfs2(root.right, subRoot)
        
        return dfs2(root, subRoot)

#### 2. 非递归
思路：

## 589. N 叉树的前序遍历
题目：给定一个 N 叉树，返回其节点值的 前序遍历 。N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。
进阶：递归法很简单，你可以使用迭代法完成此题吗?
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：依次遍历即可。

    # 代码
    def preorder(self, root: 'Node') -> List[int]:
        res = []

        def dfs(root):
            nonlocal res
            if not root:
                return 
            res.append(root.val)
            for cl in root.children:
                dfs(cl)
        
        dfs(root)
        return res


#### 2. 非递归
思路：

## 590. N 叉树的后序遍历
题目：给定一个 N 叉树，返回其节点值的 后序遍历 。N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。
进阶：递归法很简单，你可以使用迭代法完成此题吗?
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：依次遍历即可。

    # 代码
    def postorder(self, root: 'Node') -> List[int]:

        res = []

        def dfs(root):
            nonlocal res
            if not root:
                return 
            for cl in root.children:
                dfs(cl)
            res.append(root.val)

        dfs(root)
        return res


#### 2. 非递归
思路：

## 617. 合并二叉树
题目：给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。
你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：依次遍历即可。

    # 代码
    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:

        def dfs(root1, root2):
            if root1 and root2:
                root = TreeNode(root1.val + root2.val)
                root.left = dfs(root1.left, root2.left)
                root.right = dfs(root1.right, root2.right)
            elif root1:
                root = TreeNode(root1.val)
                root.left = dfs(root1.left, None)
                root.right = dfs(root1.right, None)
            elif root2:
                root = TreeNode(root2.val)
                root.left = dfs(root2.left, None)
                root.right = dfs(root2.right, None)
            else:
                root = None
                return 
            return root

        return dfs(root1, root2)


#### 2. 非递归
思路：

## 637. 二叉树的层平均值
题目：给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：层序遍历，求每层平均值即可。

    # 代码
    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:

        res = []
        queue = [root]
        while queue:
            res.append(sum([q.val for q in queue]) / len([q.val for q in queue]))
            l1 = []
            for q in queue:
                if q.left:
                    l1.append(q.left)
                if q.right:
                    l1.append(q.right)
            queue = l1
        return res


#### 2. 非递归
思路：

## 653. 两数之和 IV - 输入 BST
题目：给定一个二叉搜索树 root 和一个目标结果 k，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：层序遍历，求每层平均值即可。

    # 代码
    def findTarget(self, root: TreeNode, k: int) -> bool:

        res = []

        def dfs(root):
            nonlocal res
            if not root:
                return
            dfs(root.left)
            res.append(root.val)
            dfs(root.right)

        dfs(root)

        l, r = 0, len(res)-1
        while l < r:
            if res[l] + res[r] == k:
                return True
            elif res[l] + res[r] > k:
                r -= 1
            else:
                l += 1
        return False

#### 2. 非递归
思路：

## 671. 二叉树中第二小的节点
题目：给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。
更正式地说，root.val = min(root.left.val, root.right.val) 总成立。给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 前序遍历，找到第一个不等于根节点的值返回即可。

    # 代码
    def findSecondMinimumValue(self, root: TreeNode) -> int:
        min_v = root.val

        def dfs(root):
            if not root:
                return float('inf')
            if root.val != min_v:
                return root.val
            else:
                return min(dfs(root.left), dfs(root.right))

        return dfs(root) if dfs(root) != float('inf') else -1

#### 2. 非递归
思路：

## 700. 二叉搜索树中的搜索
题目：给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 前序遍历，判断当前节点和给定值的大小，若大则遍历左子树，否则右子树。

    # 代码
    def searchBST(self, root: TreeNode, val: int) -> TreeNode:

        def dfs(root):
            if not root:
                return -1
            if root.val == val:
                return root
            elif root.val > val:
                return dfs(root.left)
            else:
                return dfs(root.right)

        return dfs(root) if dfs(root)!= -1 else None

#### 2. 非递归
思路：

## 703. 数据流中的第 K 大元素
题目：设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。
请实现 KthLargest 类：
KthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。
int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 

    # 代码
    

#### 2. 非递归
思路：

## 783. 二叉搜索树节点最小距离
题目：给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 中序遍历，记录最小差值即可。

    # 代码
    def minDiffInBST(self, root: TreeNode) -> int:

        min_v = float('inf')
        pre = None

        def dfs(root):
            nonlocal min_v, pre
            if not root:
                return
            dfs(root.left)
            if pre and abs(pre.val - root.val) < min_v:
                min_v = abs(pre.val - root.val)
            pre = root
            dfs(root.right)
        
        dfs(root)
        return min_v

#### 2. 非递归
思路：

## 872. 叶子相似的树
题目：请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 叶值序列 。
举个例子，如上图所示，给定一棵叶值序列为 (6, 7, 4, 9, 8) 的树。如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是 叶相似 的。
如果给定的两个根结点分别为 root1 和 root2 的树是叶相似的，则返回 true；否则返回 false 。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 中序遍历，记录最小差值即可。

    # 代码
    def leafSimilar(self, root1: TreeNode, root2: TreeNode) -> bool:

        def dfs(root, res):
            if not root:
                return
            if not root.left and not root.right:
                res.append(root.val) 

            dfs(root.left, res)
            dfs(root.right, res)

        res1, res2 = [], []
        dfs(root1, res1)
        dfs(root2, res2)
        return res1 == res2

#### 2. 非递归
思路：

## 897. 递增顺序搜索树
题目：给你一棵二叉搜索树，请你 按中序遍历 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 中序遍历，然后构建递增树即可。

    # 代码
    def increasingBST(self, root: TreeNode) -> TreeNode:

        res = []

        def dfs(root):
            nonlocal res
            if not root:
                return
            dfs(root.left)
            res.append(root.val)
            dfs(root.right)

        dfs(root)
        if not res:
            return None
        main_node = TreeNode(0)
        res_node = main_node
        for re in res:
            tmp = TreeNode(re)
            main_node.left = None
            main_node.right = tmp
            main_node = main_node.right

        return res_node.right

#### 2. 非递归
思路：

## 938. 二叉搜索树的范围和
题目：给定二叉搜索树的根结点 root，返回值位于范围 [low, high] 之间的所有结点的值的和。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 中序遍历，值在给定范围的求和即可。

    # 代码
    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:

        res = []

        def dfs(root):
            if not root:
                return 
            dfs(root.left)
            if root.val >= low and root.val <=high:
                res.append(root.val)
            dfs(root.right)
        
        dfs(root)
        return sum(res)

#### 2. 非递归
思路：

## 965. 单值二叉树
题目：如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。只有给定的树是单值二叉树时，才返回 true；否则返回 false。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 前序遍历，把所有值存入数组，然后判断数组是否只包含同一个数即可。

    # 代码
    def isUnivalTree(self, root: TreeNode) -> bool:
        val = root.val

        def dfs(root):
            if not root:
                return True
            if root.val != val:
                return False
            else:
                return dfs(root.left) and dfs(root.right)
        
        return dfs(root)

#### 2. 非递归
思路：

## 993. 二叉树的堂兄弟节点
题目：在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。
我们给出了具有唯一值的二叉树的根节点 root ，以及树中两个不同节点的值 x 和 y 。只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true 。否则，返回 false。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 前序遍历，记录当前节点的深度，和当前节点的父节点。

    # 代码
    def isCousins(self, root: TreeNode, x: int, y: int) -> bool:
        x_d, y_d, x_p, y_p = 0, 0, None, None

        def dfs(root, parent, x, y, depth):
            nonlocal x_d, x_p, y_d, y_p
            if not root:
                return
            if root.val == x:
                x_d = depth
                x_p = parent
            if root.val == y:
                y_d = depth
                y_p = parent
            dfs(root.left, root, x, y, depth+1)
            dfs(root.right, root, x, y, depth+1)
        
        dfs(root, None, x, y, depth=0)
        return x_d == y_d and x_p !=y_p

#### 2. 非递归
思路：

## 1022. 从根到叶的二进制数之和
题目：给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。例如，如果路径为 0 -> 1 -> 1 -> 0 -> 1，那么它表示二进制数 01101，也就是 13 。对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。返回这些数字之和。题目数据保证答案是一个 32 位 整数。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 遍历记录根到叶子节点的路径，然后求和即可。

    # 代码
    def sumRootToLeaf(self, root: TreeNode) -> int:

        res = []

        def dfs(root, path):
            if not root:
                return
            path += str(root.val)
            if not root.left and not root.right:
                res.append(path)
            dfs(root.left, path)
            dfs(root.right, path)

        def getNum(s):
            sum = 0
            for i in range(len(s)):
                sum += (int(s[len(s) - i -1]) * pow(2, i))
            return sum

        dfs(root, '')
        sum = 0
        for re in res:
            sum += getNum(re)
        return sum

#### 2. 非递归
思路：

## 95. 不同的二叉搜索树 II
题目：给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 从[1,...n] 遍历，一次当根，因为是二叉搜索树，当根节点取i时，[1,...i] 构成左子树，[i,...n] 构成右子树，左右子树再递归求解即可。

    # 代码
    def generateTrees(self, n: int) -> List[TreeNode]:

        def dfs(s, e):
            res = []
            if s > e:
                return [None]
            for i in range(s, e+1):
                lefts = dfs(s, i-1)
                rights = dfs(i+1, e)
                for l in lefts:
                    for r in rights:
                        node = TreeNode(i)
                        node.left = l
                        node.right = r
                        res.append(node)
            return res
        return dfs(1, n)

#### 2. 非递归
思路：

## 96. 不同的二叉搜索树
题目：给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 记忆化搜索，总的种数=左子树种数*右子树数量。
    # 代码
    def numTrees(self, n: int) -> int:

        dic = {0: 1, 1: 2, 2: 2}

        def dfs(n):
            if n <= 0: return 1
            if n <= 2: return n
            if n in dic:
                return dic[n]
            dic[n] = sum([dfs(i-1) * dfs(n-i) for i in range(1, n+1)])
            return dic[n]

        return dfs(n)

#### 2. 非递归
思路：

## 98. 验证二叉搜索树
题目：给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。有效 二叉搜索树定义如下：
节点的左子树只包含 小于 当前节点的数。节点的右子树只包含 大于 当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 中序遍历，单调递增

    # 代码
    def isValidBST(self, root: TreeNode) -> bool:
        pre = None

        def dfs(root):
            nonlocal pre
            if not root:
                return True
            left = dfs(root.left)
            if pre and pre.val >= root.val:
                return False
            pre = root
            right = dfs(root.right)
            return left and right
        
        return dfs(root)

#### 2. 非递归
思路：

## 99. 恢复二叉搜索树
题目：给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。
进阶：使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 中序遍历，找到第一个a>b的，取a,然后取第二个a>b的取b,最后交换a和b。

    # 代码
    def recoverTree(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """

        firstNode = None
        secondNode = None
        pre = None

        def dfs(root):
            nonlocal pre, firstNode, secondNode
            if not root:
                return 
            
            dfs(root.left)
            if pre:
                if not firstNode and pre.val > root.val:
                    firstNode = pre
                    secondNode = root
                elif firstNode and pre.val > root.val:
                    secondNode = root
            pre = root
            dfs(root.right)

        dfs(root)
        if firstNode and secondNode:
            firstNode.val, secondNode.val = secondNode.val, firstNode.val

#### 2. 非递归
思路：

## 102. 二叉树的层序遍历
题目：给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 

#### 2. 非递归
思路：层序遍历，非递归。

    # 代码
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        
        res = []
        queue = [root]

        while queue:
            res.append([q.val for q in queue])
            l = []
            for q in queue:
                if q.left:
                    l.append(q.left)
                if q.right:
                    l.append(q.right)
            queue = l
        
        return res

## 103. 二叉树的锯齿形层序遍历
题目：给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 

#### 2. 非递归
思路：层序遍历，使用单独遍历记录是否需要翻转。

    # 代码
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        res = []
        queue = [root]
        is_reverse = False
        while queue:
            tmp = [q.val for q in queue]
            if is_reverse:
                tmp.reverse()
                res.append(tmp)
                is_reverse = False
            else:
                res.append(tmp)
                is_reverse = True

            l = []
            for q in queue:
                if q.left:
                    l.append(q.left)
                if q.right:
                    l.append(q.right)
            queue = l
        
        return res
        
## 105. 从前序与中序遍历序列构造二叉树
题目：给定一棵树的前序遍历 preorder 与中序遍历  inorder。请构造二叉树并返回其根节点。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 根据前序找到根节点，然后递归构建左子树和右子树

    # 构造二叉树
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:

        def dfs(preorder, inorder):
            if not preorder or not inorder:
                return
            root = TreeNode(preorder[0])
            index = inorder.index(preorder[0])
            root.left = dfs(preorder[1:index+1], inorder[0:index])
            root.right = dfs(preorder[index+1:], inorder[index+1:])
            return root

        return dfs(preorder, inorder)

#### 2. 非递归
思路：

## 106. 从中序与后序遍历序列构造二叉树
题目：根据一棵树的中序遍历与后序遍历构造二叉树。
注意:你可以假设树中没有重复的元素。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 根据后序找到根节点，然后递归构建左子树和右子树

    # 构造二叉树
    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:

        def dfs(inorder, postorder):
            if not inorder or not postorder:
                return 
            index = inorder.index(postorder[-1])
            root = TreeNode(postorder[-1])
            root.left = dfs(inorder[0:index], postorder[0:index])
            root.right = dfs(inorder[index+1:], postorder[index:len(postorder)-1])
            return root
        
        return dfs(inorder, postorder)

#### 2. 非递归
思路：

## 107. 二叉树的层序遍历 II
题目：给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 层序遍历，将结果翻转即可。

    # 层顺序遍历
    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []

        res = []
        queue = [root]
        while queue:
            res.append([q.val for q in queue])
            l = []
            for q in queue:
                if q.left:
                    l.append(q.left)
                if q.right:
                    l.append(q.right)
            queue= l

        res.reverse()

        return res
#### 2. 非递归
思路：

## 109. 有序链表转换二叉搜索树
题目：给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。
本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 有序链表快慢指针找中点，然后构建树即可。

    # 层顺序遍历
    def sortedListToBST(self, head: ListNode) -> TreeNode:

        def findMid(head, tail):
            fast = head
            slow = head
            while fast != tail and fast.next != tail:
                slow = slow.next
                fast = fast.next.next
            return slow
        
        def dfs(head, tail):
            if head == tail:
                return None
            node = findMid(head, tail)
            root= TreeNode(node.val)
            root.left = dfs(head, node)
            root.right = dfs(node.next, tail)
            return root

        return dfs(head, None)
#### 2. 非递归
思路：

## 113. 路径总和 II
题目：给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。
叶子节点 是指没有子节点的节点。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 深度优先遍历，遍历到叶子节点时判断即可。

    # 层顺序遍历
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:

        res = []
        sub_res = []
        def dfs(root):
            nonlocal res, sub_res
            if not root:
                return 
            sub_res.append(root.val)
            if not root.left and not root.right:
                if sum(sub_res) == targetSum:
                    res.append([s for s in sub_res])
            dfs(root.left)
            dfs(root.right)
            sub_res.pop()

        dfs(root)
        return res
#### 2. 非递归
思路：

## 114. 二叉树展开为链表
题目：给你二叉树的根结点 root ，请你将它展开为一个单链表：
展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
展开后的单链表应该与二叉树 先序遍历 顺序相同。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 先序遍历，根左右，将根节点的右子树移到左子树的最右节点，将左子树变为根的右子树，将根的右子树置为空，然后根节点右移循环判断。

    # 层顺序遍历
    def flatten(self, root: TreeNode) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        if not root:
            return 

        node = root

        while node:
            if node.left:
                sub_left = node.left
                tmp = sub_left
                while tmp.right:
                    tmp = tmp.right
                tmp.right = node.right
                node.right = sub_left
                node.left = None
            node = node.right
#### 2. 非递归
思路：

## 116. 填充每个节点的下一个右侧节点指针
题目：给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
初始状态下，所有 next 指针都被设置为 NULL。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 每个根节点的左节点next应该指向根节点的右节点，每个根节点的右节点next应该指向其父节点的next节点的左节点。

    # 
    def connect(self, root: 'Node') -> 'Node':

        def dfs(root):
            if not root:
                return
            if root.left:
                root.left.next = root.right
            if root.right:
                if root.next:
                    root.right.next = root.next.left
            dfs(root.left)
            dfs(root.right)

        dfs(root)
        return root
#### 2. 非递归
思路：

## 117. 填充每个节点的下一个右侧节点指针 II
题目：给定一个二叉树
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
初始状态下，所有 next 指针都被设置为 NULL。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 每个根节点的左节点next应该指向根节点的右节点，每个根节点的右节点next应该指向其父节点的next节点的左节点。

    # 
    
#### 2. 非递归
思路：

## 129. 求根节点到叶节点数字之和
给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。
每条从根节点到叶节点的路径都代表一个数字：
例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。
计算从根节点到叶节点生成的 所有数字之和 。
叶节点 是指没有子节点的节点。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 深度遍历，直接求和即可。

    # 
    def sumNumbers(self, root: TreeNode) -> int:

        res = 0
        def dfs(root, num):
            nonlocal res
            if not root:
                return
            if not root.left and not root.right:
                res += num
            if root.left:
                dfs(root.left, num * 10 + root.left.val)
            if root.right:
                dfs(root.right, num * 10 + root.right.val)
        dfs(root, root.val)
        return res
    
#### 2. 非递归
思路：

## 173. 二叉搜索树迭代器
实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：
BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。
boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。
int next()将指针向右移动，然后返回指针处的数字。
注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。
你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 求next时构造单调栈。

    # 
    class BSTIterator:

    def __init__(self, root: TreeNode):
        self.res = []
        while root:
            self.res.append(root)
            root = root.left


    def next(self) -> int:
        cur = self.res.pop()
        node = cur.right
        while node:
            self.res.append(node)
            node = node.left
        return cur.val


    def hasNext(self) -> bool:
        return len(self.res) > 0
    
#### 2. 非递归
思路：

## 199. 二叉树的右视图
给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 层次遍历，每层取最右边节点。

    # 
    def rightSideView(self, root: TreeNode) -> List[int]:
        if not root:
            return []

        res = []
        queue = [root]
        while queue:
            res.append(queue[-1].val)
            l = []
            for q in queue:
                if q.left:
                    l.append(q.left)
                if q.right:
                    l.append(q.right)
            queue = l

        return res
    
#### 2. 非递归
思路：

## 222. 完全二叉树的节点个数
给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。
完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 遍历根节点饿左子树高度和右子树高度，若高度相同则表示左子树肯定是满二叉树，总节点个数为左子树满二叉树+递归右子树，若不想等，则右子树肯定是二叉树，总节点个数为右子树满二叉树+递归左子树

    # 
    def countNodes(self, root: TreeNode) -> int:
        if not root:
            return 0

        def getDepth(node):
            if not node:
                return 0
            return max(getDepth(node.left), getDepth(node.right)) + 1

        def dfs(root):
            if not root:
                return 0
            l_d, r_d = getDepth(root.left), getDepth(root.right)
            if l_d == r_d:
                return (1<<l_d) + dfs(root.right)
            else:
                return (1<<r_d) + dfs(root.left)
        
        return dfs(root)
    
#### 2. 非递归
思路：

## 230. 二叉搜索树中第K小的元素
给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 中序遍历，遍历到第k个时结束即可。

    # 
    def kthSmallest(self, root: TreeNode, k: int) -> int:

        res = 0

        def dfs(root):
            nonlocal res, k
            if not root:
                return
            dfs(root.left)
            k -= 1
            if k == 0:
                res = root.val
                return
            dfs(root.right)

        dfs(root)

        return res
    
#### 2. 非递归
思路：

## 236. 二叉树的最近公共祖先
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 最近公共祖先只会出现在情况，一是在根节点的左子树和右子树中，则为根，二是p是q的根，三是q是p的根。

    # 
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':

        def dfs(root):
            # nonlocal p, q
            if not root:
                return None
            if root == p or root == q:
                return root
            left = dfs(root.left)
            right = dfs(root.right)
            if not left:
                return right
            elif not right:
                return left
            elif not left and not right:
                return None
            else:
                return root

        return dfs(root)
    
#### 2. 非递归
思路：

## 331. 验证二叉树的前序序列化
序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 3##变为#，栈最后只剩一个#，返回true，反之反回false

    # 
    def isValidSerialization(self, preorder: str) -> bool:

        stack = []
        data = preorder.split(',')
        for s in data:
            stack.append(s)
            while len(stack) >= 3 and stack[-1] == '#' and stack[-2] == '#' and stack[-3] != '#':
                for i in range(3):
                    stack.pop()
                stack.append('#')
        return len(stack) == 1 and stack[0] == '#'
    
#### 2. 非递归
思路：

## 337. 打家劫舍 III
在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。
计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 递归，当根节点不偷时，左右两个孩子可以偷，可以不偷，取偷和不偷的最大值，当根节点偷时，左右两个孩子都不偷。

    # 
    def rob(self, root: TreeNode) -> int:

        def dfs(root):
            if not root:
                return 0, 0  # 偷，不偷
            left = dfs(root.left)
            right = dfs(root.right)
            # 偷当前节点，其左右两个孩子都不能偷
            v1 = root.val + left[1] + right[1]
            # 不偷当前节点，则左右两个孩子可以偷，可以不偷，取孩子最大值
            v2 = max(left[0], left[1]) + max(right[0], right[1])
            return v1, v2

        res = dfs(root)
        return max(res[0], res[1])
    
#### 2. 非递归
思路：

## 341. 扁平化嵌套列表迭代器
题目：给你一个嵌套的整数列表 nestedList 。每个元素要么是一个整数，要么是一个列表；该列表的元素也可能是整数或者是其他列表。请你实现一个迭代器将其扁平化，使之能够遍历这个列表中的所有整数。
实现扁平迭代器类 NestedIterator ：
NestedIterator(List<NestedInteger> nestedList) 用嵌套列表 nestedList 初始化迭代器。
int next() 返回嵌套列表的下一个整数。
boolean hasNext() 如果仍然存在待迭代的整数，返回 true ；否则，返回 false 。
你的代码将会用下述伪代码检测：
    
    # 
    initialize iterator with nestedList
    res = []
    while iterator.hasNext()
        append iterator.next() to the end of res
    return res

如果 res 与预期的扁平化列表匹配，那么你的代码将会被判为正确。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 递归，将NestedInteger列表中的整数加入列表，将NestedInteger列表中的列表递归出整数加入列表。
    
    # 
    class NestedIterator:
        def __init__(self, nestedList: [NestedInteger]):
            self.res = []
            self.index = 0
            def dfs(nestedList):
                for n in nestedList:
                    if n.isInteger():
                        self.res.append(n.getInteger())
                    else:
                        tmp_list = n.getList()
                        for l in tmp_list:
                            if l.isInteger():
                                self.res.append(l.getInteger())
                            else:
                                dfs(l.getList())
    
            dfs(nestedList)
            self.length = len(self.res)
    
    
        def next(self) -> int:
            data = self.res[self.index]
            self.index += 1
            return data
    
    
        def hasNext(self) -> bool:
            return self.index < self.length                   
    
#### 2. 非递归
思路：
                                           
## 429. N 叉树的层序遍历
题目：给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。
树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 二叉树层次遍历，改造一下即可。

    # 
    def levelOrder(self, root: 'Node') -> List[List[int]]:

        if not root:
            return []

        res = []
        queue = [root]
        while queue:
            res.append([q.val for q in queue])
            l = []
            for q in queue:
                # if q.left:
                #     l.append(q.left)
                # if q.right:
                #     l.append(q.right)
                for c in q.children:
                    l.append(c)
            queue = l

        return res
    
#### 2. 非递归
思路：         
    
## 437. 路径总和 III
题目：给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。
路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 前缀和

    # 
    def pathSum(self, root: TreeNode, targetSum: int) -> int:

        if not root:
            return 0

        res = 0
        def dfs(root, preSum):
            nonlocal res
            if not root:
                return
            for i in range(len(preSum)):
                preSum[i] += root.val
            preSum.append(root.val)
            for i in preSum:
                if i == targetSum:
                    res += 1
            dfs(root.left, preSum[:])
            dfs(root.right, preSum[:])

        dfs(root, [])
        return res
    
#### 2. 非递归
思路：       
    
## 449. 序列化和反序列化二叉搜索树
题目：序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。
设计一个算法来序列化和反序列化 二叉搜索树 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。
编码的字符串应尽可能紧凑。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路: 序列化前序，反序列化时由前序得到中序，然后前序，中序构建二叉树。

    # 
    def pathSum(self, root: TreeNode, targetSum: int) -> int:

        if not root:
            return 0

        res = 0
        def dfs(root, preSum):
            nonlocal res
            if not root:
                return
            for i in range(len(preSum)):
                preSum[i] += root.val
            preSum.append(root.val)
            for i in preSum:
                if i == targetSum:
                    res += 1
            dfs(root.left, preSum[:])
            dfs(root.right, preSum[:])

        dfs(root, [])
        return resclass Codec:

    def serialize(self, root: TreeNode) -> str:
        """Encodes a tree to a single string.
        """
        str1 = ''
        def dfs(root):
            nonlocal str1
            if not root:
                return
            str1 += ' ' + str(root.val)
            dfs(root.left)
            dfs(root.right)
        dfs(root)
        return str1
        

    def deserialize(self, data: str) -> TreeNode:
        """Decodes your encoded data to tree.
        """
        preOrder = []
        for d in data.split(' '):
            if d:
                preOrder.append(int(d))
        inOrder = [p for p in preOrder]
        inOrder.sort()

        # 前序、中序构建二叉树
        def dfs(preOrder, inOrder):
            if not preOrder or not inOrder:
                return
            root = TreeNode(preOrder[0])
            index = inOrder.index(preOrder[0])
            root.left = dfs(preOrder[1:index+1], inOrder[0:index])
            root.right = dfs(preOrder[index+1:], inOrder[index+1:])
            return root

        return dfs(preOrder, inOrder)
    
#### 2. 非递归
思路：       
     
