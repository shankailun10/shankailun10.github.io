# leetcode题解
1. TOC
{:toc}

## 101. 对称二叉树
题目：给定一个二叉树，检查它是否是镜像对称的。
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归

#### 2. 非递归
思路：判断根是否为空，是返回True, 否判断左右两个孩子是否相等，是继续判断左孩子的左节点和右孩子的右节点是否相等，以及左孩子的右节点和右孩子的左节点是否相等

    #队列代码
    def getRes(root):
        if not root:
            return True
        queue = [(root.left, root.right)]
        while queue != []:
            left, right = queue.pop()
            if not left and not right:
                continue
            if left and right and left.val == right.val:
                queue.append((left.left, right.right))
                queue.append((left.right, right.left))
            else:
                return False
        return True
        
## 102. 二叉树的层序遍历
题目：给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1、递归

#### 2. 非递归
思路：若根为空，返回[]，若根不空将根入队列queue，然后依次遍历队列中的节点值存入res，然后依次遍历队列中的节点，把该节点的左节点、右节点依次入子队列l1，将子队列l1赋值给queue,返回res。

    # 代码
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        res, queue = [], [root]
        while queue:
            res.append([q.val for q in queue])
            l1 = []
            for q in queue:
                if q.left:
                    l1.append(q.left)
                if q.right:
                    l1.append(q.right)
            queue = l1
        return res
        

## 100. 相同的树
题目：给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
### 两种方法：1、递归实现，2. 非递归实现(队列)
####1. 递归
思路：比较根节点是否相等，然后递归比较左子树节点和右子树节点是否相等。

    # 代码
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        if not p and not q:
            return True
        elif not p or not q:
            return False
        elif p.val != q.val:
            return False
        else:
            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)

####2. 非递归
思路：同时遍历两棵树，依次比较节点值，若当前左子树或右子树为空时也入队列。

## 104. 二叉树最大深度
给定一个二叉树，找出其最大深度。
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明: 叶子节点是指没有子节点的节点。
### 两种方法：1、递归实现，2. 非递归实现(队列)
####1. 递归
思路：若根为空，返回0，若根不空，则最大深度为左子树最大深度和右子树最大深度取最大值+1

    # 代码
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        l = self.maxDepth(root.left)
        r = self.maxDepth(root.right)
        return max(l, r) + 1

### 2. 非递归
思路：二叉树层次遍历，返回数组长度。

## 108. 将有序数组转换为二叉搜索树
题目：给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。
高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：取数组中间位置做根，中间位置的左边部分构建左子树，右边部分构建右子树。

    # 代码
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        def mark_tree(s, e):
            if s > e:
                return None
            mid = (s + e) // 2
            sub_tree = TreeNode(nums[mid])
            sub_tree.left = mark_tree(s, mid - 1)
            sub_tree.right = mark_tree(mid + 1, e)
            return sub_tree
        return mark_tree(0, len(nums) - 1)

#### 2. 非递归
思路：

## 110. 平衡二叉树
题目：给定一个二叉树，判断它是否是高度平衡的二叉树。
本题中，一棵高度平衡二叉树定义为：
一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：若根为空，返回True,判断根的左右子树高度差绝对值是否<=1，否：返回False,依次判断根的左子树、右子树是否是平衡树

    # 代码
    def isBalanced(self, root: TreeNode) -> bool:
        def maxDepth(node):
            if not node:
                return 0
            l = maxDepth(node.left)
            r = maxDepth(node.right)
            return max(l, r) + 1

        if not root:
            return True
        return abs(maxDepth(root.left) - maxDepth(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)

#### 2. 非递归
思路：

## 111. 二叉树的最小深度
题目：给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。说明：叶子节点是指没有子节点的节点。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：层序遍历二叉树，记录深度，遇到某个节点没有左子树或右子树直接返回深度即可。

    # 代码
    def minDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        queue = [root]
        depth = 1
        while queue:
            l1 = []
            for q in queue:
                if not q.left and not q.right:
                    return depth
                if q.left:
                    l1.append(q.left)
                if q.right:
                    l1.append(q.right)
            queue = l1
            depth += 1
        return depth

#### 2. 非递归
思路：

## 112. 路径总和
题目：给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：深度优先遍历，判断当前节点是否是叶子结点并且路径和是否等于给定值，若是则返回true,否则返回false

    # 代码
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if not root:
            return targetSum == 0

        if not root.left and not root.right and root.val == targetSum:
            return True
        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)

#### 2. 非递归
思路：

## 144. 二叉树的前序遍历
题目：给你二叉树的根节点 root ，返回它节点值的 前序 遍历。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：深度优先遍历，一次打印节点值

    # 代码
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        
        res = []

        def dfs(node):
            if not node:
                return None
            res.append(node.val)
            dfs(node.left)
            dfs(node.right)
        
        dfs(root)
        return res

#### 2. 非递归
思路：

## 144. 二叉树的后序遍历
题目：给定一个二叉树，返回它的 后序 遍历。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：深度优先遍历，一次打印节点值

    # 代码
    def postorderTraversal(self, root: TreeNode) -> List[int]:

        res = []

        def dfs(node):
            if not node:
                return
            dfs(node.left)
            dfs(node.right)
            res.append(node.val)
        
        dfs(root)
        return res

#### 2. 非递归
思路：

## 226. 翻转二叉树
题目：翻转一棵二叉树。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：递归遍历根节点，交换左右节点值，遍历左子树，遍历🈶右子树，返回根节点。

    # 代码
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return None
        root.left, root.right = root.right, root.left
        self.invertTree(root.left)
        self.invertTree(root.right)
        return root

#### 2. 非递归
思路：



## 235. 二叉搜索树的最近公共祖先
题目：给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：由于是二叉搜索树，最近公共祖先的值一定在p,q值的中间，因此可遍历二叉搜索树，寻找在中间的节点。

    # 代码
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if p.val < root.val and q.val < root.val:
            return self.lowestCommonAncestor(root.left, p, q)
        elif p.val > root.val and q.val >root.val:
            return self.lowestCommonAncestor(root.right, p, q)
        else:
            return root

#### 2. 非递归
思路：

## 257. 二叉树的所有路径
题目：给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。叶子节点 是指没有子节点的节点。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：深度优先遍历，遍历时记录当前路径即可。

    # 代码
    def binaryTreePaths(self, root: TreeNode) -> List[str]:

        res = []
    
        def dfs(root, path):
            if not root:
                return
            if not root.left and not root.right:
                path += (str(root.val))
            else:
                path += (str(root.val) + '->')
            if not root.left and not root.right:
                res.append(path)
            dfs(root.left, path)
            dfs(root.right, path)
        
        dfs(root, '')
        return res

#### 2. 非递归
思路：

## 404. 左叶子之和
题目：计算给定二叉树的所有左叶子之和。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：深度优先遍历，遍历时记录当前路径即可。

    # 代码
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        
        self.num = 0

        def dfs(root, flag):
            if not root:
                return
            if not root.left and not root.right and flag == 1:
                self.num += root.val
            dfs(root.left, 1)
            dfs(root.right, 0)
        
        dfs(root, 0)
        
        return self.num

#### 2. 非递归
思路：

## 501. 二叉搜索树中的众数
题目：给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。
假定 BST 有如下定义：
结点左子树中所含结点的值小于等于当前结点的值
结点右子树中所含结点的值大于等于当前结点的值
左子树和右子树都是二叉搜索树
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：中序遍历，边遍历边记录当前出现最大值即可。

    # 代码
    def findMode(self, root: TreeNode) -> List[int]:

        self.res = []
        self.pre = None  # 前一个节点
        self.current_count = 0 # 当前节点重复数量
        self.max_count = 0 # 当前最大数量

        def dfs(root):
            if not root:
                return 
            dfs(root.left)
            if self.pre and self.pre.val == root.val:
                self.current_count += 1
            else:
                self.current_count = 1
            self.pre = root
            if self.current_count == self.max_count:
                self.res.append(root.val)
            elif self.current_count > self.max_count:
                self.max_count = self.current_count
                self.res.clear()
                self.res.append(root.val)

            dfs(root.right)
        
        dfs(root)
        return self.res

#### 2. 非递归
思路：

## 530. 二叉搜索树的最小绝对差
题目：给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：中序遍历，拿当前节点和前一节点比较求出最小值即可。

    # 代码
    def getMinimumDifference(self, root: TreeNode) -> int:

        value = float('inf')
        pre = None

        def dfs(root):
            nonlocal value, pre
            if not root:
                return 
            dfs(root.left)
            if pre and abs(pre.val - root.val) < value:
                value = abs(pre.val - root.val)
            pre = root
            dfs(root.right)

        dfs(root)
        return value

#### 2. 非递归
思路：

## 543. 二叉树的直径
题目：给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：求以每个节点为根节点的最大高度，记录最大值即可。

    # 代码
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        max_v = 0

        def depth(root):
            nonlocal max_v
            if not root:
                return 0
            l = depth(root.left)
            r = depth(root.right)
            max_v = max(max_v, l+r+1)
            return max(l, r) + 1

        depth(root)
        return max_v-1

#### 2. 非递归
思路：

## 559. N 叉树的最大深度
题目：给定一个 N 叉树，找到其最大深度。最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。
N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：若根为空，返回高度为0，若根的所有children子节点为空（根是叶子节点），返回高度为1；递归求出每一个子节点树的高度，得出最大值即可。

    # 代码
    def maxDepth(self, root: 'Node') -> int:

        def dfs(root):
            nonlocal max_d
            if not root:
                return 0
            if not root.children:
                return 1
            height = []
            for cl in root.children:
                height.append(dfs(cl))
            return max(height) + 1

        max_d = dfs(root)
        return max_d

#### 2. 非递归
思路：

## 563. 二叉树的坡度
题目：给定一个二叉树，计算 整个树 的坡度 。
一个树的 节点的坡度 定义即为，该节点左子树的节点之和和右子树节点之和的 差的绝对值 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。
整个树 的坡度就是其所有节点的坡度之和。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：求以某个节点为根节点的的树的值总和，即左节点总和+右节点总和+自身值，其中，左节点总和和右节点总和差的绝对值即为当前节点的坡度，对所有节点求坡度然后做加和即为树的坡度。

    # 代码
    def findTilt(self, root: TreeNode) -> int:
        res = 0

        # 求以某个节点为根的总和
        def getNodeSum(root):
            nonlocal res
            if not root:
                return 0
            ls = getNodeSum(root.left)
            rs = getNodeSum(root.right)
            res += abs(ls - rs)
            return ls+rs+root.val

        getNodeSum(root)

        return res

#### 2. 非递归
思路：

## 572. 另一棵树的子树
题目：给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。
二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：遍历root每一个节点，以每个子节点树为根判断是否是相同的树。

    # 代码
    def isSubtree(self, root: TreeNode, subRoot: TreeNode) -> bool:

        # 以p, q 为根节点的两颗二叉树是否为相同的树
        def isSambleTree(p, q):
            if not p and not q:
                return True
            elif not q or not p:
                return False
            elif p.val != q.val:
                return False
            else:
                return isSambleTree(p.left, q.left) and isSambleTree(p.right, q.right)
        
        # 遍历root树，并判断是否为相同的树
        def dfs(root, subRoot):
            if not root and not subRoot:
                return True
            if not root or not subRoot:
                return False
            else:
                return isSambleTree(root, subRoot) or dfs(root.left, subRoot) or dfs(root.right, subRoot)

        # 法2
        def dfs2(root, subRoot):
            if not root:
                return False
            if root.val == subRoot.val:
                if isSambleTree(root, subRoot):
                    return True
        
            return dfs2(root.left, subRoot) or dfs2(root.right, subRoot)
        
        return dfs2(root, subRoot)

#### 2. 非递归
思路：

## 589. N 叉树的前序遍历
题目：给定一个 N 叉树，返回其节点值的 前序遍历 。N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。
进阶：递归法很简单，你可以使用迭代法完成此题吗?
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：依次遍历即可。

    # 代码
    def preorder(self, root: 'Node') -> List[int]:
        res = []

        def dfs(root):
            nonlocal res
            if not root:
                return 
            res.append(root.val)
            for cl in root.children:
                dfs(cl)
        
        dfs(root)
        return res


#### 2. 非递归
思路：

## 590. N 叉树的后序遍历
题目：给定一个 N 叉树，返回其节点值的 后序遍历 。N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。
进阶：递归法很简单，你可以使用迭代法完成此题吗?
### 两种方法：1、递归实现，2. 非递归实现(队列)
#### 1. 递归
思路：依次遍历即可。

    # 代码
    def postorder(self, root: 'Node') -> List[int]:

        res = []

        def dfs(root):
            nonlocal res
            if not root:
                return 
            for cl in root.children:
                dfs(cl)
            res.append(root.val)

        dfs(root)
        return res


#### 2. 非递归
思路：



