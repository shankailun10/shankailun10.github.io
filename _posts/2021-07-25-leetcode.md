# leetcodeé¢˜è§£
1. TOC
{:toc}

## 101. å¯¹ç§°äºŒå‰æ ‘
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ£€æŸ¥å®ƒæ˜¯å¦æ˜¯é•œåƒå¯¹ç§°çš„ã€‚
ä¾‹å¦‚ï¼ŒäºŒå‰æ ‘ [1,2,2,3,4,4,3] æ˜¯å¯¹ç§°çš„ã€‚ä½†æ˜¯ä¸‹é¢è¿™ä¸ª [1,2,2,null,3,null,3] åˆ™ä¸æ˜¯é•œåƒå¯¹ç§°çš„:

### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’

#### 2. éé€’å½’
æ€è·¯ï¼šåˆ¤æ–­æ ¹æ˜¯å¦ä¸ºç©ºï¼Œæ˜¯è¿”å›True, å¦åˆ¤æ–­å·¦å³ä¸¤ä¸ªå­©å­æ˜¯å¦ç›¸ç­‰ï¼Œæ˜¯ç»§ç»­åˆ¤æ–­å·¦å­©å­çš„å·¦èŠ‚ç‚¹å’Œå³å­©å­çš„å³èŠ‚ç‚¹æ˜¯å¦ç›¸ç­‰ï¼Œä»¥åŠå·¦å­©å­çš„å³èŠ‚ç‚¹å’Œå³å­©å­çš„å·¦èŠ‚ç‚¹æ˜¯å¦ç›¸ç­‰

    #é˜Ÿåˆ—ä»£ç 
    def getRes(root):
        if not root:
            return True
        queue = [(root.left, root.right)]
        while queue != []:
            left, right = queue.pop()
            if not left and not right:
                continue
            if left and right and left.val == right.val:
                queue.append((left.left, right.right))
                queue.append((left.right, right.left))
            else:
                return False
        return True
        
## 102. äºŒå‰æ ‘çš„å±‚åºéå†
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¯·ä½ è¿”å›å…¶æŒ‰ å±‚åºéå† å¾—åˆ°çš„èŠ‚ç‚¹å€¼ã€‚ ï¼ˆå³é€å±‚åœ°ï¼Œä»å·¦åˆ°å³è®¿é—®æ‰€æœ‰èŠ‚ç‚¹ï¼‰ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1ã€é€’å½’

#### 2. éé€’å½’
æ€è·¯ï¼šè‹¥æ ¹ä¸ºç©ºï¼Œè¿”å›[]ï¼Œè‹¥æ ¹ä¸ç©ºå°†æ ¹å…¥é˜Ÿåˆ—queueï¼Œç„¶åä¾æ¬¡éå†é˜Ÿåˆ—ä¸­çš„èŠ‚ç‚¹å€¼å­˜å…¥resï¼Œç„¶åä¾æ¬¡éå†é˜Ÿåˆ—ä¸­çš„èŠ‚ç‚¹ï¼ŒæŠŠè¯¥èŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹ã€å³èŠ‚ç‚¹ä¾æ¬¡å…¥å­é˜Ÿåˆ—l1ï¼Œå°†å­é˜Ÿåˆ—l1èµ‹å€¼ç»™queue,è¿”å›resã€‚

    # ä»£ç 
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        res, queue = [], [root]
        while queue:
            res.append([q.val for q in queue])
            l1 = []
            for q in queue:
                if q.left:
                    l1.append(q.left)
                if q.right:
                    l1.append(q.right)
            queue = l1
        return res
        

## 100. ç›¸åŒçš„æ ‘
é¢˜ç›®ï¼šç»™ä½ ä¸¤æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ p å’Œ q ï¼Œç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥æ£€éªŒè¿™ä¸¤æ£µæ ‘æ˜¯å¦ç›¸åŒã€‚å¦‚æœä¸¤ä¸ªæ ‘åœ¨ç»“æ„ä¸Šç›¸åŒï¼Œå¹¶ä¸”èŠ‚ç‚¹å…·æœ‰ç›¸åŒçš„å€¼ï¼Œåˆ™è®¤ä¸ºå®ƒä»¬æ˜¯ç›¸åŒçš„ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
####1. é€’å½’
æ€è·¯ï¼šæ¯”è¾ƒæ ¹èŠ‚ç‚¹æ˜¯å¦ç›¸ç­‰ï¼Œç„¶åé€’å½’æ¯”è¾ƒå·¦å­æ ‘èŠ‚ç‚¹å’Œå³å­æ ‘èŠ‚ç‚¹æ˜¯å¦ç›¸ç­‰ã€‚

    # ä»£ç 
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        if not p and not q:
            return True
        elif not p or not q:
            return False
        elif p.val != q.val:
            return False
        else:
            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)

####2. éé€’å½’
æ€è·¯ï¼šåŒæ—¶éå†ä¸¤æ£µæ ‘ï¼Œä¾æ¬¡æ¯”è¾ƒèŠ‚ç‚¹å€¼ï¼Œè‹¥å½“å‰å·¦å­æ ‘æˆ–å³å­æ ‘ä¸ºç©ºæ—¶ä¹Ÿå…¥é˜Ÿåˆ—ã€‚

## 104. äºŒå‰æ ‘æœ€å¤§æ·±åº¦
ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾å‡ºå…¶æœ€å¤§æ·±åº¦ã€‚
äºŒå‰æ ‘çš„æ·±åº¦ä¸ºæ ¹èŠ‚ç‚¹åˆ°æœ€è¿œå¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°ã€‚è¯´æ˜: å¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
####1. é€’å½’
æ€è·¯ï¼šè‹¥æ ¹ä¸ºç©ºï¼Œè¿”å›0ï¼Œè‹¥æ ¹ä¸ç©ºï¼Œåˆ™æœ€å¤§æ·±åº¦ä¸ºå·¦å­æ ‘æœ€å¤§æ·±åº¦å’Œå³å­æ ‘æœ€å¤§æ·±åº¦å–æœ€å¤§å€¼+1

    # ä»£ç 
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        l = self.maxDepth(root.left)
        r = self.maxDepth(root.right)
        return max(l, r) + 1

### 2. éé€’å½’
æ€è·¯ï¼šäºŒå‰æ ‘å±‚æ¬¡éå†ï¼Œè¿”å›æ•°ç»„é•¿åº¦ã€‚

## 108. å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œå…¶ä¸­å…ƒç´ å·²ç»æŒ‰ å‡åº æ’åˆ—ï¼Œè¯·ä½ å°†å…¶è½¬æ¢ä¸ºä¸€æ£µ é«˜åº¦å¹³è¡¡ äºŒå‰æœç´¢æ ‘ã€‚
é«˜åº¦å¹³è¡¡ äºŒå‰æ ‘æ˜¯ä¸€æ£µæ»¡è¶³ã€Œæ¯ä¸ªèŠ‚ç‚¹çš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡ 1 ã€çš„äºŒå‰æ ‘ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šå–æ•°ç»„ä¸­é—´ä½ç½®åšæ ¹ï¼Œä¸­é—´ä½ç½®çš„å·¦è¾¹éƒ¨åˆ†æ„å»ºå·¦å­æ ‘ï¼Œå³è¾¹éƒ¨åˆ†æ„å»ºå³å­æ ‘ã€‚

    # ä»£ç 
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        def mark_tree(s, e):
            if s > e:
                return None
            mid = (s + e) // 2
            sub_tree = TreeNode(nums[mid])
            sub_tree.left = mark_tree(s, mid - 1)
            sub_tree.right = mark_tree(mid + 1, e)
            return sub_tree
        return mark_tree(0, len(nums) - 1)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 110. å¹³è¡¡äºŒå‰æ ‘
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œåˆ¤æ–­å®ƒæ˜¯å¦æ˜¯é«˜åº¦å¹³è¡¡çš„äºŒå‰æ ‘ã€‚
æœ¬é¢˜ä¸­ï¼Œä¸€æ£µé«˜åº¦å¹³è¡¡äºŒå‰æ ‘å®šä¹‰ä¸ºï¼š
ä¸€ä¸ªäºŒå‰æ ‘æ¯ä¸ªèŠ‚ç‚¹ çš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡ 1 
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šè‹¥æ ¹ä¸ºç©ºï¼Œè¿”å›True,åˆ¤æ–­æ ¹çš„å·¦å³å­æ ‘é«˜åº¦å·®ç»å¯¹å€¼æ˜¯å¦<=1ï¼Œå¦ï¼šè¿”å›False,ä¾æ¬¡åˆ¤æ–­æ ¹çš„å·¦å­æ ‘ã€å³å­æ ‘æ˜¯å¦æ˜¯å¹³è¡¡æ ‘

    # ä»£ç 
    def isBalanced(self, root: TreeNode) -> bool:
        def maxDepth(node):
            if not node:
                return 0
            l = maxDepth(node.left)
            r = maxDepth(node.right)
            return max(l, r) + 1

        if not root:
            return True
        return abs(maxDepth(root.left) - maxDepth(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 111. äºŒå‰æ ‘çš„æœ€å°æ·±åº¦
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾å‡ºå…¶æœ€å°æ·±åº¦ã€‚æœ€å°æ·±åº¦æ˜¯ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿‘å¶å­èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°é‡ã€‚è¯´æ˜ï¼šå¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šå±‚åºéå†äºŒå‰æ ‘ï¼Œè®°å½•æ·±åº¦ï¼Œé‡åˆ°æŸä¸ªèŠ‚ç‚¹æ²¡æœ‰å·¦å­æ ‘æˆ–å³å­æ ‘ç›´æ¥è¿”å›æ·±åº¦å³å¯ã€‚

    # ä»£ç 
    def minDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        queue = [root]
        depth = 1
        while queue:
            l1 = []
            for q in queue:
                if not q.left and not q.right:
                    return depth
                if q.left:
                    l1.append(q.left)
                if q.right:
                    l1.append(q.right)
            queue = l1
            depth += 1
        return depth

#### 2. éé€’å½’
æ€è·¯ï¼š

## 112. è·¯å¾„æ€»å’Œ
é¢˜ç›®ï¼šç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹Â root å’Œä¸€ä¸ªè¡¨ç¤ºç›®æ ‡å’Œçš„æ•´æ•°Â targetSum ï¼Œåˆ¤æ–­è¯¥æ ‘ä¸­æ˜¯å¦å­˜åœ¨ æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹ çš„è·¯å¾„ï¼Œè¿™æ¡è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹å€¼ç›¸åŠ ç­‰äºç›®æ ‡å’ŒÂ targetSum ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šæ·±åº¦ä¼˜å…ˆéå†ï¼Œåˆ¤æ–­å½“å‰èŠ‚ç‚¹æ˜¯å¦æ˜¯å¶å­ç»“ç‚¹å¹¶ä¸”è·¯å¾„å’Œæ˜¯å¦ç­‰äºç»™å®šå€¼ï¼Œè‹¥æ˜¯åˆ™è¿”å›true,å¦åˆ™è¿”å›false

    # ä»£ç 
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if not root:
            return targetSum == 0

        if not root.left and not root.right and root.val == targetSum:
            return True
        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 144. äºŒå‰æ ‘çš„å‰åºéå†
é¢˜ç›®ï¼šç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å›å®ƒèŠ‚ç‚¹å€¼çš„ å‰åº éå†ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šæ·±åº¦ä¼˜å…ˆéå†ï¼Œä¸€æ¬¡æ‰“å°èŠ‚ç‚¹å€¼

    # ä»£ç 
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        
        res = []

        def dfs(node):
            if not node:
                return None
            res.append(node.val)
            dfs(node.left)
            dfs(node.right)
        
        dfs(root)
        return res

#### 2. éé€’å½’
æ€è·¯ï¼š

## 144. äºŒå‰æ ‘çš„ååºéå†
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¿”å›å®ƒçš„ ååº éå†ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šæ·±åº¦ä¼˜å…ˆéå†ï¼Œä¸€æ¬¡æ‰“å°èŠ‚ç‚¹å€¼

    # ä»£ç 
    def postorderTraversal(self, root: TreeNode) -> List[int]:

        res = []

        def dfs(node):
            if not node:
                return
            dfs(node.left)
            dfs(node.right)
            res.append(node.val)
        
        dfs(root)
        return res

#### 2. éé€’å½’
æ€è·¯ï¼š

## 226. ç¿»è½¬äºŒå‰æ ‘
é¢˜ç›®ï¼šç¿»è½¬ä¸€æ£µäºŒå‰æ ‘ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šé€’å½’éå†æ ¹èŠ‚ç‚¹ï¼Œäº¤æ¢å·¦å³èŠ‚ç‚¹å€¼ï¼Œéå†å·¦å­æ ‘ï¼Œéå†ğŸˆ¶å³å­æ ‘ï¼Œè¿”å›æ ¹èŠ‚ç‚¹ã€‚

    # ä»£ç 
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return None
        root.left, root.right = root.right, root.left
        self.invertTree(root.left)
        self.invertTree(root.right)
        return root

#### 2. éé€’å½’
æ€è·¯ï¼š



## 235. äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æœç´¢æ ‘, æ‰¾åˆ°è¯¥æ ‘ä¸­ä¸¤ä¸ªæŒ‡å®šèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚
ç™¾åº¦ç™¾ç§‘ä¸­æœ€è¿‘å…¬å…±ç¥–å…ˆçš„å®šä¹‰ä¸ºï¼šâ€œå¯¹äºæœ‰æ ¹æ ‘ T çš„ä¸¤ä¸ªç»“ç‚¹ pã€qï¼Œæœ€è¿‘å…¬å…±ç¥–å…ˆè¡¨ç¤ºä¸ºä¸€ä¸ªç»“ç‚¹ xï¼Œæ»¡è¶³ x æ˜¯ pã€q çš„ç¥–å…ˆä¸” x çš„æ·±åº¦å°½å¯èƒ½å¤§ï¼ˆä¸€ä¸ªèŠ‚ç‚¹ä¹Ÿå¯ä»¥æ˜¯å®ƒè‡ªå·±çš„ç¥–å…ˆï¼‰ã€‚â€
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šç”±äºæ˜¯äºŒå‰æœç´¢æ ‘ï¼Œæœ€è¿‘å…¬å…±ç¥–å…ˆçš„å€¼ä¸€å®šåœ¨p,qå€¼çš„ä¸­é—´ï¼Œå› æ­¤å¯éå†äºŒå‰æœç´¢æ ‘ï¼Œå¯»æ‰¾åœ¨ä¸­é—´çš„èŠ‚ç‚¹ã€‚

    # ä»£ç 
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if p.val < root.val and q.val < root.val:
            return self.lowestCommonAncestor(root.left, p, q)
        elif p.val > root.val and q.val >root.val:
            return self.lowestCommonAncestor(root.right, p, q)
        else:
            return root

#### 2. éé€’å½’
æ€è·¯ï¼š

## 257. äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼ŒæŒ‰ ä»»æ„é¡ºåº ï¼Œè¿”å›æ‰€æœ‰ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ã€‚å¶å­èŠ‚ç‚¹ æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šæ·±åº¦ä¼˜å…ˆéå†ï¼Œéå†æ—¶è®°å½•å½“å‰è·¯å¾„å³å¯ã€‚

    # ä»£ç 
    def binaryTreePaths(self, root: TreeNode) -> List[str]:

        res = []
    
        def dfs(root, path):
            if not root:
                return
            if not root.left and not root.right:
                path += (str(root.val))
            else:
                path += (str(root.val) + '->')
            if not root.left and not root.right:
                res.append(path)
            dfs(root.left, path)
            dfs(root.right, path)
        
        dfs(root, '')
        return res

#### 2. éé€’å½’
æ€è·¯ï¼š

## 404. å·¦å¶å­ä¹‹å’Œ
é¢˜ç›®ï¼šè®¡ç®—ç»™å®šäºŒå‰æ ‘çš„æ‰€æœ‰å·¦å¶å­ä¹‹å’Œã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šæ·±åº¦ä¼˜å…ˆéå†ï¼Œéå†æ—¶è®°å½•å½“å‰è·¯å¾„å³å¯ã€‚

    # ä»£ç 
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        
        self.num = 0

        def dfs(root, flag):
            if not root:
                return
            if not root.left and not root.right and flag == 1:
                self.num += root.val
            dfs(root.left, 1)
            dfs(root.right, 0)
        
        dfs(root, 0)
        
        return self.num

#### 2. éé€’å½’
æ€è·¯ï¼š

## 501. äºŒå‰æœç´¢æ ‘ä¸­çš„ä¼—æ•°
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªæœ‰ç›¸åŒå€¼çš„äºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰ï¼Œæ‰¾å‡º BST ä¸­çš„æ‰€æœ‰ä¼—æ•°ï¼ˆå‡ºç°é¢‘ç‡æœ€é«˜çš„å…ƒç´ ï¼‰ã€‚
å‡å®š BST æœ‰å¦‚ä¸‹å®šä¹‰ï¼š
ç»“ç‚¹å·¦å­æ ‘ä¸­æ‰€å«ç»“ç‚¹çš„å€¼å°äºç­‰äºå½“å‰ç»“ç‚¹çš„å€¼
ç»“ç‚¹å³å­æ ‘ä¸­æ‰€å«ç»“ç‚¹çš„å€¼å¤§äºç­‰äºå½“å‰ç»“ç‚¹çš„å€¼
å·¦å­æ ‘å’Œå³å­æ ‘éƒ½æ˜¯äºŒå‰æœç´¢æ ‘
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šä¸­åºéå†ï¼Œè¾¹éå†è¾¹è®°å½•å½“å‰å‡ºç°æœ€å¤§å€¼å³å¯ã€‚

    # ä»£ç 
    def findMode(self, root: TreeNode) -> List[int]:

        self.res = []
        self.pre = None  # å‰ä¸€ä¸ªèŠ‚ç‚¹
        self.current_count = 0 # å½“å‰èŠ‚ç‚¹é‡å¤æ•°é‡
        self.max_count = 0 # å½“å‰æœ€å¤§æ•°é‡

        def dfs(root):
            if not root:
                return 
            dfs(root.left)
            if self.pre and self.pre.val == root.val:
                self.current_count += 1
            else:
                self.current_count = 1
            self.pre = root
            if self.current_count == self.max_count:
                self.res.append(root.val)
            elif self.current_count > self.max_count:
                self.max_count = self.current_count
                self.res.clear()
                self.res.append(root.val)

            dfs(root.right)
        
        dfs(root)
        return self.res

#### 2. éé€’å½’
æ€è·¯ï¼š

## 530. äºŒå‰æœç´¢æ ‘çš„æœ€å°ç»å¯¹å·®
é¢˜ç›®ï¼šç»™ä½ ä¸€æ£µæ‰€æœ‰èŠ‚ç‚¹ä¸ºéè´Ÿå€¼çš„äºŒå‰æœç´¢æ ‘ï¼Œè¯·ä½ è®¡ç®—æ ‘ä¸­ä»»æ„ä¸¤èŠ‚ç‚¹çš„å·®çš„ç»å¯¹å€¼çš„æœ€å°å€¼ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šä¸­åºéå†ï¼Œæ‹¿å½“å‰èŠ‚ç‚¹å’Œå‰ä¸€èŠ‚ç‚¹æ¯”è¾ƒæ±‚å‡ºæœ€å°å€¼å³å¯ã€‚

    # ä»£ç 
    def getMinimumDifference(self, root: TreeNode) -> int:

        value = float('inf')
        pre = None

        def dfs(root):
            nonlocal value, pre
            if not root:
                return 
            dfs(root.left)
            if pre and abs(pre.val - root.val) < value:
                value = abs(pre.val - root.val)
            pre = root
            dfs(root.right)

        dfs(root)
        return value

#### 2. éé€’å½’
æ€è·¯ï¼š

## 543. äºŒå‰æ ‘çš„ç›´å¾„
é¢˜ç›®ï¼šç»™å®šä¸€æ£µäºŒå‰æ ‘ï¼Œä½ éœ€è¦è®¡ç®—å®ƒçš„ç›´å¾„é•¿åº¦ã€‚ä¸€æ£µäºŒå‰æ ‘çš„ç›´å¾„é•¿åº¦æ˜¯ä»»æ„ä¸¤ä¸ªç»“ç‚¹è·¯å¾„é•¿åº¦ä¸­çš„æœ€å¤§å€¼ã€‚è¿™æ¡è·¯å¾„å¯èƒ½ç©¿è¿‡ä¹Ÿå¯èƒ½ä¸ç©¿è¿‡æ ¹ç»“ç‚¹ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šæ±‚ä»¥æ¯ä¸ªèŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„æœ€å¤§é«˜åº¦ï¼Œè®°å½•æœ€å¤§å€¼å³å¯ã€‚

    # ä»£ç 
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        max_v = 0

        def depth(root):
            nonlocal max_v
            if not root:
                return 0
            l = depth(root.left)
            r = depth(root.right)
            max_v = max(max_v, l+r+1)
            return max(l, r) + 1

        depth(root)
        return max_v-1

#### 2. éé€’å½’
æ€è·¯ï¼š

## 559. N å‰æ ‘çš„æœ€å¤§æ·±åº¦
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ª N å‰æ ‘ï¼Œæ‰¾åˆ°å…¶æœ€å¤§æ·±åº¦ã€‚æœ€å¤§æ·±åº¦æ˜¯æŒ‡ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿œå¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ€»æ•°ã€‚
N å‰æ ‘è¾“å…¥æŒ‰å±‚åºéå†åºåˆ—åŒ–è¡¨ç¤ºï¼Œæ¯ç»„å­èŠ‚ç‚¹ç”±ç©ºå€¼åˆ†éš”ï¼ˆè¯·å‚è§ç¤ºä¾‹ï¼‰ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šè‹¥æ ¹ä¸ºç©ºï¼Œè¿”å›é«˜åº¦ä¸º0ï¼Œè‹¥æ ¹çš„æ‰€æœ‰childrenå­èŠ‚ç‚¹ä¸ºç©ºï¼ˆæ ¹æ˜¯å¶å­èŠ‚ç‚¹ï¼‰ï¼Œè¿”å›é«˜åº¦ä¸º1ï¼›é€’å½’æ±‚å‡ºæ¯ä¸€ä¸ªå­èŠ‚ç‚¹æ ‘çš„é«˜åº¦ï¼Œå¾—å‡ºæœ€å¤§å€¼å³å¯ã€‚

    # ä»£ç 
    def maxDepth(self, root: 'Node') -> int:

        def dfs(root):
            nonlocal max_d
            if not root:
                return 0
            if not root.children:
                return 1
            height = []
            for cl in root.children:
                height.append(dfs(cl))
            return max(height) + 1

        max_d = dfs(root)
        return max_d

#### 2. éé€’å½’
æ€è·¯ï¼š

## 563. äºŒå‰æ ‘çš„å¡åº¦
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè®¡ç®— æ•´ä¸ªæ ‘ çš„å¡åº¦ ã€‚
ä¸€ä¸ªæ ‘çš„ èŠ‚ç‚¹çš„å¡åº¦ å®šä¹‰å³ä¸ºï¼Œè¯¥èŠ‚ç‚¹å·¦å­æ ‘çš„èŠ‚ç‚¹ä¹‹å’Œå’Œå³å­æ ‘èŠ‚ç‚¹ä¹‹å’Œçš„ å·®çš„ç»å¯¹å€¼ ã€‚å¦‚æœæ²¡æœ‰å·¦å­æ ‘çš„è¯ï¼Œå·¦å­æ ‘çš„èŠ‚ç‚¹ä¹‹å’Œä¸º 0 ï¼›æ²¡æœ‰å³å­æ ‘çš„è¯ä¹Ÿæ˜¯ä¸€æ ·ã€‚ç©ºç»“ç‚¹çš„å¡åº¦æ˜¯ 0 ã€‚
æ•´ä¸ªæ ‘ çš„å¡åº¦å°±æ˜¯å…¶æ‰€æœ‰èŠ‚ç‚¹çš„å¡åº¦ä¹‹å’Œã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šæ±‚ä»¥æŸä¸ªèŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„çš„æ ‘çš„å€¼æ€»å’Œï¼Œå³å·¦èŠ‚ç‚¹æ€»å’Œ+å³èŠ‚ç‚¹æ€»å’Œ+è‡ªèº«å€¼ï¼Œå…¶ä¸­ï¼Œå·¦èŠ‚ç‚¹æ€»å’Œå’Œå³èŠ‚ç‚¹æ€»å’Œå·®çš„ç»å¯¹å€¼å³ä¸ºå½“å‰èŠ‚ç‚¹çš„å¡åº¦ï¼Œå¯¹æ‰€æœ‰èŠ‚ç‚¹æ±‚å¡åº¦ç„¶ååšåŠ å’Œå³ä¸ºæ ‘çš„å¡åº¦ã€‚

    # ä»£ç 
    def findTilt(self, root: TreeNode) -> int:
        res = 0

        # æ±‚ä»¥æŸä¸ªèŠ‚ç‚¹ä¸ºæ ¹çš„æ€»å’Œ
        def getNodeSum(root):
            nonlocal res
            if not root:
                return 0
            ls = getNodeSum(root.left)
            rs = getNodeSum(root.right)
            res += abs(ls - rs)
            return ls+rs+root.val

        getNodeSum(root)

        return res

#### 2. éé€’å½’
æ€è·¯ï¼š

## 572. å¦ä¸€æ£µæ ‘çš„å­æ ‘
é¢˜ç›®ï¼šç»™ä½ ä¸¤æ£µäºŒå‰æ ‘ root å’Œ subRoot ã€‚æ£€éªŒ root ä¸­æ˜¯å¦åŒ…å«å’Œ subRoot å…·æœ‰ç›¸åŒç»“æ„å’ŒèŠ‚ç‚¹å€¼çš„å­æ ‘ã€‚å¦‚æœå­˜åœ¨ï¼Œè¿”å› true ï¼›å¦åˆ™ï¼Œè¿”å› false ã€‚
äºŒå‰æ ‘ tree çš„ä¸€æ£µå­æ ‘åŒ…æ‹¬ tree çš„æŸä¸ªèŠ‚ç‚¹å’Œè¿™ä¸ªèŠ‚ç‚¹çš„æ‰€æœ‰åä»£èŠ‚ç‚¹ã€‚tree ä¹Ÿå¯ä»¥çœ‹åšå®ƒè‡ªèº«çš„ä¸€æ£µå­æ ‘ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šéå†rootæ¯ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä»¥æ¯ä¸ªå­èŠ‚ç‚¹æ ‘ä¸ºæ ¹åˆ¤æ–­æ˜¯å¦æ˜¯ç›¸åŒçš„æ ‘ã€‚

    # ä»£ç 
    def isSubtree(self, root: TreeNode, subRoot: TreeNode) -> bool:

        # ä»¥p, q ä¸ºæ ¹èŠ‚ç‚¹çš„ä¸¤é¢—äºŒå‰æ ‘æ˜¯å¦ä¸ºç›¸åŒçš„æ ‘
        def isSambleTree(p, q):
            if not p and not q:
                return True
            elif not q or not p:
                return False
            elif p.val != q.val:
                return False
            else:
                return isSambleTree(p.left, q.left) and isSambleTree(p.right, q.right)
        
        # éå†rootæ ‘ï¼Œå¹¶åˆ¤æ–­æ˜¯å¦ä¸ºç›¸åŒçš„æ ‘
        def dfs(root, subRoot):
            if not root and not subRoot:
                return True
            if not root or not subRoot:
                return False
            else:
                return isSambleTree(root, subRoot) or dfs(root.left, subRoot) or dfs(root.right, subRoot)

        # æ³•2
        def dfs2(root, subRoot):
            if not root:
                return False
            if root.val == subRoot.val:
                if isSambleTree(root, subRoot):
                    return True
        
            return dfs2(root.left, subRoot) or dfs2(root.right, subRoot)
        
        return dfs2(root, subRoot)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 589. N å‰æ ‘çš„å‰åºéå†
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ª N å‰æ ‘ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„ å‰åºéå† ã€‚N å‰æ ‘ åœ¨è¾“å…¥ä¸­æŒ‰å±‚åºéå†è¿›è¡Œåºåˆ—åŒ–è¡¨ç¤ºï¼Œæ¯ç»„å­èŠ‚ç‚¹ç”±ç©ºå€¼ null åˆ†éš”ï¼ˆè¯·å‚è§ç¤ºä¾‹ï¼‰ã€‚
è¿›é˜¶ï¼šé€’å½’æ³•å¾ˆç®€å•ï¼Œä½ å¯ä»¥ä½¿ç”¨è¿­ä»£æ³•å®Œæˆæ­¤é¢˜å—?
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šä¾æ¬¡éå†å³å¯ã€‚

    # ä»£ç 
    def preorder(self, root: 'Node') -> List[int]:
        res = []

        def dfs(root):
            nonlocal res
            if not root:
                return 
            res.append(root.val)
            for cl in root.children:
                dfs(cl)
        
        dfs(root)
        return res


#### 2. éé€’å½’
æ€è·¯ï¼š

## 590. N å‰æ ‘çš„ååºéå†
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ª N å‰æ ‘ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„ ååºéå† ã€‚N å‰æ ‘ åœ¨è¾“å…¥ä¸­æŒ‰å±‚åºéå†è¿›è¡Œåºåˆ—åŒ–è¡¨ç¤ºï¼Œæ¯ç»„å­èŠ‚ç‚¹ç”±ç©ºå€¼ null åˆ†éš”ï¼ˆè¯·å‚è§ç¤ºä¾‹ï¼‰ã€‚
è¿›é˜¶ï¼šé€’å½’æ³•å¾ˆç®€å•ï¼Œä½ å¯ä»¥ä½¿ç”¨è¿­ä»£æ³•å®Œæˆæ­¤é¢˜å—?
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šä¾æ¬¡éå†å³å¯ã€‚

    # ä»£ç 
    def postorder(self, root: 'Node') -> List[int]:

        res = []

        def dfs(root):
            nonlocal res
            if not root:
                return 
            for cl in root.children:
                dfs(cl)
            res.append(root.val)

        dfs(root)
        return res


#### 2. éé€’å½’
æ€è·¯ï¼š

## 617. åˆå¹¶äºŒå‰æ ‘
é¢˜ç›®ï¼šç»™å®šä¸¤ä¸ªäºŒå‰æ ‘ï¼Œæƒ³è±¡å½“ä½ å°†å®ƒä»¬ä¸­çš„ä¸€ä¸ªè¦†ç›–åˆ°å¦ä¸€ä¸ªä¸Šæ—¶ï¼Œä¸¤ä¸ªäºŒå‰æ ‘çš„ä¸€äº›èŠ‚ç‚¹ä¾¿ä¼šé‡å ã€‚
ä½ éœ€è¦å°†ä»–ä»¬åˆå¹¶ä¸ºä¸€ä¸ªæ–°çš„äºŒå‰æ ‘ã€‚åˆå¹¶çš„è§„åˆ™æ˜¯å¦‚æœä¸¤ä¸ªèŠ‚ç‚¹é‡å ï¼Œé‚£ä¹ˆå°†ä»–ä»¬çš„å€¼ç›¸åŠ ä½œä¸ºèŠ‚ç‚¹åˆå¹¶åçš„æ–°å€¼ï¼Œå¦åˆ™ä¸ä¸ºÂ NULL çš„èŠ‚ç‚¹å°†ç›´æ¥ä½œä¸ºæ–°äºŒå‰æ ‘çš„èŠ‚ç‚¹ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šä¾æ¬¡éå†å³å¯ã€‚

    # ä»£ç 
    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:

        def dfs(root1, root2):
            if root1 and root2:
                root = TreeNode(root1.val + root2.val)
                root.left = dfs(root1.left, root2.left)
                root.right = dfs(root1.right, root2.right)
            elif root1:
                root = TreeNode(root1.val)
                root.left = dfs(root1.left, None)
                root.right = dfs(root1.right, None)
            elif root2:
                root = TreeNode(root2.val)
                root.left = dfs(root2.left, None)
                root.right = dfs(root2.right, None)
            else:
                root = None
                return 
            return root

        return dfs(root1, root2)


#### 2. éé€’å½’
æ€è·¯ï¼š

## 637. äºŒå‰æ ‘çš„å±‚å¹³å‡å€¼
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªéç©ºäºŒå‰æ ‘, è¿”å›ä¸€ä¸ªç”±æ¯å±‚èŠ‚ç‚¹å¹³å‡å€¼ç»„æˆçš„æ•°ç»„ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šå±‚åºéå†ï¼Œæ±‚æ¯å±‚å¹³å‡å€¼å³å¯ã€‚

    # ä»£ç 
    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:

        res = []
        queue = [root]
        while queue:
            res.append(sum([q.val for q in queue]) / len([q.val for q in queue]))
            l1 = []
            for q in queue:
                if q.left:
                    l1.append(q.left)
                if q.right:
                    l1.append(q.right)
            queue = l1
        return res


#### 2. éé€’å½’
æ€è·¯ï¼š

## 653. ä¸¤æ•°ä¹‹å’Œ IV - è¾“å…¥ BST
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æœç´¢æ ‘ root å’Œä¸€ä¸ªç›®æ ‡ç»“æœ kï¼Œå¦‚æœ BST ä¸­å­˜åœ¨ä¸¤ä¸ªå…ƒç´ ä¸”å®ƒä»¬çš„å’Œç­‰äºç»™å®šçš„ç›®æ ‡ç»“æœï¼Œåˆ™è¿”å› trueã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯ï¼šå±‚åºéå†ï¼Œæ±‚æ¯å±‚å¹³å‡å€¼å³å¯ã€‚

    # ä»£ç 
    def findTarget(self, root: TreeNode, k: int) -> bool:

        res = []

        def dfs(root):
            nonlocal res
            if not root:
                return
            dfs(root.left)
            res.append(root.val)
            dfs(root.right)

        dfs(root)

        l, r = 0, len(res)-1
        while l < r:
            if res[l] + res[r] == k:
                return True
            elif res[l] + res[r] > k:
                r -= 1
            else:
                l += 1
        return False

#### 2. éé€’å½’
æ€è·¯ï¼š

## 671. äºŒå‰æ ‘ä¸­ç¬¬äºŒå°çš„èŠ‚ç‚¹
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªéç©ºç‰¹æ®Šçš„äºŒå‰æ ‘ï¼Œæ¯ä¸ªèŠ‚ç‚¹éƒ½æ˜¯æ­£æ•°ï¼Œå¹¶ä¸”æ¯ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹æ•°é‡åªèƒ½ä¸ºÂ 2Â æˆ–Â 0ã€‚å¦‚æœä¸€ä¸ªèŠ‚ç‚¹æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹çš„è¯ï¼Œé‚£ä¹ˆè¯¥èŠ‚ç‚¹çš„å€¼ç­‰äºä¸¤ä¸ªå­èŠ‚ç‚¹ä¸­è¾ƒå°çš„ä¸€ä¸ªã€‚
æ›´æ­£å¼åœ°è¯´ï¼Œroot.val = min(root.left.val, root.right.val) æ€»æˆç«‹ã€‚ç»™å‡ºè¿™æ ·çš„ä¸€ä¸ªäºŒå‰æ ‘ï¼Œä½ éœ€è¦è¾“å‡ºæ‰€æœ‰èŠ‚ç‚¹ä¸­çš„ç¬¬äºŒå°çš„å€¼ã€‚å¦‚æœç¬¬äºŒå°çš„å€¼ä¸å­˜åœ¨çš„è¯ï¼Œè¾“å‡º -1 ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: å‰åºéå†ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸ç­‰äºæ ¹èŠ‚ç‚¹çš„å€¼è¿”å›å³å¯ã€‚

    # ä»£ç 
    def findSecondMinimumValue(self, root: TreeNode) -> int:
        min_v = root.val

        def dfs(root):
            if not root:
                return float('inf')
            if root.val != min_v:
                return root.val
            else:
                return min(dfs(root.left), dfs(root.right))

        return dfs(root) if dfs(root) != float('inf') else -1

#### 2. éé€’å½’
æ€è·¯ï¼š

## 700. äºŒå‰æœç´¢æ ‘ä¸­çš„æœç´¢
é¢˜ç›®ï¼šç»™å®šäºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰çš„æ ¹èŠ‚ç‚¹å’Œä¸€ä¸ªå€¼ã€‚ ä½ éœ€è¦åœ¨BSTä¸­æ‰¾åˆ°èŠ‚ç‚¹å€¼ç­‰äºç»™å®šå€¼çš„èŠ‚ç‚¹ã€‚ è¿”å›ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„å­æ ‘ã€‚ å¦‚æœèŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œåˆ™è¿”å› NULLã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: å‰åºéå†ï¼Œåˆ¤æ–­å½“å‰èŠ‚ç‚¹å’Œç»™å®šå€¼çš„å¤§å°ï¼Œè‹¥å¤§åˆ™éå†å·¦å­æ ‘ï¼Œå¦åˆ™å³å­æ ‘ã€‚

    # ä»£ç 
    def searchBST(self, root: TreeNode, val: int) -> TreeNode:

        def dfs(root):
            if not root:
                return -1
            if root.val == val:
                return root
            elif root.val > val:
                return dfs(root.left)
            else:
                return dfs(root.right)

        return dfs(root) if dfs(root)!= -1 else None

#### 2. éé€’å½’
æ€è·¯ï¼š

## 703. æ•°æ®æµä¸­çš„ç¬¬ K å¤§å…ƒç´ 
é¢˜ç›®ï¼šè®¾è®¡ä¸€ä¸ªæ‰¾åˆ°æ•°æ®æµä¸­ç¬¬ k å¤§å…ƒç´ çš„ç±»ï¼ˆclassï¼‰ã€‚æ³¨æ„æ˜¯æ’åºåçš„ç¬¬ k å¤§å…ƒç´ ï¼Œä¸æ˜¯ç¬¬ k ä¸ªä¸åŒçš„å…ƒç´ ã€‚
è¯·å®ç° KthLargestÂ ç±»ï¼š
KthLargest(int k, int[] nums) ä½¿ç”¨æ•´æ•° k å’Œæ•´æ•°æµ nums åˆå§‹åŒ–å¯¹è±¡ã€‚
int add(int val) å°† val æ’å…¥æ•°æ®æµ nums åï¼Œè¿”å›å½“å‰æ•°æ®æµä¸­ç¬¬ k å¤§çš„å…ƒç´ ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: 

    # ä»£ç 
    

#### 2. éé€’å½’
æ€è·¯ï¼š

## 783. äºŒå‰æœç´¢æ ‘èŠ‚ç‚¹æœ€å°è·ç¦»
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å› æ ‘ä¸­ä»»æ„ä¸¤ä¸åŒèŠ‚ç‚¹å€¼ä¹‹é—´çš„æœ€å°å·®å€¼ ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: ä¸­åºéå†ï¼Œè®°å½•æœ€å°å·®å€¼å³å¯ã€‚

    # ä»£ç 
    def minDiffInBST(self, root: TreeNode) -> int:

        min_v = float('inf')
        pre = None

        def dfs(root):
            nonlocal min_v, pre
            if not root:
                return
            dfs(root.left)
            if pre and abs(pre.val - root.val) < min_v:
                min_v = abs(pre.val - root.val)
            pre = root
            dfs(root.right)
        
        dfs(root)
        return min_v

#### 2. éé€’å½’
æ€è·¯ï¼š

## 872. å¶å­ç›¸ä¼¼çš„æ ‘
é¢˜ç›®ï¼šè¯·è€ƒè™‘ä¸€æ£µäºŒå‰æ ‘ä¸Šæ‰€æœ‰çš„å¶å­ï¼Œè¿™äº›å¶å­çš„å€¼æŒ‰ä»å·¦åˆ°å³çš„é¡ºåºæ’åˆ—å½¢æˆä¸€ä¸ª å¶å€¼åºåˆ— ã€‚
ä¸¾ä¸ªä¾‹å­ï¼Œå¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œç»™å®šä¸€æ£µå¶å€¼åºåˆ—ä¸ºÂ (6, 7, 4, 9, 8)Â çš„æ ‘ã€‚å¦‚æœæœ‰ä¸¤æ£µäºŒå‰æ ‘çš„å¶å€¼åºåˆ—æ˜¯ç›¸åŒï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±è®¤ä¸ºå®ƒä»¬æ˜¯Â å¶ç›¸ä¼¼Â çš„ã€‚
å¦‚æœç»™å®šçš„ä¸¤ä¸ªæ ¹ç»“ç‚¹åˆ†åˆ«ä¸ºÂ root1 å’ŒÂ root2Â çš„æ ‘æ˜¯å¶ç›¸ä¼¼çš„ï¼Œåˆ™è¿”å›Â trueï¼›å¦åˆ™è¿”å› false ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: ä¸­åºéå†ï¼Œè®°å½•æœ€å°å·®å€¼å³å¯ã€‚

    # ä»£ç 
    def leafSimilar(self, root1: TreeNode, root2: TreeNode) -> bool:

        def dfs(root, res):
            if not root:
                return
            if not root.left and not root.right:
                res.append(root.val) 

            dfs(root.left, res)
            dfs(root.right, res)

        res1, res2 = [], []
        dfs(root1, res1)
        dfs(root2, res2)
        return res1 == res2

#### 2. éé€’å½’
æ€è·¯ï¼š

## 897. é€’å¢é¡ºåºæœç´¢æ ‘
é¢˜ç›®ï¼šç»™ä½ ä¸€æ£µäºŒå‰æœç´¢æ ‘ï¼Œè¯·ä½  æŒ‰ä¸­åºéå† å°†å…¶é‡æ–°æ’åˆ—ä¸ºä¸€æ£µé€’å¢é¡ºåºæœç´¢æ ‘ï¼Œä½¿æ ‘ä¸­æœ€å·¦è¾¹çš„èŠ‚ç‚¹æˆä¸ºæ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œå¹¶ä¸”æ¯ä¸ªèŠ‚ç‚¹æ²¡æœ‰å·¦å­èŠ‚ç‚¹ï¼Œåªæœ‰ä¸€ä¸ªå³å­èŠ‚ç‚¹ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: ä¸­åºéå†ï¼Œç„¶åæ„å»ºé€’å¢æ ‘å³å¯ã€‚

    # ä»£ç 
    def increasingBST(self, root: TreeNode) -> TreeNode:

        res = []

        def dfs(root):
            nonlocal res
            if not root:
                return
            dfs(root.left)
            res.append(root.val)
            dfs(root.right)

        dfs(root)
        if not res:
            return None
        main_node = TreeNode(0)
        res_node = main_node
        for re in res:
            tmp = TreeNode(re)
            main_node.left = None
            main_node.right = tmp
            main_node = main_node.right

        return res_node.right

#### 2. éé€’å½’
æ€è·¯ï¼š

## 938. äºŒå‰æœç´¢æ ‘çš„èŒƒå›´å’Œ
é¢˜ç›®ï¼šç»™å®šäºŒå‰æœç´¢æ ‘çš„æ ¹ç»“ç‚¹ rootï¼Œè¿”å›å€¼ä½äºèŒƒå›´ [low, high] ä¹‹é—´çš„æ‰€æœ‰ç»“ç‚¹çš„å€¼çš„å’Œã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: ä¸­åºéå†ï¼Œå€¼åœ¨ç»™å®šèŒƒå›´çš„æ±‚å’Œå³å¯ã€‚

    # ä»£ç 
    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:

        res = []

        def dfs(root):
            if not root:
                return 
            dfs(root.left)
            if root.val >= low and root.val <=high:
                res.append(root.val)
            dfs(root.right)
        
        dfs(root)
        return sum(res)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 965. å•å€¼äºŒå‰æ ‘
é¢˜ç›®ï¼šå¦‚æœäºŒå‰æ ‘æ¯ä¸ªèŠ‚ç‚¹éƒ½å…·æœ‰ç›¸åŒçš„å€¼ï¼Œé‚£ä¹ˆè¯¥äºŒå‰æ ‘å°±æ˜¯å•å€¼äºŒå‰æ ‘ã€‚åªæœ‰ç»™å®šçš„æ ‘æ˜¯å•å€¼äºŒå‰æ ‘æ—¶ï¼Œæ‰è¿”å› trueï¼›å¦åˆ™è¿”å› falseã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: å‰åºéå†ï¼ŒæŠŠæ‰€æœ‰å€¼å­˜å…¥æ•°ç»„ï¼Œç„¶ååˆ¤æ–­æ•°ç»„æ˜¯å¦åªåŒ…å«åŒä¸€ä¸ªæ•°å³å¯ã€‚

    # ä»£ç 
    def isUnivalTree(self, root: TreeNode) -> bool:
        val = root.val

        def dfs(root):
            if not root:
                return True
            if root.val != val:
                return False
            else:
                return dfs(root.left) and dfs(root.right)
        
        return dfs(root)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 993. äºŒå‰æ ‘çš„å ‚å…„å¼ŸèŠ‚ç‚¹
é¢˜ç›®ï¼šåœ¨äºŒå‰æ ‘ä¸­ï¼Œæ ¹èŠ‚ç‚¹ä½äºæ·±åº¦ 0 å¤„ï¼Œæ¯ä¸ªæ·±åº¦ä¸º k çš„èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ä½äºæ·±åº¦ k+1 å¤„ã€‚å¦‚æœäºŒå‰æ ‘çš„ä¸¤ä¸ªèŠ‚ç‚¹æ·±åº¦ç›¸åŒï¼Œä½† çˆ¶èŠ‚ç‚¹ä¸åŒ ï¼Œåˆ™å®ƒä»¬æ˜¯ä¸€å¯¹å ‚å…„å¼ŸèŠ‚ç‚¹ã€‚
æˆ‘ä»¬ç»™å‡ºäº†å…·æœ‰å”¯ä¸€å€¼çš„äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œä»¥åŠæ ‘ä¸­ä¸¤ä¸ªä¸åŒèŠ‚ç‚¹çš„å€¼ x å’Œ y ã€‚åªæœ‰ä¸å€¼ x å’Œ y å¯¹åº”çš„èŠ‚ç‚¹æ˜¯å ‚å…„å¼ŸèŠ‚ç‚¹æ—¶ï¼Œæ‰è¿”å› true ã€‚å¦åˆ™ï¼Œè¿”å› falseã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: å‰åºéå†ï¼Œè®°å½•å½“å‰èŠ‚ç‚¹çš„æ·±åº¦ï¼Œå’Œå½“å‰èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ã€‚

    # ä»£ç 
    def isCousins(self, root: TreeNode, x: int, y: int) -> bool:
        x_d, y_d, x_p, y_p = 0, 0, None, None

        def dfs(root, parent, x, y, depth):
            nonlocal x_d, x_p, y_d, y_p
            if not root:
                return
            if root.val == x:
                x_d = depth
                x_p = parent
            if root.val == y:
                y_d = depth
                y_p = parent
            dfs(root.left, root, x, y, depth+1)
            dfs(root.right, root, x, y, depth+1)
        
        dfs(root, None, x, y, depth=0)
        return x_d == y_d and x_p !=y_p

#### 2. éé€’å½’
æ€è·¯ï¼š

## 1022. ä»æ ¹åˆ°å¶çš„äºŒè¿›åˆ¶æ•°ä¹‹å’Œ
é¢˜ç›®ï¼šç»™å‡ºä¸€æ£µäºŒå‰æ ‘ï¼Œå…¶ä¸Šæ¯ä¸ªç»“ç‚¹çš„å€¼éƒ½æ˜¯Â 0Â æˆ–Â 1Â ã€‚æ¯ä¸€æ¡ä»æ ¹åˆ°å¶çš„è·¯å¾„éƒ½ä»£è¡¨ä¸€ä¸ªä»æœ€é«˜æœ‰æ•ˆä½å¼€å§‹çš„äºŒè¿›åˆ¶æ•°ã€‚ä¾‹å¦‚ï¼Œå¦‚æœè·¯å¾„ä¸ºÂ 0 -> 1 -> 1 -> 0 -> 1ï¼Œé‚£ä¹ˆå®ƒè¡¨ç¤ºäºŒè¿›åˆ¶æ•°Â 01101ï¼Œä¹Ÿå°±æ˜¯Â 13Â ã€‚å¯¹æ ‘ä¸Šçš„æ¯ä¸€ç‰‡å¶å­ï¼Œæˆ‘ä»¬éƒ½è¦æ‰¾å‡ºä»æ ¹åˆ°è¯¥å¶å­çš„è·¯å¾„æ‰€è¡¨ç¤ºçš„æ•°å­—ã€‚è¿”å›è¿™äº›æ•°å­—ä¹‹å’Œã€‚é¢˜ç›®æ•°æ®ä¿è¯ç­”æ¡ˆæ˜¯ä¸€ä¸ª 32 ä½ æ•´æ•°ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: éå†è®°å½•æ ¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ï¼Œç„¶åæ±‚å’Œå³å¯ã€‚

    # ä»£ç 
    def sumRootToLeaf(self, root: TreeNode) -> int:

        res = []

        def dfs(root, path):
            if not root:
                return
            path += str(root.val)
            if not root.left and not root.right:
                res.append(path)
            dfs(root.left, path)
            dfs(root.right, path)

        def getNum(s):
            sum = 0
            for i in range(len(s)):
                sum += (int(s[len(s) - i -1]) * pow(2, i))
            return sum

        dfs(root, '')
        sum = 0
        for re in res:
            sum += getNum(re)
        return sum

#### 2. éé€’å½’
æ€è·¯ï¼š

## 95. ä¸åŒçš„äºŒå‰æœç´¢æ ‘ II
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªæ•´æ•° n ï¼Œè¯·ä½ ç”Ÿæˆå¹¶è¿”å›æ‰€æœ‰ç”± n ä¸ªèŠ‚ç‚¹ç»„æˆä¸”èŠ‚ç‚¹å€¼ä» 1 åˆ° n äº’ä¸ç›¸åŒçš„ä¸åŒ äºŒå‰æœç´¢æ ‘ ã€‚å¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›ç­”æ¡ˆã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: ä»[1,...n] éå†ï¼Œä¸€æ¬¡å½“æ ¹ï¼Œå› ä¸ºæ˜¯äºŒå‰æœç´¢æ ‘ï¼Œå½“æ ¹èŠ‚ç‚¹å–iæ—¶ï¼Œ[1,...i] æ„æˆå·¦å­æ ‘ï¼Œ[i,...n] æ„æˆå³å­æ ‘ï¼Œå·¦å³å­æ ‘å†é€’å½’æ±‚è§£å³å¯ã€‚

    # ä»£ç 
    def generateTrees(self, n: int) -> List[TreeNode]:

        def dfs(s, e):
            res = []
            if s > e:
                return [None]
            for i in range(s, e+1):
                lefts = dfs(s, i-1)
                rights = dfs(i+1, e)
                for l in lefts:
                    for r in rights:
                        node = TreeNode(i)
                        node.left = l
                        node.right = r
                        res.append(node)
            return res
        return dfs(1, n)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 96. ä¸åŒçš„äºŒå‰æœç´¢æ ‘
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªæ•´æ•° n ï¼Œæ±‚æ°ç”± n ä¸ªèŠ‚ç‚¹ç»„æˆä¸”èŠ‚ç‚¹å€¼ä» 1 åˆ° n äº’ä¸ç›¸åŒçš„ äºŒå‰æœç´¢æ ‘ æœ‰å¤šå°‘ç§ï¼Ÿè¿”å›æ»¡è¶³é¢˜æ„çš„äºŒå‰æœç´¢æ ‘çš„ç§æ•°ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: è®°å¿†åŒ–æœç´¢ï¼Œæ€»çš„ç§æ•°=å·¦å­æ ‘ç§æ•°*å³å­æ ‘æ•°é‡ã€‚
    # ä»£ç 
    def numTrees(self, n: int) -> int:

        dic = {0: 1, 1: 2, 2: 2}

        def dfs(n):
            if n <= 0: return 1
            if n <= 2: return n
            if n in dic:
                return dic[n]
            dic[n] = sum([dfs(i-1) * dfs(n-i) for i in range(1, n+1)])
            return dic[n]

        return dfs(n)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 98. éªŒè¯äºŒå‰æœç´¢æ ‘
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œåˆ¤æ–­å…¶æ˜¯å¦æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„äºŒå‰æœç´¢æ ‘ã€‚æœ‰æ•ˆ äºŒå‰æœç´¢æ ‘å®šä¹‰å¦‚ä¸‹ï¼š
èŠ‚ç‚¹çš„å·¦å­æ ‘åªåŒ…å« å°äº å½“å‰èŠ‚ç‚¹çš„æ•°ã€‚èŠ‚ç‚¹çš„å³å­æ ‘åªåŒ…å« å¤§äº å½“å‰èŠ‚ç‚¹çš„æ•°ã€‚æ‰€æœ‰å·¦å­æ ‘å’Œå³å­æ ‘è‡ªèº«å¿…é¡»ä¹Ÿæ˜¯äºŒå‰æœç´¢æ ‘ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: ä¸­åºéå†ï¼Œå•è°ƒé€’å¢

    # ä»£ç 
    def isValidBST(self, root: TreeNode) -> bool:
        pre = None

        def dfs(root):
            nonlocal pre
            if not root:
                return True
            left = dfs(root.left)
            if pre and pre.val >= root.val:
                return False
            pre = root
            right = dfs(root.right)
            return left and right
        
        return dfs(root)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 99. æ¢å¤äºŒå‰æœç´¢æ ‘
é¢˜ç›®ï¼šç»™ä½ äºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¯¥æ ‘ä¸­çš„ä¸¤ä¸ªèŠ‚ç‚¹è¢«é”™è¯¯åœ°äº¤æ¢ã€‚è¯·åœ¨ä¸æ”¹å˜å…¶ç»“æ„çš„æƒ…å†µä¸‹ï¼Œæ¢å¤è¿™æ£µæ ‘ã€‚
è¿›é˜¶ï¼šä½¿ç”¨ O(n) ç©ºé—´å¤æ‚åº¦çš„è§£æ³•å¾ˆå®¹æ˜“å®ç°ã€‚ä½ èƒ½æƒ³å‡ºä¸€ä¸ªåªä½¿ç”¨å¸¸æ•°ç©ºé—´çš„è§£å†³æ–¹æ¡ˆå—ï¼Ÿ
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: ä¸­åºéå†ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªa>bçš„ï¼Œå–a,ç„¶åå–ç¬¬äºŒä¸ªa>bçš„å–b,æœ€åäº¤æ¢aå’Œbã€‚

    # ä»£ç 
    def recoverTree(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """

        firstNode = None
        secondNode = None
        pre = None

        def dfs(root):
            nonlocal pre, firstNode, secondNode
            if not root:
                return 
            
            dfs(root.left)
            if pre:
                if not firstNode and pre.val > root.val:
                    firstNode = pre
                    secondNode = root
                elif firstNode and pre.val > root.val:
                    secondNode = root
            pre = root
            dfs(root.right)

        dfs(root)
        if firstNode and secondNode:
            firstNode.val, secondNode.val = secondNode.val, firstNode.val

#### 2. éé€’å½’
æ€è·¯ï¼š

## 102. äºŒå‰æ ‘çš„å±‚åºéå†
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¯·ä½ è¿”å›å…¶æŒ‰ å±‚åºéå† å¾—åˆ°çš„èŠ‚ç‚¹å€¼ã€‚ ï¼ˆå³é€å±‚åœ°ï¼Œä»å·¦åˆ°å³è®¿é—®æ‰€æœ‰èŠ‚ç‚¹ï¼‰ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: 

#### 2. éé€’å½’
æ€è·¯ï¼šå±‚åºéå†ï¼Œéé€’å½’ã€‚

    # ä»£ç 
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        
        res = []
        queue = [root]

        while queue:
            res.append([q.val for q in queue])
            l = []
            for q in queue:
                if q.left:
                    l.append(q.left)
                if q.right:
                    l.append(q.right)
            queue = l
        
        return res

## 103. äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚åºéå†
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„é”¯é½¿å½¢å±‚åºéå†ã€‚ï¼ˆå³å…ˆä»å·¦å¾€å³ï¼Œå†ä»å³å¾€å·¦è¿›è¡Œä¸‹ä¸€å±‚éå†ï¼Œä»¥æ­¤ç±»æ¨ï¼Œå±‚ä¸å±‚ä¹‹é—´äº¤æ›¿è¿›è¡Œï¼‰ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: 

#### 2. éé€’å½’
æ€è·¯ï¼šå±‚åºéå†ï¼Œä½¿ç”¨å•ç‹¬éå†è®°å½•æ˜¯å¦éœ€è¦ç¿»è½¬ã€‚

    # ä»£ç 
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        res = []
        queue = [root]
        is_reverse = False
        while queue:
            tmp = [q.val for q in queue]
            if is_reverse:
                tmp.reverse()
                res.append(tmp)
                is_reverse = False
            else:
                res.append(tmp)
                is_reverse = True

            l = []
            for q in queue:
                if q.left:
                    l.append(q.left)
                if q.right:
                    l.append(q.right)
            queue = l
        
        return res
        
## 105. ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘
é¢˜ç›®ï¼šç»™å®šä¸€æ£µæ ‘çš„å‰åºéå† preorder ä¸ä¸­åºéå†  inorderã€‚è¯·æ„é€ äºŒå‰æ ‘å¹¶è¿”å›å…¶æ ¹èŠ‚ç‚¹ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: æ ¹æ®å‰åºæ‰¾åˆ°æ ¹èŠ‚ç‚¹ï¼Œç„¶åé€’å½’æ„å»ºå·¦å­æ ‘å’Œå³å­æ ‘

    # æ„é€ äºŒå‰æ ‘
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:

        def dfs(preorder, inorder):
            if not preorder or not inorder:
                return
            root = TreeNode(preorder[0])
            index = inorder.index(preorder[0])
            root.left = dfs(preorder[1:index+1], inorder[0:index])
            root.right = dfs(preorder[index+1:], inorder[index+1:])
            return root

        return dfs(preorder, inorder)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 106. ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘
é¢˜ç›®ï¼šæ ¹æ®ä¸€æ£µæ ‘çš„ä¸­åºéå†ä¸ååºéå†æ„é€ äºŒå‰æ ‘ã€‚
æ³¨æ„:ä½ å¯ä»¥å‡è®¾æ ‘ä¸­æ²¡æœ‰é‡å¤çš„å…ƒç´ ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: æ ¹æ®ååºæ‰¾åˆ°æ ¹èŠ‚ç‚¹ï¼Œç„¶åé€’å½’æ„å»ºå·¦å­æ ‘å’Œå³å­æ ‘

    # æ„é€ äºŒå‰æ ‘
    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:

        def dfs(inorder, postorder):
            if not inorder or not postorder:
                return 
            index = inorder.index(postorder[-1])
            root = TreeNode(postorder[-1])
            root.left = dfs(inorder[0:index], postorder[0:index])
            root.right = dfs(inorder[index+1:], postorder[index:len(postorder)-1])
            return root
        
        return dfs(inorder, postorder)

#### 2. éé€’å½’
æ€è·¯ï¼š

## 107. äºŒå‰æ ‘çš„å±‚åºéå† II
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼è‡ªåº•å‘ä¸Šçš„å±‚åºéå†ã€‚ ï¼ˆå³æŒ‰ä»å¶å­èŠ‚ç‚¹æ‰€åœ¨å±‚åˆ°æ ¹èŠ‚ç‚¹æ‰€åœ¨çš„å±‚ï¼Œé€å±‚ä»å·¦å‘å³éå†ï¼‰
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: å±‚åºéå†ï¼Œå°†ç»“æœç¿»è½¬å³å¯ã€‚

    # å±‚é¡ºåºéå†
    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []

        res = []
        queue = [root]
        while queue:
            res.append([q.val for q in queue])
            l = []
            for q in queue:
                if q.left:
                    l.append(q.left)
                if q.right:
                    l.append(q.right)
            queue= l

        res.reverse()

        return res
#### 2. éé€’å½’
æ€è·¯ï¼š

## 109. æœ‰åºé“¾è¡¨è½¬æ¢äºŒå‰æœç´¢æ ‘
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªå•é“¾è¡¨ï¼Œå…¶ä¸­çš„å…ƒç´ æŒ‰å‡åºæ’åºï¼Œå°†å…¶è½¬æ¢ä¸ºé«˜åº¦å¹³è¡¡çš„äºŒå‰æœç´¢æ ‘ã€‚
æœ¬é¢˜ä¸­ï¼Œä¸€ä¸ªé«˜åº¦å¹³è¡¡äºŒå‰æ ‘æ˜¯æŒ‡ä¸€ä¸ªäºŒå‰æ ‘æ¯ä¸ªèŠ‚ç‚¹Â çš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡ 1ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: æœ‰åºé“¾è¡¨å¿«æ…¢æŒ‡é’ˆæ‰¾ä¸­ç‚¹ï¼Œç„¶åæ„å»ºæ ‘å³å¯ã€‚

    # å±‚é¡ºåºéå†
    def sortedListToBST(self, head: ListNode) -> TreeNode:

        def findMid(head, tail):
            fast = head
            slow = head
            while fast != tail and fast.next != tail:
                slow = slow.next
                fast = fast.next.next
            return slow
        
        def dfs(head, tail):
            if head == tail:
                return None
            node = findMid(head, tail)
            root= TreeNode(node.val)
            root.left = dfs(head, node)
            root.right = dfs(node.next, tail)
            return root

        return dfs(head, None)
#### 2. éé€’å½’
æ€è·¯ï¼š

## 113. è·¯å¾„æ€»å’Œ II
é¢˜ç›®ï¼šç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root å’Œä¸€ä¸ªæ•´æ•°ç›®æ ‡å’Œ targetSum ï¼Œæ‰¾å‡ºæ‰€æœ‰ ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹ è·¯å¾„æ€»å’Œç­‰äºç»™å®šç›®æ ‡å’Œçš„è·¯å¾„ã€‚
å¶å­èŠ‚ç‚¹ æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: æ·±åº¦ä¼˜å…ˆéå†ï¼Œéå†åˆ°å¶å­èŠ‚ç‚¹æ—¶åˆ¤æ–­å³å¯ã€‚

    # å±‚é¡ºåºéå†
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:

        res = []
        sub_res = []
        def dfs(root):
            nonlocal res, sub_res
            if not root:
                return 
            sub_res.append(root.val)
            if not root.left and not root.right:
                if sum(sub_res) == targetSum:
                    res.append([s for s in sub_res])
            dfs(root.left)
            dfs(root.right)
            sub_res.pop()

        dfs(root)
        return res
#### 2. éé€’å½’
æ€è·¯ï¼š

## 114. äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨
é¢˜ç›®ï¼šç»™ä½ äºŒå‰æ ‘çš„æ ¹ç»“ç‚¹ root ï¼Œè¯·ä½ å°†å®ƒå±•å¼€ä¸ºä¸€ä¸ªå•é“¾è¡¨ï¼š
å±•å¼€åçš„å•é“¾è¡¨åº”è¯¥åŒæ ·ä½¿ç”¨ TreeNode ï¼Œå…¶ä¸­ right å­æŒ‡é’ˆæŒ‡å‘é“¾è¡¨ä¸­ä¸‹ä¸€ä¸ªç»“ç‚¹ï¼Œè€Œå·¦å­æŒ‡é’ˆå§‹ç»ˆä¸º null ã€‚
å±•å¼€åçš„å•é“¾è¡¨åº”è¯¥ä¸äºŒå‰æ ‘ å…ˆåºéå† é¡ºåºç›¸åŒã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: å…ˆåºéå†ï¼Œæ ¹å·¦å³ï¼Œå°†æ ¹èŠ‚ç‚¹çš„å³å­æ ‘ç§»åˆ°å·¦å­æ ‘çš„æœ€å³èŠ‚ç‚¹ï¼Œå°†å·¦å­æ ‘å˜ä¸ºæ ¹çš„å³å­æ ‘ï¼Œå°†æ ¹çš„å³å­æ ‘ç½®ä¸ºç©ºï¼Œç„¶åæ ¹èŠ‚ç‚¹å³ç§»å¾ªç¯åˆ¤æ–­ã€‚

    # å±‚é¡ºåºéå†
    def flatten(self, root: TreeNode) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        if not root:
            return 

        node = root

        while node:
            if node.left:
                sub_left = node.left
                tmp = sub_left
                while tmp.right:
                    tmp = tmp.right
                tmp.right = node.right
                node.right = sub_left
                node.left = None
            node = node.right
#### 2. éé€’å½’
æ€è·¯ï¼š

## 116. å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªÂ å®Œç¾äºŒå‰æ ‘Â ï¼Œå…¶æ‰€æœ‰å¶å­èŠ‚ç‚¹éƒ½åœ¨åŒä¸€å±‚ï¼Œæ¯ä¸ªçˆ¶èŠ‚ç‚¹éƒ½æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ã€‚äºŒå‰æ ‘å®šä¹‰å¦‚ä¸‹ï¼š
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
å¡«å……å®ƒçš„æ¯ä¸ª next æŒ‡é’ˆï¼Œè®©è¿™ä¸ªæŒ‡é’ˆæŒ‡å‘å…¶ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹ã€‚å¦‚æœæ‰¾ä¸åˆ°ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹ï¼Œåˆ™å°† next æŒ‡é’ˆè®¾ç½®ä¸º NULLã€‚
åˆå§‹çŠ¶æ€ä¸‹ï¼Œæ‰€æœ‰Â next æŒ‡é’ˆéƒ½è¢«è®¾ç½®ä¸º NULLã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: æ¯ä¸ªæ ¹èŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹nextåº”è¯¥æŒ‡å‘æ ¹èŠ‚ç‚¹çš„å³èŠ‚ç‚¹ï¼Œæ¯ä¸ªæ ¹èŠ‚ç‚¹çš„å³èŠ‚ç‚¹nextåº”è¯¥æŒ‡å‘å…¶çˆ¶èŠ‚ç‚¹çš„nextèŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹ã€‚

    # 
    def connect(self, root: 'Node') -> 'Node':

        def dfs(root):
            if not root:
                return
            if root.left:
                root.left.next = root.right
            if root.right:
                if root.next:
                    root.right.next = root.next.left
            dfs(root.left)
            dfs(root.right)

        dfs(root)
        return root
#### 2. éé€’å½’
æ€è·¯ï¼š

## 117. å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ II
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æ ‘
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
å¡«å……å®ƒçš„æ¯ä¸ª next æŒ‡é’ˆï¼Œè®©è¿™ä¸ªæŒ‡é’ˆæŒ‡å‘å…¶ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹ã€‚å¦‚æœæ‰¾ä¸åˆ°ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹ï¼Œåˆ™å°† next æŒ‡é’ˆè®¾ç½®ä¸º NULLã€‚
åˆå§‹çŠ¶æ€ä¸‹ï¼Œæ‰€æœ‰Â next æŒ‡é’ˆéƒ½è¢«è®¾ç½®ä¸º NULLã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: æ¯ä¸ªæ ¹èŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹nextåº”è¯¥æŒ‡å‘æ ¹èŠ‚ç‚¹çš„å³èŠ‚ç‚¹ï¼Œæ¯ä¸ªæ ¹èŠ‚ç‚¹çš„å³èŠ‚ç‚¹nextåº”è¯¥æŒ‡å‘å…¶çˆ¶èŠ‚ç‚¹çš„nextèŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹ã€‚

    # 
    
#### 2. éé€’å½’
æ€è·¯ï¼š

## 129. æ±‚æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹æ•°å­—ä¹‹å’Œ
ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œæ ‘ä¸­æ¯ä¸ªèŠ‚ç‚¹éƒ½å­˜æ”¾æœ‰ä¸€ä¸ª 0 åˆ° 9 ä¹‹é—´çš„æ•°å­—ã€‚
æ¯æ¡ä»æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹çš„è·¯å¾„éƒ½ä»£è¡¨ä¸€ä¸ªæ•°å­—ï¼š
ä¾‹å¦‚ï¼Œä»æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹çš„è·¯å¾„ 1 -> 2 -> 3 è¡¨ç¤ºæ•°å­— 123 ã€‚
è®¡ç®—ä»æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹ç”Ÿæˆçš„ æ‰€æœ‰æ•°å­—ä¹‹å’Œ ã€‚
å¶èŠ‚ç‚¹ æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: æ·±åº¦éå†ï¼Œç›´æ¥æ±‚å’Œå³å¯ã€‚

    # 
    def sumNumbers(self, root: TreeNode) -> int:

        res = 0
        def dfs(root, num):
            nonlocal res
            if not root:
                return
            if not root.left and not root.right:
                res += num
            if root.left:
                dfs(root.left, num * 10 + root.left.val)
            if root.right:
                dfs(root.right, num * 10 + root.right.val)
        dfs(root, root.val)
        return res
    
#### 2. éé€’å½’
æ€è·¯ï¼š

## 173. äºŒå‰æœç´¢æ ‘è¿­ä»£å™¨
å®ç°ä¸€ä¸ªäºŒå‰æœç´¢æ ‘è¿­ä»£å™¨ç±»BSTIterator ï¼Œè¡¨ç¤ºä¸€ä¸ªæŒ‰ä¸­åºéå†äºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰çš„è¿­ä»£å™¨ï¼š
BSTIterator(TreeNode root) åˆå§‹åŒ– BSTIterator ç±»çš„ä¸€ä¸ªå¯¹è±¡ã€‚BST çš„æ ¹èŠ‚ç‚¹ root ä¼šä½œä¸ºæ„é€ å‡½æ•°çš„ä¸€éƒ¨åˆ†ç»™å‡ºã€‚æŒ‡é’ˆåº”åˆå§‹åŒ–ä¸ºä¸€ä¸ªä¸å­˜åœ¨äº BST ä¸­çš„æ•°å­—ï¼Œä¸”è¯¥æ•°å­—å°äº BST ä¸­çš„ä»»ä½•å…ƒç´ ã€‚
boolean hasNext() å¦‚æœå‘æŒ‡é’ˆå³ä¾§éå†å­˜åœ¨æ•°å­—ï¼Œåˆ™è¿”å› true ï¼›å¦åˆ™è¿”å› false ã€‚
int next()å°†æŒ‡é’ˆå‘å³ç§»åŠ¨ï¼Œç„¶åè¿”å›æŒ‡é’ˆå¤„çš„æ•°å­—ã€‚
æ³¨æ„ï¼ŒæŒ‡é’ˆåˆå§‹åŒ–ä¸ºä¸€ä¸ªä¸å­˜åœ¨äº BST ä¸­çš„æ•°å­—ï¼Œæ‰€ä»¥å¯¹ next() çš„é¦–æ¬¡è°ƒç”¨å°†è¿”å› BST ä¸­çš„æœ€å°å…ƒç´ ã€‚
ä½ å¯ä»¥å‡è®¾Â next()Â è°ƒç”¨æ€»æ˜¯æœ‰æ•ˆçš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå½“è°ƒç”¨ next()Â æ—¶ï¼ŒBST çš„ä¸­åºéå†ä¸­è‡³å°‘å­˜åœ¨ä¸€ä¸ªä¸‹ä¸€ä¸ªæ•°å­—ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: æ±‚nextæ—¶æ„é€ å•è°ƒæ ˆã€‚

    # 
    class BSTIterator:

    def __init__(self, root: TreeNode):
        self.res = []
        while root:
            self.res.append(root)
            root = root.left


    def next(self) -> int:
        cur = self.res.pop()
        node = cur.right
        while node:
            self.res.append(node)
            node = node.left
        return cur.val


    def hasNext(self) -> bool:
        return len(self.res) > 0
    
#### 2. éé€’å½’
æ€è·¯ï¼š

## 199. äºŒå‰æ ‘çš„å³è§†å›¾
ç»™å®šä¸€ä¸ªäºŒå‰æ ‘çš„ æ ¹èŠ‚ç‚¹ rootï¼Œæƒ³è±¡è‡ªå·±ç«™åœ¨å®ƒçš„å³ä¾§ï¼ŒæŒ‰ç…§ä»é¡¶éƒ¨åˆ°åº•éƒ¨çš„é¡ºåºï¼Œè¿”å›ä»å³ä¾§æ‰€èƒ½çœ‹åˆ°çš„èŠ‚ç‚¹å€¼ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: å±‚æ¬¡éå†ï¼Œæ¯å±‚å–æœ€å³è¾¹èŠ‚ç‚¹ã€‚

    # 
    def rightSideView(self, root: TreeNode) -> List[int]:
        if not root:
            return []

        res = []
        queue = [root]
        while queue:
            res.append(queue[-1].val)
            l = []
            for q in queue:
                if q.left:
                    l.append(q.left)
                if q.right:
                    l.append(q.right)
            queue = l

        return res
    
#### 2. éé€’å½’
æ€è·¯ï¼š

## 222. å®Œå…¨äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°
ç»™ä½ ä¸€æ£µ å®Œå…¨äºŒå‰æ ‘ çš„æ ¹èŠ‚ç‚¹ root ï¼Œæ±‚å‡ºè¯¥æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°ã€‚
å®Œå…¨äºŒå‰æ ‘ çš„å®šä¹‰å¦‚ä¸‹ï¼šåœ¨å®Œå…¨äºŒå‰æ ‘ä¸­ï¼Œé™¤äº†æœ€åº•å±‚èŠ‚ç‚¹å¯èƒ½æ²¡å¡«æ»¡å¤–ï¼Œå…¶ä½™æ¯å±‚èŠ‚ç‚¹æ•°éƒ½è¾¾åˆ°æœ€å¤§å€¼ï¼Œå¹¶ä¸”æœ€ä¸‹é¢ä¸€å±‚çš„èŠ‚ç‚¹éƒ½é›†ä¸­åœ¨è¯¥å±‚æœ€å·¦è¾¹çš„è‹¥å¹²ä½ç½®ã€‚è‹¥æœ€åº•å±‚ä¸ºç¬¬ h å±‚ï¼Œåˆ™è¯¥å±‚åŒ…å« 1~Â 2hÂ ä¸ªèŠ‚ç‚¹ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: éå†æ ¹èŠ‚ç‚¹é¥¿å·¦å­æ ‘é«˜åº¦å’Œå³å­æ ‘é«˜åº¦ï¼Œè‹¥é«˜åº¦ç›¸åŒåˆ™è¡¨ç¤ºå·¦å­æ ‘è‚¯å®šæ˜¯æ»¡äºŒå‰æ ‘ï¼Œæ€»èŠ‚ç‚¹ä¸ªæ•°ä¸ºå·¦å­æ ‘æ»¡äºŒå‰æ ‘+é€’å½’å³å­æ ‘ï¼Œè‹¥ä¸æƒ³ç­‰ï¼Œåˆ™å³å­æ ‘è‚¯å®šæ˜¯äºŒå‰æ ‘ï¼Œæ€»èŠ‚ç‚¹ä¸ªæ•°ä¸ºå³å­æ ‘æ»¡äºŒå‰æ ‘+é€’å½’å·¦å­æ ‘

    # 
    def countNodes(self, root: TreeNode) -> int:
        if not root:
            return 0

        def getDepth(node):
            if not node:
                return 0
            return max(getDepth(node.left), getDepth(node.right)) + 1

        def dfs(root):
            if not root:
                return 0
            l_d, r_d = getDepth(root.left), getDepth(root.right)
            if l_d == r_d:
                return (1<<l_d) + dfs(root.right)
            else:
                return (1<<r_d) + dfs(root.left)
        
        return dfs(root)
    
#### 2. éé€’å½’
æ€è·¯ï¼š

## 230. äºŒå‰æœç´¢æ ‘ä¸­ç¬¬Kå°çš„å…ƒç´ 
ç»™å®šä¸€ä¸ªäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œå’Œä¸€ä¸ªæ•´æ•° k ï¼Œè¯·ä½ è®¾è®¡ä¸€ä¸ªç®—æ³•æŸ¥æ‰¾å…¶ä¸­ç¬¬ k ä¸ªæœ€å°å…ƒç´ ï¼ˆä» 1 å¼€å§‹è®¡æ•°ï¼‰ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: ä¸­åºéå†ï¼Œéå†åˆ°ç¬¬kä¸ªæ—¶ç»“æŸå³å¯ã€‚

    # 
    def kthSmallest(self, root: TreeNode, k: int) -> int:

        res = 0

        def dfs(root):
            nonlocal res, k
            if not root:
                return
            dfs(root.left)
            k -= 1
            if k == 0:
                res = root.val
                return
            dfs(root.right)

        dfs(root)

        return res
    
#### 2. éé€’å½’
æ€è·¯ï¼š

## 236. äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ
ç»™å®šä¸€ä¸ªäºŒå‰æ ‘, æ‰¾åˆ°è¯¥æ ‘ä¸­ä¸¤ä¸ªæŒ‡å®šèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚
ç™¾åº¦ç™¾ç§‘ä¸­æœ€è¿‘å…¬å…±ç¥–å…ˆçš„å®šä¹‰ä¸ºï¼šâ€œå¯¹äºæœ‰æ ¹æ ‘ T çš„ä¸¤ä¸ªèŠ‚ç‚¹ pã€qï¼Œæœ€è¿‘å…¬å…±ç¥–å…ˆè¡¨ç¤ºä¸ºä¸€ä¸ªèŠ‚ç‚¹ xï¼Œæ»¡è¶³ x æ˜¯ pã€q çš„ç¥–å…ˆä¸” x çš„æ·±åº¦å°½å¯èƒ½å¤§ï¼ˆä¸€ä¸ªèŠ‚ç‚¹ä¹Ÿå¯ä»¥æ˜¯å®ƒè‡ªå·±çš„ç¥–å…ˆï¼‰ã€‚â€
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: æœ€è¿‘å…¬å…±ç¥–å…ˆåªä¼šå‡ºç°åœ¨æƒ…å†µï¼Œä¸€æ˜¯åœ¨æ ¹èŠ‚ç‚¹çš„å·¦å­æ ‘å’Œå³å­æ ‘ä¸­ï¼Œåˆ™ä¸ºæ ¹ï¼ŒäºŒæ˜¯pæ˜¯qçš„æ ¹ï¼Œä¸‰æ˜¯qæ˜¯pçš„æ ¹ã€‚

    # 
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':

        def dfs(root):
            # nonlocal p, q
            if not root:
                return None
            if root == p or root == q:
                return root
            left = dfs(root.left)
            right = dfs(root.right)
            if not left:
                return right
            elif not right:
                return left
            elif not left and not right:
                return None
            else:
                return root

        return dfs(root)
    
#### 2. éé€’å½’
æ€è·¯ï¼š

## 331. éªŒè¯äºŒå‰æ ‘çš„å‰åºåºåˆ—åŒ–
åºåˆ—åŒ–äºŒå‰æ ‘çš„ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨å‰åºéå†ã€‚å½“æˆ‘ä»¬é‡åˆ°ä¸€ä¸ªéç©ºèŠ‚ç‚¹æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥è®°å½•ä¸‹è¿™ä¸ªèŠ‚ç‚¹çš„å€¼ã€‚å¦‚æœå®ƒæ˜¯ä¸€ä¸ªç©ºèŠ‚ç‚¹ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªæ ‡è®°å€¼è®°å½•ï¼Œ
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: 3##å˜ä¸º#ï¼Œæ ˆæœ€ååªå‰©ä¸€ä¸ª#ï¼Œè¿”å›trueï¼Œåä¹‹åå›false

    # 
    def isValidSerialization(self, preorder: str) -> bool:

        stack = []
        data = preorder.split(',')
        for s in data:
            stack.append(s)
            while len(stack) >= 3 and stack[-1] == '#' and stack[-2] == '#' and stack[-3] != '#':
                for i in range(3):
                    stack.pop()
                stack.append('#')
        return len(stack) == 1 and stack[0] == '#'
    
#### 2. éé€’å½’
æ€è·¯ï¼š

## 337. æ‰“å®¶åŠ«èˆ III
åœ¨ä¸Šæ¬¡æ‰“åŠ«å®Œä¸€æ¡è¡—é“ä¹‹åå’Œä¸€åœˆæˆ¿å±‹åï¼Œå°å·åˆå‘ç°äº†ä¸€ä¸ªæ–°çš„å¯è¡Œçªƒçš„åœ°åŒºã€‚è¿™ä¸ªåœ°åŒºåªæœ‰ä¸€ä¸ªå…¥å£ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºâ€œæ ¹â€ã€‚ é™¤äº†â€œæ ¹â€ä¹‹å¤–ï¼Œæ¯æ ‹æˆ¿å­æœ‰ä¸”åªæœ‰ä¸€ä¸ªâ€œçˆ¶â€œæˆ¿å­ä¸ä¹‹ç›¸è¿ã€‚ä¸€ç•ªä¾¦å¯Ÿä¹‹åï¼Œèªæ˜çš„å°å·æ„è¯†åˆ°â€œè¿™ä¸ªåœ°æ–¹çš„æ‰€æœ‰æˆ¿å±‹çš„æ’åˆ—ç±»ä¼¼äºä¸€æ£µäºŒå‰æ ‘â€ã€‚ å¦‚æœä¸¤ä¸ªç›´æ¥ç›¸è¿çš„æˆ¿å­åœ¨åŒä¸€å¤©æ™šä¸Šè¢«æ‰“åŠ«ï¼Œæˆ¿å±‹å°†è‡ªåŠ¨æŠ¥è­¦ã€‚
è®¡ç®—åœ¨ä¸è§¦åŠ¨è­¦æŠ¥çš„æƒ…å†µä¸‹ï¼Œå°å·ä¸€æ™šèƒ½å¤Ÿç›—å–çš„æœ€é«˜é‡‘é¢ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: é€’å½’ï¼Œå½“æ ¹èŠ‚ç‚¹ä¸å·æ—¶ï¼Œå·¦å³ä¸¤ä¸ªå­©å­å¯ä»¥å·ï¼Œå¯ä»¥ä¸å·ï¼Œå–å·å’Œä¸å·çš„æœ€å¤§å€¼ï¼Œå½“æ ¹èŠ‚ç‚¹å·æ—¶ï¼Œå·¦å³ä¸¤ä¸ªå­©å­éƒ½ä¸å·ã€‚

    # 
    def rob(self, root: TreeNode) -> int:

        def dfs(root):
            if not root:
                return 0, 0  # å·ï¼Œä¸å·
            left = dfs(root.left)
            right = dfs(root.right)
            # å·å½“å‰èŠ‚ç‚¹ï¼Œå…¶å·¦å³ä¸¤ä¸ªå­©å­éƒ½ä¸èƒ½å·
            v1 = root.val + left[1] + right[1]
            # ä¸å·å½“å‰èŠ‚ç‚¹ï¼Œåˆ™å·¦å³ä¸¤ä¸ªå­©å­å¯ä»¥å·ï¼Œå¯ä»¥ä¸å·ï¼Œå–å­©å­æœ€å¤§å€¼
            v2 = max(left[0], left[1]) + max(right[0], right[1])
            return v1, v2

        res = dfs(root)
        return max(res[0], res[1])
    
#### 2. éé€’å½’
æ€è·¯ï¼š

## 341. æ‰å¹³åŒ–åµŒå¥—åˆ—è¡¨è¿­ä»£å™¨
é¢˜ç›®ï¼šç»™ä½ ä¸€ä¸ªåµŒå¥—çš„æ•´æ•°åˆ—è¡¨ nestedList ã€‚æ¯ä¸ªå…ƒç´ è¦ä¹ˆæ˜¯ä¸€ä¸ªæ•´æ•°ï¼Œè¦ä¹ˆæ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼›è¯¥åˆ—è¡¨çš„å…ƒç´ ä¹Ÿå¯èƒ½æ˜¯æ•´æ•°æˆ–è€…æ˜¯å…¶ä»–åˆ—è¡¨ã€‚è¯·ä½ å®ç°ä¸€ä¸ªè¿­ä»£å™¨å°†å…¶æ‰å¹³åŒ–ï¼Œä½¿ä¹‹èƒ½å¤Ÿéå†è¿™ä¸ªåˆ—è¡¨ä¸­çš„æ‰€æœ‰æ•´æ•°ã€‚
å®ç°æ‰å¹³è¿­ä»£å™¨ç±» NestedIterator ï¼š
NestedIterator(List<NestedInteger> nestedList) ç”¨åµŒå¥—åˆ—è¡¨ nestedList åˆå§‹åŒ–è¿­ä»£å™¨ã€‚
int next() è¿”å›åµŒå¥—åˆ—è¡¨çš„ä¸‹ä¸€ä¸ªæ•´æ•°ã€‚
boolean hasNext() å¦‚æœä»ç„¶å­˜åœ¨å¾…è¿­ä»£çš„æ•´æ•°ï¼Œè¿”å› true ï¼›å¦åˆ™ï¼Œè¿”å› false ã€‚
ä½ çš„ä»£ç å°†ä¼šç”¨ä¸‹è¿°ä¼ªä»£ç æ£€æµ‹ï¼š
    
    # 
    initialize iterator with nestedList
    res = []
    while iterator.hasNext()
        append iterator.next() to the end of res
    return res

å¦‚æœ res ä¸é¢„æœŸçš„æ‰å¹³åŒ–åˆ—è¡¨åŒ¹é…ï¼Œé‚£ä¹ˆä½ çš„ä»£ç å°†ä¼šè¢«åˆ¤ä¸ºæ­£ç¡®ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: é€’å½’ï¼Œå°†NestedIntegeråˆ—è¡¨ä¸­çš„æ•´æ•°åŠ å…¥åˆ—è¡¨ï¼Œå°†NestedIntegeråˆ—è¡¨ä¸­çš„åˆ—è¡¨é€’å½’å‡ºæ•´æ•°åŠ å…¥åˆ—è¡¨ã€‚
    
    # 
    class NestedIterator:
        def __init__(self, nestedList: [NestedInteger]):
            self.res = []
            self.index = 0
            def dfs(nestedList):
                for n in nestedList:
                    if n.isInteger():
                        self.res.append(n.getInteger())
                    else:
                        tmp_list = n.getList()
                        for l in tmp_list:
                            if l.isInteger():
                                self.res.append(l.getInteger())
                            else:
                                dfs(l.getList())
    
            dfs(nestedList)
            self.length = len(self.res)
    
    
        def next(self) -> int:
            data = self.res[self.index]
            self.index += 1
            return data
    
    
        def hasNext(self) -> bool:
            return self.index < self.length                   
    
#### 2. éé€’å½’
æ€è·¯ï¼š
                                           
## 429. N å‰æ ‘çš„å±‚åºéå†
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ª N å‰æ ‘ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„å±‚åºéå†ã€‚ï¼ˆå³ä»å·¦åˆ°å³ï¼Œé€å±‚éå†ï¼‰ã€‚
æ ‘çš„åºåˆ—åŒ–è¾“å…¥æ˜¯ç”¨å±‚åºéå†ï¼Œæ¯ç»„å­èŠ‚ç‚¹éƒ½ç”± null å€¼åˆ†éš”ï¼ˆå‚è§ç¤ºä¾‹ï¼‰ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: äºŒå‰æ ‘å±‚æ¬¡éå†ï¼Œæ”¹é€ ä¸€ä¸‹å³å¯ã€‚

    # 
    def levelOrder(self, root: 'Node') -> List[List[int]]:

        if not root:
            return []

        res = []
        queue = [root]
        while queue:
            res.append([q.val for q in queue])
            l = []
            for q in queue:
                # if q.left:
                #     l.append(q.left)
                # if q.right:
                #     l.append(q.right)
                for c in q.children:
                    l.append(c)
            queue = l

        return res
    
#### 2. éé€’å½’
æ€è·¯ï¼š         
    
## 437. è·¯å¾„æ€»å’Œ III
é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ rootÂ ï¼Œå’Œä¸€ä¸ªæ•´æ•° targetSum ï¼Œæ±‚è¯¥äºŒå‰æ ‘é‡ŒèŠ‚ç‚¹å€¼ä¹‹å’Œç­‰äº targetSum çš„ è·¯å¾„ çš„æ•°ç›®ã€‚
è·¯å¾„ ä¸éœ€è¦ä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œä¹Ÿä¸éœ€è¦åœ¨å¶å­èŠ‚ç‚¹ç»“æŸï¼Œä½†æ˜¯è·¯å¾„æ–¹å‘å¿…é¡»æ˜¯å‘ä¸‹çš„ï¼ˆåªèƒ½ä»çˆ¶èŠ‚ç‚¹åˆ°å­èŠ‚ç‚¹ï¼‰ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: å‰ç¼€å’Œ

    # 
    def pathSum(self, root: TreeNode, targetSum: int) -> int:

        if not root:
            return 0

        res = 0
        def dfs(root, preSum):
            nonlocal res
            if not root:
                return
            for i in range(len(preSum)):
                preSum[i] += root.val
            preSum.append(root.val)
            for i in preSum:
                if i == targetSum:
                    res += 1
            dfs(root.left, preSum[:])
            dfs(root.right, preSum[:])

        dfs(root, [])
        return res
    
#### 2. éé€’å½’
æ€è·¯ï¼š       
    
## 449. åºåˆ—åŒ–å’Œååºåˆ—åŒ–äºŒå‰æœç´¢æ ‘
é¢˜ç›®ï¼šåºåˆ—åŒ–æ˜¯å°†æ•°æ®ç»“æ„æˆ–å¯¹è±¡è½¬æ¢ä¸ºä¸€ç³»åˆ—ä½çš„è¿‡ç¨‹ï¼Œä»¥ä¾¿å®ƒå¯ä»¥å­˜å‚¨åœ¨æ–‡ä»¶æˆ–å†…å­˜ç¼“å†²åŒºä¸­ï¼Œæˆ–é€šè¿‡ç½‘ç»œè¿æ¥é“¾è·¯ä¼ è¾“ï¼Œä»¥ä¾¿ç¨ååœ¨åŒä¸€ä¸ªæˆ–å¦ä¸€ä¸ªè®¡ç®—æœºç¯å¢ƒä¸­é‡å»ºã€‚
è®¾è®¡ä¸€ä¸ªç®—æ³•æ¥åºåˆ—åŒ–å’Œååºåˆ—åŒ– äºŒå‰æœç´¢æ ‘ ã€‚ å¯¹åºåˆ—åŒ–/ååºåˆ—åŒ–ç®—æ³•çš„å·¥ä½œæ–¹å¼æ²¡æœ‰é™åˆ¶ã€‚ æ‚¨åªéœ€ç¡®ä¿äºŒå‰æœç´¢æ ‘å¯ä»¥åºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸²ï¼Œå¹¶ä¸”å¯ä»¥å°†è¯¥å­—ç¬¦ä¸²ååºåˆ—åŒ–ä¸ºæœ€åˆçš„äºŒå‰æœç´¢æ ‘ã€‚
ç¼–ç çš„å­—ç¬¦ä¸²åº”å°½å¯èƒ½ç´§å‡‘ã€‚
### ä¸¤ç§æ–¹æ³•ï¼š1ã€é€’å½’å®ç°ï¼Œ2. éé€’å½’å®ç°(é˜Ÿåˆ—)
#### 1. é€’å½’
æ€è·¯: åºåˆ—åŒ–å‰åºï¼Œååºåˆ—åŒ–æ—¶ç”±å‰åºå¾—åˆ°ä¸­åºï¼Œç„¶åå‰åºï¼Œä¸­åºæ„å»ºäºŒå‰æ ‘ã€‚

    # 
    def pathSum(self, root: TreeNode, targetSum: int) -> int:

        if not root:
            return 0

        res = 0
        def dfs(root, preSum):
            nonlocal res
            if not root:
                return
            for i in range(len(preSum)):
                preSum[i] += root.val
            preSum.append(root.val)
            for i in preSum:
                if i == targetSum:
                    res += 1
            dfs(root.left, preSum[:])
            dfs(root.right, preSum[:])

        dfs(root, [])
        return resclass Codec:

    def serialize(self, root: TreeNode) -> str:
        """Encodes a tree to a single string.
        """
        str1 = ''
        def dfs(root):
            nonlocal str1
            if not root:
                return
            str1 += ' ' + str(root.val)
            dfs(root.left)
            dfs(root.right)
        dfs(root)
        return str1
        

    def deserialize(self, data: str) -> TreeNode:
        """Decodes your encoded data to tree.
        """
        preOrder = []
        for d in data.split(' '):
            if d:
                preOrder.append(int(d))
        inOrder = [p for p in preOrder]
        inOrder.sort()

        # å‰åºã€ä¸­åºæ„å»ºäºŒå‰æ ‘
        def dfs(preOrder, inOrder):
            if not preOrder or not inOrder:
                return
            root = TreeNode(preOrder[0])
            index = inOrder.index(preOrder[0])
            root.left = dfs(preOrder[1:index+1], inOrder[0:index])
            root.right = dfs(preOrder[index+1:], inOrder[index+1:])
            return root

        return dfs(preOrder, inOrder)
    
#### 2. éé€’å½’
æ€è·¯ï¼š       
     
