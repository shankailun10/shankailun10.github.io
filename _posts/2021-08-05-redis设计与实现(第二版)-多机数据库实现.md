# redis多机数据库实现
1. TOC
{:toc}
## 1、主从复制
redis中，用户可以通过执行SLAVEOF master_ip port 命令或设置slaveof配置选项，让一个redis服务器去复制(replicate)
另一台redis服务器的数据, 被复制的服务器为主服务器(master)，复制的服务器为从服务器(slave)。
数据一致性：主服务器和从服务器保持着相同的数据。
### 1.1 旧版复制功能的实现(redis2.8之前)
redis服务器的复制功能分为同步(sync)和命令传播(command propagate)两步。其中同步操作用于将从服务器的数据库状态
更新为和主服务器状态一致；命令传播用于在主服务器数据库状态被修改之后，让主从服务器的数据库状态重新回到一致。
#### 1.1.1 同步
当从服务器使用SLAVEOF master_ip port 命令绑定主服务器并从主服务器复制数据库状态时，从服务器会向主服务器发送
SYNC命令，即执行同步操作。SYNC命令的执行步骤如下：

1. 从服务器向主服务器发送SYNC命令。
2. 主服务器收到SYNC命令之后执行BGSAVE命令，使用子进程在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执
行的写命令。
3. 主服务器的BGSAVE命令执行完毕，主服务器将生成的RDB文件发送给从服务器，从服务器接受文件并载入文件更新数据库
状态。
4. 主服务器将记录在缓冲区里的所有写命令发送给从服务器，从服务器接收并执行这些写命令，将数据库状态更新至主服
务器当前所处状态。

#### 1.1.2 命令传播
同步操作后主从服务器数据库状态暂时保持一致，后续当主服务器继续执行写命令时，主从服务器的数据库状态将发生变化。
此时，主服务器可通过命令传播操作将主从服务器状态再次达到一致。即：主服务器会将后续的写命令发送给从服务器执行，
以便再次达到一致。
### 1.2 旧版复制功能的缺陷
redis中从服务器对主服务器的复制分为初次复制和断线后重复制两种情况。其中初次复制是指从服务器之前没有复制过主
服务器，或当前复制的主服务器和上一次复制的主服务器不一样；断线后重复制是指处于命令传播阶段的主从服务器因为
网络原因中断了复制，后面从服务器通过自动重连接重新连上了主服务器，并继续复制主服务器。旧版的断线后重复制效率
低下，因为断线重连接后从服务器向主服务器发送的是SYNC命令，主服务器收到SYNC命令后会执行BGSAVE命令生成RDB文件并
使用RDB文件进行数据同步，并不是继续使用命令传播操作发送断线期间主服务器执行的所有写命令。另外SYNC命令也是一个
十分耗时的操作，每次执行SYNC命令后主服务器需要执行BGSAVE命令生成RDB文件，生成过程会耗费主服务器大量的CPU、内存
和磁盘I/O资源；然后主服务器要把生成的RDB文件发送给从服务器，发送操作也会耗费主服务器大量的网络资源(带宽和流量)，
并对主服务器响应请求命令的时间产生影响；从服务器接收并载入RDB文件，在载入期间会阻塞导致没有办法处理命令请求。
### 1.3 新版复制功能的实现(redis2.8版本及以上)
redis2.8版本及以上使用PSYNC命令代替SYNC命令，解决旧版复制功能在断线重连后的复制的低效问题。PSYNC命令具有完整
重同步(full resynchronization)和部分重同步(partial resynchronization)两种模式。其中完整重同步执行步骤同SYNC命
令的同步一致；部分重同步用于处于断线后重复制，当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器会
将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器接收并执行这些写命令使主从数据库状态达到一致。
### 1.4 部分重同步的实现
部分重同步包含三个部分：

1.主服务器的复制偏移量(replication offset)和从服务器的复制偏移量；
2.主服务器的复制积压缓冲区(replication backlog)；
3.服务器运行ID(run ID)。

#### 1.4.1 复制偏移量
主服务器和从服务器分别维护一个复制偏移量。其中主服务器每次向从服务器传播N个字节数据时，主服务器的复制偏移量会加
上N；从服务器每次收到主服务器传来N个字节后将自身的复制偏移量加上N。主从服务器通过对比彼此的复制偏移量来决定数据
库状态是否一致，当偏移量相同时则一致，反之则不一致。
#### 1.4.2 复制积压缓冲区
复制积压缓冲区由主服务器维护的一个固定长度(fixed-size)先进先出(FIFO)队列，默认大小1MB。该队列大小固定，不会随着
队列元素数量增加或减少而发生变化。
当主服务器进行命令传播时，一方面会将写命令发送给所有从服务器，另一方面会将写命令加入复制积压缓冲区队列。即:主服
务器的复制积压缓冲区会保存部分最近传播的命令，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量。当从服
务器重新连上主服务器时，从服务器会通过PSYNC命令将自己的服务偏移量offset发送给主服务器，主服务器根据从服务器的复
制偏移量决定对从服务器执行何种同步操作。

1. 若offset偏移量之后的数据(即offset+1开始的数据)仍然存在于复制积压缓冲区里，主服务器对从服务器执行部分重同步操
作。
2. 若offset偏移量之后的数据不存在于复制积压缓冲区，则主服务器才能对从服务器执行完整同步操作。

##### 1.4.2.1 复制积压缓冲区大小
复制积压缓冲区大小默认为1MB，最小大小计算公式(估算)：second * write_size_per_second。其中second为从服务器断线后
重新连接上主服务器所需的平均时间(单位秒)；write_size_per_second为主服务器平均每秒产生的写命令数据量(协议格式的
写命令的长度总和)。如主服务器平均每秒产生1MB写数据，从服务器断线后平均要5秒能重连上主服务器，则复制积压缓冲区大
小不能低于5MB。一般安全起见，复制积压缓冲区大小取值为最小大小的2倍，即：2 * second * write_size_per_second。
#### 1.4.3 服务器运行ID(run ID)
部分重同步还取决与服务器运行ID。运行ID在服务器启动时自动生成，由40个随机16进制字符组成，主从服务器都有自己的运
行ID。当从服务器对主服务器进行初次复制时，主服务器将自己的运行ID传送给从服务器，从服务器将主服务器的运行ID保存起
来。当从服务器断线并重新连上主服务器时，从服务器向当前连接的主服务器发送保存的运行ID。若从服务器保存的运行ID和
当前连接的主服务器的运行ID相同，则表示连接的是断线重连之前的主服务器，则主服务器进行部分重同步操作；若运行ID不
相同，则表示连接的不是断线重连之前的主服务器，则主服务器进行完整重同步操作。
### 1.5 PSYNC命令的实现
PSYNC命令的两种调用方法。

1. PSYNC ? -1 命令。从服务器之前没有连接过主服务器，或从服务器执行了SLAVEOF no one 命令，则从服务器在开始新的复制
时会向主服务器发送 PSYNC ? -1 命令，主动请求主服务器进行完整重同步操作。
2. PSYNC [runid] [offset] 命令。从服务器已经复制过主服务器，在从服务器开始一次新的复制时会向主服务器发送
PSYNC [runid] [offset] 命令，runid是从服务器保存的上次复制的主服务器的运行ID，offset 是从服务器的当前复制偏移量。
主服务器会根据这两个参数来决定对从服务器进行完整重同步还是部分重同步。

主服务器收到PSYNC命令后会给从服务器返回三种回复中的一种。

1. 主服务器返回+FULLRESYNC [runid] [offset]回复，表示主服务器将与从服务器执行完整重同步操作。其中runid为主服务器
运行ID，offset 为主服务器当前的偏移量。从服务器收到回复后将主服务器run ID保存，将主服务器偏移量作为自身的初始化
偏移量。K
2. 主服务器返回+CONTINUE回复，表示主服务器将与从服务器进行部分重同步操作，从服务器只需等待接收并执行主服务器发
来的自身缺少的写命令即可。
3. 主服务器返回-ERR回复，表示主服务器的版本低于redis2.8，识别不了PSYNC命令，从服务器将向主服务器发送SYNC命令，进
行完整重同步操作。

### 1.6 复制的实现
客户端向从服务器发送SLAVEOF命令，让从服务器复制主服务器。命令为：SLAVEOF [master_ip] [master_port]。复制功能详细
实现步骤为:

1. 设置主服务器的地址和端口
2. 建立套接字连接
3. 发送PING命令
4. 身份验证
5. 发送端口信息
6. 同步
7. 命令传播

#### 1.6.1 设置主服务器的地址和端口
当客户端像从服务器发送SLAVEOF [master_ip] [master_port]命令时，从服务器首先会把主服务器的ip地址和端口保存到
redisServer结构体的masterhost属性和masterport属性。

    # 保存主服务器的ip和端口
    struct redisServer{
        //...
        // 主服务器的ip地址
        char *masterhost;
        // 主服务器的端口
        int masterport;
        //...
    }

其中SLAVEOF命令是异步命令，从服务器在完成masterhost和masterport命令设置之后便会向发送SLAVEOF的客户端返回OK命令，
表示复制指令已经被接收，但是实际的复制工作在返回OK之后才开始。
#### 1.6.2 建立套接字连接
在SLVAVEOF命令执行之后，从服务器器根据ip和端口创建向主服务器的套接字连接，如果能成功连接到主服务器，从服务器会为该套接字
关联专门用于复制工作文件事件处理器，负责接下来的复制工作(接收RDB文件、命令传播等)。主服务器在接受从服务器的套接字连接之后
为该套接字创建相应的客户端状态。
#### 1.6.3 发送PING命令
从服务器成为主服务器的客户端之后，首先会向主服务器发送一个PING命令，ping命令的作用有两个，一是因为虽然主从服务器建立了套
接字连接，但是并没有使用套接字进行过通信，可以通过ping命令检查套接字的读写状态是不是正常；二是检查主服务器是否能正常处理
命令请求，以便后续的复制工作正常进行。从服务器发送ping命令之后，主服务器会返回三种命令回复。

1. 如果主服务器给从服务器返回了一个命令回复，但是从服务器不能在规定时间内读取命令回复的内容，表示主从服务器之间的网络连接
状态不佳，不能即逆行后续的复制操作，此时从服务器会断开并重新创建连向主服务器的套接字。
2. 如果主服务器向从服务器返回一个错误，则表示主服务器暂时没办法处理从服务器的命令请求，不能继续后续的复制操作，从服务器会
断开并重新创建连向主服务器的套接字。
3. 若从服务器读取到主服务器返回的pong回复，则表示主从服务器之间的网络建立正常，且主服务器可以正常处理从服务器发来的命令
请求，从服务器可以继续后续的复制操作。

#### 1.6.4 身份验证
从服务器在收到主服务器返回的pong回复之后，接下来根据从服务器配置的masterauth选项决定是否进行身份验证，配置了该选项则进行
身份验证，否则不进行身份验证。若需要身份验证，从服务器向主服务器发送一条auth命令，命令参数是masterauth选项值。从服务器在
身份验证阶段可能会遇到一下几种情况。

1. 主服务器没有设置requirepass选项，且从服务器也没有设置masterauth选项，则主服务器继续执行从服务器发送的命令，继续后续
复制工作。
2. 若从服务器通过auth命令发送的密码和主服务器requirepass选项相同，则主服务器继续执行从服务器发送的命令，继续后续复制工作，
若不相同则返回一个invalid password错误。
3. 若主服务器设置了requirepass选项，从服务器没有设置masterauth选项，则主服务器返回NOAUTH错误；若主服务器没有设置
requirepass选项，从服务器设置了masterauth选项，则主服务器返回 no password is set错误。

一旦发生错误情况，从服务器都会中止目前的复制工作，并重新创建套接字执行复制操作。

#### 1.6.5 发送端口信息
身份验证通过之后，从服务器向主服务器发送 REPLCONF listening-port [port-number] 命令，告知从服务器监听的端口号。主服务器
接收到命令之后会将端口号记录在从服务器对应的客户端状态的 slave_listening_port属性中。该属性目前唯一作用就是在主服务器上执行
info replication时打印出从服务器的监听端口号。

    # 从服务器对应的客户端状态
    typedef struct redisClient{
        //...
        // 从服务器的监听端口号
        int slave_listening_port;
        //...
    }redisClient;

#### 1.6.6 同步
从服务器向主服务器发送psync命令，执行同步操作，将自身的数据库状态更新至主服务器所处的当前数据库状态。
#### 1.6.7 命令传播
在主从服务器完成同步操作之后，主服务器将进入命令传播阶段，在该阶段中主服务器将自身新增的写命令发送给从服务器，从服务器接收并执行
这些写命令，则主从服务器的状态就可以保持一致。
### 1.7 心跳检测
在命令传播阶段，从服务器默认以每秒一次的频率，向主服务器发送 REPLCONF ACK [replication_offset] 命令。告诉主服务器从服务器
当前的复制偏移量。REPLCONF ACK 命令对主服务器有三个作用：

1. 检测主从服务器的网络连接状态。
2. 辅助实现 min-slaves选项。
3. 检测命令丢失。

#### 1.7.1 检测主从服务器的网络连接状态
主从服务器可通过发送和接受REPLCONF ACK命令检查两者之间的网络通*信连接是否正常，若主服务器超过一秒没收到从服务器发来的命令，便知
网络连接有问题。*
#### 1.7.2 辅助实现min-slaves配置选项
redis 的 min-slaves-to-write和min-slaves-max-lag两个选项用来防止主服务器在不安全的情况下执行写命令。比如：

    # 选项配置
    min-slaves-to-write 3
    min-slaves-max-lag 10

则在从服务器数量少于3个，或者3个从服务器的延迟(lag)值都大于等于10秒时，主服务器将拒绝执行写命令，lag为主服务器自上次收到从服务器
发来的REPLCONF ACK命令的间隔时间(正常从服务器一秒发一次，该lag值在0-1之间)。
#### 1.7.3 检测命令丢失
由于网络原因，主服务器发送给从服务器的写命令可能会丢失，但是由于从服务器每一秒会发送REPLCONF ACK命令传递从服务器当前复制偏移量给
主服务器，若从服务器当前的偏移量小于主服务器，则主服务器可以知道命令可能丢失，此时会重新在复制积压缓冲区中找到缺失的命令并发送给从
服务器。复制偏移量是redis2.8版本新增的，之前的版本若发生丢失情况主服务器是无从知晓的。


## 2、Sentinel(哨兵)
sentinel 是redis的高可用性(high availability) 解决方案。由一个或多个Sentinel实例(instance)组成的Sentinel系统可以监视
任意多个主服务器及主服务器下的所有从服务器，当主服务器进行下线时，自动将下线主服务器下的某个从服务器升级为新的主服务器。
### 2.1 Sentinel 的启动和初始化
命令 redis-sentinel /path/to/your/sentinel.conf或命令 redis-server /path/to/your/sentinel.conf --sentinel 用于
启动一个Sentinel，并执行以下几个步骤：

1. 初始化服务器
2. 将普通redis服务器使用的代码代替成Sentinel专用代码。
3. 初始化Sentinel状态。
4. 根据给定的配置文件，初始化Sentinel的监视主服务器列表。
5. 创建连向主服务器的网络连接。

#### 2.1.1 初始化服务器
sentinel是特殊的redis服务器，服务器初始化过程和普通的redis服务器一致，省略了RDB文件或AOF文件的载入等过程。
#### 2.1.2 使用Sentinel专用代码
启动sentinel的过程中，将部分普通的redis服务器使用的代码替换成Sentinel专用代码，比如普通服务器的端口取值为
redis.h/REDIS_SERVERPORT 6379，sentinel使用 sentinel.c/REDIS_SENTINEL_PORT 26379；普通服务器使用
redis.c/redisCommandTable作为服务器的命令表，sentinel使用sentinel.c/sentinelcmds作为命令列表。且
sentinel.c/sentinelcmds命令列表里不包含 SET、DBSIZE、EVAL等这些命令，只包含七个：PING、SENTINEL、INFO、
SUBSCRIBE、UNSUBSCRIBE、PSUBSCRIBE、PUNSUBSCRIBE。
#### 2.1.3初始化Sentinel状态
sentinel状态用sentinel.c/sentinelState结构体表示，如下：

    # Sentinel状态
    struct sentinelState {
        // 当亲纪元，用于实现故障转移
        uint64_t current_epoch;
        // 保存所有被监视的主服务器，字典键是主服务器的名字，值是指向sentinelRedisInstance结构体的指针
        dict *masters;
        // 是否进入TILRT模式
        int tilt;
        // 目前正在执行的脚本的数量
        int running_scripts;
        // 进入TILT模式的时间
        mstime_t tilt_start_time;
        // 最后一次执行时间处理器的时间
        mstime_t previous_time;
        // 一个FIFO队列，包含所有需要执行的用户脚本
        list *scripts_queue;
    }

#### 2.1.4初始化Sentinel状态的masters属性
sentinel状态的masters字典记录了所有被Sentinel监视的主服务器的相关信息。其中，字典的键是主服务器的名字，值是
指向sentinelRedisInstance结构体的指针，每个sentinelRedisInstance结构表示一个被Sentinel监视的实例，实例可以是主服务器、
从服务器、另一个Sentinel。其中sentinelRedisInstance结构如下：

    # sentinelRedisInstance结构
    typedef struct sentinelRedisInsstance{
        // 标识值
        int flags;
        // 实例的名字,主服务器的名字由用户在配置文件中设置，从服务器以及Sentinel的名字由Sentinel自动设置，格式为ip:port
        char *name;
        // 实例的运行ID
        char *runid;
        // 配置纪元，用于实现故障转移
        uint64_t config_epoch;
        // 实例的地址
        sentinelAddr *addr;
        // SENTINEL down-after-milliseconds 选项设定的值
        // 实例无响应多少毫秒之后会被判定为主观下线(subjectively down)
        mstime_t dowm_after_period;
        // SENTINEL monitor <master-name> <IP> <port> <quorum> 选项中的quorum 参数
        // 判断这个实例为客观下线(objectively down)所需的支持投票数量
        int quorum;
        // SENTINEL failover-timeout <master0-name> <ms> 选项的值
        // 刷新故障迁移状态的最大时限
        mstime_t failover_timeout;
        // ...
        
    }sentinelRedisinstance;

其中sentinelAddr保存实例的ip地址和端口号

    # sentinelAddr结构
    typedef struct sentinelAddr{
        char *ip;
        int port;
    }sentinelAddr;

#### 2.1.5 创建连向主服务器的网络连接
sentinel初始化最后一步，创建连向被监视主服务器的网络连接，Sentinel将成为主服务器的客户端，向主服务器发送命令，并接收主服务器
的命令回复。Sentinel会创建两个连向主服务器的异步网络连接。一是命令连接，用于向主服务器发送命令，并接收命令回复；二是订阅连接，
用于专门订阅主服务器的__sentinel__:hello频道。
### 2.2 获取主服务器的信息
Sentinel默认没10秒向被监视的主服务器的发送INFO命令，通过分析INFO命令的回复获取主服务器的当前信息。INFO命令回复包括：主服务器
的信息，运行ID,角色master等，及从服务器的ip:port。
### 2.3 获取从服务器信息
当Sentinel发现主服务器有新的从服务器出现时，Sentinel会为新的从服务器创建实例结构，并创建一个连接到从服务器的命令连接和订阅连接。
### 2.4 向主服务器和从服务器发送信息
sentinel默认情况下以每2秒一次的频率，通过命令连接向所有被监视主从服务器发送一条命令:
PUBLISH __sentinel__hello "[s_ip], [s_port], [s_runid], [s_opoch], [m_name], [m_ip], [m_port], [m_epoch]",
该命令向服务器 的__sentinel__:hello频道发送一条信息，其中s_开头是sentinel自身的信息，m_开头的是主服务器的信息。s_ip、s_port：
sentinel的ip和端口，s_runid：sentinel的运行ID,s_opoch:Sentinel当前的配置纪元；m_name：主服务哦的名字，m_ip、m_port：主
服务器的ip和端口，m_epoch主服务器当前的配置纪元。
### 2.5 接收来自主服务器和从服务器的频道信息
Sentinel与主从服务器建立起订阅连接之后，Sentinel会通过订阅连接向服务器发送一下命令：
SUBSCRIBE __sentinel__:hello,Sentinel对__sentinel__:hello频道的订阅会一直持续到Sentinel与服务器的连接断开。Sentinel既
通过命令连接向服务器__sentinel__:hello频道发送信息，又通过订阅连接从__sentinel__:hello频道接收信息。当一个Sentinel向频道发送
信息时，所有订阅了__sentinel__:hello的Sentinel都会收到相关信息，并根据返回的信息更新对应的主服务器的实例结构。
####  2.5.1 更新sentinels字典
sentinels字典保存了监听同样主服务器的Sentinel的信息，其中sentinels的键是Sentinel名字，格式为ip:port,sentinels的值是键所对应
Sentinel的实例结构，当一个Sentinel(目标Sentinel)接收到其他Sentinel(源Sentinel)发来的信息时，目标Sentinel会从信息中提取两方面
的信息：一是与Sentinel有关的参数，即源Sentinel的IP地址、端口号、运行ID和配置纪元；二是与主服务器有关的参数，即源Sentinel正在监视
的主服务器的名字，ip地址，端口号和配置纪元。
#### 2.5.2 创建连向其他Sentinel的命令连接
当Sentinel通过频道信息发现一个新的Sentinel时，会为新的Sentinel在sentinels字典中创建一个Sentinel结构,同时还会创建一个连向新
Sentinel的命令连接，新的Sentinel也会创建一个连向当前Sentinel的命令连接。使用命令连接相连的各个Sentinel可以互相发送命令请求进行
信息交换。各Sentinel间只会创建命令连接，不会创建订阅连接，因为，Sentinel需要通过接收主服务器或从服务器发来的频道信息来发现位置的新
Sentinel，所以才会建立订阅连接，而相互连接的sentinel是彼此互知的，因此只需要进行命令连接即可。
### 2.6 检测主观下线
Sentinel默认会以每秒一次的频率向所有与它创建了命令连接的实例(主服务器、从服务器、其他Sentinel)发送ping命令，并通过实例返回的PING
命令回复来判断实例是否在线。回复有有效回复和无效回复两种情况。

1. 有效回复；实例返回+PONG、-LOADING、-MASTERDOWN三种回复的一种。
2. 无效回复：实例返回除以上三种回复之外的其他回复，或在指定时限内没有返回任何回复。

Sentinel配置文件中的down-after-millseconds选项指定了Sentinel判断实例进入主观下线所需的时间长度：如果一个实例在
down-after-milliseconds毫秒内，连续向Sentinel返回无效回复，则Sentinel会修改这个实例所对应的实例结构，在结构的flags属性中打开
SRI_S_DOWN标识，来表示该实例已进入主观下线状态。down-after-millseconds属性不仅适用于Sentinel之间，同样适用于Sentinel用来判断
主服务器和从服务器的标准。不同的Sentinel配置的down-after-millseconds属性值可能不同，当一个达到指定值时只有当前达到指定值的Sentinel
会认为其主观下线。
### 2.7 检测客观下线状态
当Sentinel将主服务器判断为主观下线后，会向其他同样监视该主服务器的Sentinel询问是否真的下线(主观下线或客观下线)，当Sentinel判断下线
的数量达到一定值之后，Sentinel会将主服务器判定为客观下线，并对主服务器执行故障转移操作。
#### 2.7.1 发送SENTINEL is-master-down-by-addr命令
Sentinel使用 SENTINEL is-master-down-by-addr [ip] [port] [current_epoch] [runid] 命令询问其他Sentinel是否已判定主服务器
已下线。其中ip、port为被Sentinel判断为已下线的主服务器的ip地址和端口号，current_epoch为当前的配置纪元，用于选举领头的Sentinel，
runid可以是*符号，或这Sentinel的运行ID，*符号代表明命令仅仅用于检测主服务器的客观下线状态，而Sentinel的运行ID则用于选举领头Sentinel。
#### 2.7.2 接收SENTINEL is-master-down-by-addr命令
当一个Sentinel(目标Sentinel)接收到另一个Sentinel(源Sentinel)发来的SENTINEL is-master-down-by-addr命令时，目标Sentinel会
分析并取出命令请求中包含的各个参数，并根据其中的主服务器ip和端口号，检查主服务器是否已下线，然后向源Sentinel返回一个包含三个参数的
Multit Bulk回复作为SENTINEL is-master-down-by-addr命令的回复。参数一：[down_state], 取值1代表主服务器已下线，取值0代表主服务器
味下线；参数二：[leader_runid],取值*符号代表命令仅用户检测主服务器的下线状态，取值目标Sentinel的运行ID代表选举的Sentinel；参数三：
[leader_epoch],目标Sentinel的局部领头Sentinel的配置纪元，仅当leader_runid不为*时有效。
#### 2.7.3 接收接收SENTINEL is-master-down-by-addr命令的回复
根据其他Sentinel返回的命令回复，Sentinel统计同意主服务器已下线的数量，当这一数量达到配置指定的判断客观下线所需数量时，Sentinel会将
主服务器实例结构flags属性的SRI_O_DOWN标识打开，表示主服务器已进入客观下线状态。
### 2.8 选举领头Sentinel
当一个主服务器被各个Sentinel判断为客观下线时，Sentinel间会协商选举出一个领头Sentinel，并由领头Sentinel对下线主服务器执行故障转移
操作。领头Sentinel选举如下：

1. 所有监视主服务器的Sentinel都有被选举的资格。
2. 每次进行领头Sentinel选举之后，无论成功或失败，所有Sentinel的配置纪元(计数器，默认为0)都会自增一次。
3. 在一个配置纪元中，所有Sentinel都有一次将某个Sentinel设置为局部领头Sentinel的机会，且局部领头一旦设置在该纪元内不能修改。
4. 每个发现主服务器的进入客观下线的Sentinel都会要求其他的Sentinel将自己设置成局部领头Sentinel。即发送
SENTINEL is-master-down-by-addr命令。
5. Sentinel局部领头设置先到先得，之后的要求都会被拒绝。
6. 请求Sentinel收到SENTINEL is-master-down-by-addr命令回复后检查彼此纪元是否相同，相同则取出leadre_runid参数，并检查参数与自身
runID是否相同，相同则表示目标Sentinel将源Sentinel设置成功。
7. 如果某个Sentinel有超过半数以上被设置成为了领头，则该Sentinel就是选举出的领头Sentinel。
8. 若在给定时间内没有选举出领头Sentinel，则过一段时间会重新选举。

### 2.9 故障转移
在选举出领头Sentinel之后，领头Sentinel将对已下线的主服务器执行故障转移操作，包含一下三个步骤：

1. 在已下线的主服务器的从服务器中选举出一个从服务器，将该从服务器转换为主服务器。
2. 让已下线主服务器的所有其他从服务器复制新的主服务器。
3. 将已下线的主服务器设置为新的主服务器的从服务器，当已下线的主服务器重新=上线后，会成为新的主服务器的从服务器，并复制新的主服务器。

### 2.9.1 选出新的主服务器
领头Sentinel从从服务器中选举出一个状态良好，数据完整的从服务器，并向从服务器发送一条SLAVEOF no one 命令，将从服务器转换为主服务器。
领头Sentinel将所有从服务器保存到一个列表中，然后按照过滤条件进行过滤，条件如下：

1. 删除列表中所有处于下线或短线状态的从服务器，保证服务器正常在线。
2. 删除列表中所有最近5秒内没有回复过领头Sentinel的INFO命令的从服务器，保证通信正常。
3. 删除所有与已下线主服务器连接断开超过down-afer-milliseconds * 10 毫秒的从服务器，保证服务器中的数据是比较新的。
4. 按照从服务器的优先级排序，选举出优先级最高的从服务器，若优先级有最高相同的，则选择服务器复制偏移量较大的，若存在相同较大偏移量的则
按照runID排序，选择runID较小的。

### 2.9.2 修改从服务器的复制目标
当新的主服务器选举出现后，领头Sentinel会将所有剩下的从服务器取复制新的主服务器，领头Sentinel通过向从服务器发送
SLVAEOF [master_ip] [master_port]命令实现。
### 2.9.3 将旧的主服务器变为从服务器
故障转移的最后一部是将旧的主服务器变为从服务器，因为主服务器已经下线，不能通过发送SLAVEOF命令实现，一次会先修改Sentinel的旧的主服务器
对应的实例结构，等旧的主服务器上线后，再次执行SLVAEOF [master_ip] [master_port]命令。


















































