# redis数据结构与对象
1. TOC
{:toc}
## 简单动态字符串（simple dynamic string, SDS）
### 1、用途
保存redis数据库的字符串值，和作为缓冲区使用(AOF模块的AOF缓冲区，和客户端状态的输入缓冲区)
### 2、定义
SDS 用 sds.h/sdshdr 结构体表示

    # SDS 结构体
    struct sdshdr {
        // 记录 buf 数组中已使用字节的数量, 等于 SDS 所保存字符串的长度
        int len;
        // 记录 buf 数组中未使用字节的数量
        int free;
        // 字节数组，用于保存字符串
        char buf[];
    };
   
### 3、API

1. sdsnew 创建一个sds, o(n)，n为sds字符串长度
2. sdsempty 创建一个空的sds, o(1)
3. ...

### 4、SDS 与 C 字符串的区别
#### 4.1 常数复杂度获取字符串长度
  c 字符串使用 n+1 长度的字符数组表示长度为 n 的字符串，最后一位是空字符'\0'，c 字符串不记录字符串的长度，获取c 字符串长度时间复杂度 o(n)，SDS 结构中记录字符串的长度，获取长度时间复杂度o(1)。
#### 4.2 杜绝缓冲区溢出
  c 字符串由于不记录长度，容易导致缓冲区溢出(buffer overflow)，如使用string.h/strcat(char* dest, const char* str)进行字符串拼接时，没有为dest分配足够的空间容纳str，导致拼接后str覆盖掉dest后面空间的内容，产生问题。SDK 中strcat()函数在执行时会先判断dest空间是否足够，不够时先进行扩展再进行拼接。
#### 4.3 减少修改字符串时带来的内存重分配次数
  c 字符串由于不记录长度，对于一个长度为 n 的字符串底层实现是用长度为 n+1 的字符数组，每次增加字符串或减小字符串长度前，程序都要对 c 字符串的底层字符数组进行内存重分配(重新申请一块较大的内存空间，把旧的字符数组空间数据和新增加或较少的数据放进新的内存空间)。如果是增长字符串操作，那么在执行前都要手动扩展底层字符数组的空间大小，若没有这一步就很有可能产生缓冲区溢出；如果是减小字符串操作，那么在执行前都要手动释放底层字符数组的空间大小，若没有这一步就很有可能产生内存泄漏；内存重分配涉及较复杂算法(系统调用等)，是一个比较耗时的操作。SDS 通过增加 free 未使用空间解除字符串长度和底层字符数组之间的关联，尽可能较少内存重分配的次数。
#### 4.4 空间预分配
  空间预分配用于优化 SDS 字符增长的操作，当 SDS API 对SDS字符空间进行修改并且需要对SDS空间进行扩展时，SDS 不仅会分配必要的空间，而且还会分配额外的未使用空间。未使用空间分配策略：如果进行修改之后所占用的内存空间(len)小于1MB，则未使用空间的大小为修改之后所占用的内存空间(len)；如果进行修改之后所占用的内存空间(len)大于等于1MB，则未使用空间的大小为1MB。通过空间预分配可以减少内存重分配次数，提高性能。
#### 4.5 惰性空间释放
  惰性空间释放用于优化 SDS 字符缩短的操作，当 SDS API 对SDS字符空间进行修改并且需要对SDS空间进行释放时，SDS 不仅立即对空间进行释放，而是通过增加free 未使用空间的大小，等待将来使用。并且SDS提供了专门用于释放未使用空间的API，不用担心惰性空间释放会带来内存浪费，惰性空间释放同样减少了内存重分配次数。
#### 4.6 二进制安全
  c 字符串的字符必须符合某种编码(如ASCII)，且必须以空字符'\0'结尾，字符串中间不能包含空字符'\0'，否则读取会断掉，这使得 c 字符串只能保存文本数据，不能保存图片、音视频、压缩文件等二进制数据。SDS 所有的API操作都是二进制安全(binary-safe)的，SDS API 在处理buf字符数组时以二进制形式处理，保存是什么样读取出来还是什么样。
#### 4.7 兼容 C 字符串
  SDS buf 数组保留了以空字符'\0'结尾的惯例，可以直接重用 c字符串的一些处理函数。
  
## 链表(list)
### 1、用途
链表在redis中使用十分广泛，比如列表键的底层实现之一(数组内容比较大时会转换为链表，或者数组中的元素比较大时也会转换为链表)，发布与订阅、慢查询、监视器等功能也用到了链表，redis链表保存多个客户端的状态信息，以及使用链表构建客户端的输出缓冲区(output buffer)。          
### 2、定义
链表结构 用 adlist.h/listNode 结构体表示

    # 双端链表 结构体
    typedef struct listNode {
        // 前置节点
        struct listNode *prev;
        // 后置节点
        struct listNode *next;
        // 节点的值
        void *value;
    } listNode;
    
链表 使用 adlist.h/list 结构体持有链表

    # 双端链表 结构体
    typedef struct list {
        // 表头节点
        listNode *head;
        // 表尾节点
        listNode *tail;
        // 链表所包含的节点数量
        unsigned long len;
        
        // 节点值复制函数
        void *(*dup)(void *ptr);
        // 节点值释放函数
        void (*free)(void *ptr);
        // 节点值对比函数
        int (*match)(void *ptr, void *key);
    } list;
    
### 3、API

1. listLength 返回链表长度, o(1)
2. listCreate 创建一个空的链表, o(1)
3. ...

## 跳跃表(skiplist)
### 1、用途
跳跃表是一种有序数据结构，通过在一个节点中维持多个指向其他节点的指针，从而达到快速访问的目的。 时间复杂度最快O(log n)， 最坏情况下o(n)， 空间复杂度o(n)。大部分情况下和平衡树媲美，且实现起来比平衡树要容易一些，一次很多地方用跳跃表来代替平衡树。 跳跃表在redis中只有两处用到，一为有序集合键的底层实现之一(当有序集合键包含的元素数量过多或元素包含的字符串过长时)；二是在集群节点中当做内部数据结构来使用。 
### 2、定义
跳跃表节点 用 redis.h/zskiplistNode 结构体表示

    # 跳跃表节点 结构体
    typedef struct zskiplistNode {
        // 后退指针
        struct zskiplistNode *backward;
        // 分值
        double score;   
        // 成员对象
        robj *obj;
        
        // 层
        struct zskiplistLevel {
            // 前进指针
            struct zskiplistNode *forward;
            // 跨度
            unsigned int span;
        } level[];
    } zskiplistNode;
    
跳跃表链表 使用 redis.h/zskiplist 结构体持有链表

    # 跳跃表链表 结构体
    typedef struct zskiplist {
        // 表头节点和表尾节点
        struct zskiplistNode *header, *tail;
        // 表中节点的数量
        unsigned long length;
        // 表中层数最大的节点的层数
        int level;
    } zskiplist;
    
### 3、API

1. zslInsert 向跳跃表插入一个节点, 最好o(log n)，最坏o(n)
2. zslCreate 创建一个新的链表, o(1)
3. ...

## 压缩列表(ziplist)
### 1、用途
压缩列表是列表键和哈希键的底层实现之一。 当列表键只包含少量列表项，并且列表项是小整数值或是较短的字符串时，redis 使用压缩列表实现列表键。当哈希键只包含少量键值对，且哈希键的键和值是小整数值或者较短的字符串时，redis 使用压缩列表作为哈希键的底层实现。
### 2、定义
压缩列表是 redis 为解约内存而开发，由一系列特殊编码的连续内存块组成的顺序性(sequential)数据结构。一个压缩列表可保存任意多个节点(entry)，每个节点可以保存一个字节数组或者一个整数值。
压缩列表格式如下：

| zlbytes | zltail | zllen | entry1 | entry2 | ... | entryn | zlend |
|-|-|-|-|-|-|-|-|
|共4字节，记录压缩列表占用的内存字节数，内存重分配或计算zlend时使用 |共4字节，记录压缩列表表尾距离表头多少个字节，通过该字段可直接访问到表尾 |共2个字节，记录压缩列表节点的数量，当zllen值<65535时，zllen值为节点数量，当zllen=65535时，节点数量值需要遍历压缩列表得出 |节点1|节点2|...|节点n(字符数组或整数值)|共1字节，用于标记压缩列表的末端|

压缩列表节点可以保存一个字符数组或一个整数值，字符数组长度有三种可以选择(<=2^6-1，<=2^14-1，<=2^32-1)。
压缩列表节点格式如下：

| previous_entry_length | encoding | content |
|-|-|-|
|共1字节或5字节，记录列表节点前一个节点的长度 |共1字节或2字节或5字节，记录content保存数据的类型和长度 |节点值，字符数组或一个整数值，值的类型和长度有encoding决定|

### 连锁更新
当压缩列表中的节点长度有恰好㓟连续多个<=2^6-1字节长时，其后置节点的previous_entry_length为1字节，此时如果在列表表头插入一个(2^6-1, 2^14-1]字节长度的节点时，新节点的后置节点previous_entry_length由一字节变为5字节(内存重分配)，同理第二个后置节点previous_entry_length内存重分配记录其前置节点的长度。删除节点同理，会引起内存连锁释放。

### 4、API

1. ziplistPush 创建一个给定值的节点，并将这个节点添加到压缩列表表头或表尾, 平均(o(n))，最坏o(n^2)
2. ziplistNew 创建一个新的压缩列表, o(1)
3. ziplistPush 、 ziplistInsert 、 ziplistDelete 和 ziplistDeleteRange 四个函数都有可能会引发连锁更新， 所以它们的最坏复杂度都是 O(N^2)
4. ...



