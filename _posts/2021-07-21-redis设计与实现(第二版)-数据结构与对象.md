# redis数据结构与对象
1. TOC
{:toc}
## 简单动态字符串（simple dynamic string, SDS）
### 1、用途
保存redis数据库的字符串值，和作为缓冲区使用(AOF模块的AOF缓冲区，和客户端状态的输入缓冲区)
### 2、定义
SDS 用 sds.h/sdshdr 结构体表示

    # SDS 结构体
    struct sdshdr {
        // 记录 buf 数组中已使用字节的数量, 等于 SDS 所保存字符串的长度
        int len;
        // 记录 buf 数组中未使用字节的数量
        int free;
        // 字节数组，用于保存字符串
        char buf[];
    };
   
### 3、API

1. sdsnew 创建一个sds, o(n)，n为sds字符串长度
2. sdsempty 创建一个空的sds, o(1)
3. ...

### 4、SDS 与 C 字符串的区别
#### 4.1 常数复杂度获取字符串长度
  c 字符串使用 n+1 长度的字符数组表示长度为 n 的字符串，最后一位是空字符'\0'，c 字符串不记录字符串的长度，获取c 字符串长度时间复杂度 o(n)，SDS 结构中记录字符串的长度，获取长度时间复杂度o(1)。
#### 4.2 杜绝缓冲区溢出
  c 字符串由于不记录长度，容易导致缓冲区溢出(buffer overflow)，如使用string.h/strcat(char* dest, const char* str)进行字符串拼接时，没有为dest分配足够的空间容纳str，导致拼接后str覆盖掉dest后面空间的内容，产生问题。SDK 中strcat()函数在执行时会先判断dest空间是否足够，不够时先进行扩展再进行拼接。
#### 4.3 减少修改字符串时带来的内存重分配次数
  c 字符串由于不记录长度，对于一个长度为 n 的字符串底层实现是用长度为 n+1 的字符数组，每次增加字符串或减小字符串长度前，程序都要对 c 字符串的底层字符数组进行内存重分配(重新申请一块较大的内存空间，把旧的字符数组空间数据和新增加或较少的数据放进新的内存空间)。如果是增长字符串操作，那么在执行前都要手动扩展底层字符数组的空间大小，若没有这一步就很有可能产生缓冲区溢出；如果是减小字符串操作，那么在执行前都要手动释放底层字符数组的空间大小，若没有这一步就很有可能产生内存泄漏；内存重分配涉及较复杂算法(系统调用等)，是一个比较耗时的操作。SDS 通过增加 free 未使用空间解除字符串长度和底层字符数组之间的关联，尽可能较少内存重分配的次数。
#### 4.4 空间预分配
  空间预分配用于优化 SDS 字符增长的操作，当 SDS API 对SDS字符空间进行修改并且需要对SDS空间进行扩展时，SDS 不仅会分配必要的空间，而且还会分配额外的未使用空间。未使用空间分配策略：如果进行修改之后所占用的内存空间(len)小于1MB，则未使用空间的大小为修改之后所占用的内存空间(len)；如果进行修改之后所占用的内存空间(len)大于等于1MB，则未使用空间的大小为1MB。通过空间预分配可以减少内存重分配次数，提高性能。
#### 4.5 惰性空间释放
  惰性空间释放用于优化 SDS 字符缩短的操作，当 SDS API 对SDS字符空间进行修改并且需要对SDS空间进行释放时，SDS 不仅立即对空间进行释放，而是通过增加free 未使用空间的大小，等待将来使用。并且SDS提供了专门用于释放未使用空间的API，不用担心惰性空间释放会带来内存浪费，惰性空间释放同样减少了内存重分配次数。
#### 4.6 二进制安全
  c 字符串的字符必须符合某种编码(如ASCII)，且必须以空字符'\0'结尾，字符串中间不能包含空字符'\0'，否则读取会断掉，这使得 c 字符串只能保存文本数据，不能保存图片、音视频、压缩文件等二进制数据。SDS 所有的API操作都是二进制安全(binary-safe)的，SDS API 在处理buf字符数组时以二进制形式处理，保存是什么样读取出来还是什么样。
#### 4.7 兼容 C 字符串
  SDS buf 数组保留了以空字符'\0'结尾的惯例，可以直接重用 c字符串的一些处理函数。
  


