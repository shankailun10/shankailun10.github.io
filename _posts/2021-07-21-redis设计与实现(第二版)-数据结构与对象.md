# redis数据结构与对象
1. TOC
{:toc}
## 简单动态字符串（simple dynamic string, SDS）
### 1、用途
保存redis数据库的字符串值，和作为缓冲区使用(AOF模块的AOF缓冲区，和客户端状态的输入缓冲区)
### 2、定义
SDS 用 sds.h/sdshdr 结构体表示

    # SDS 结构体
    struct sdshdr {
        // 记录 buf 数组中已使用字节的数量, 等于 SDS 所保存字符串的长度
        int len;
        // 记录 buf 数组中未使用字节的数量
        int free;
        // 字节数组，用于保存字符串
        char buf[];
    };
   
### 3、API

1. sdsnew 创建一个sds, o(n)，n为sds字符串长度
2. sdsempty 创建一个空的sds, o(1)
3. ...

### 4、SDS 与 C 字符串的区别
#### 4.1 常数复杂度获取字符串长度
  c 字符串使用 n+1 长度的字符数组表示长度为 n 的字符串，最后一位是空字符'\0'，c 字符串不记录字符串的长度，获取c 字符串长度时间复杂度 o(n)，SDS 结构中记录字符串的长度，获取长度时间复杂度o(1)。
#### 4.2 杜绝缓冲区溢出
  c 字符串由于不记录长度，容易导致缓冲区溢出(buffer overflow)，如使用string.h/strcat(char* dest, const char* str)进行字符串拼接时，没有为dest分配足够的空间容纳str，导致拼接后str覆盖掉dest后面空间的内容，产生问题。SDK 中strcat()函数在执行时会先判断dest空间是否足够，不够时先进行扩展再进行拼接。
#### 4.3 减少修改字符串时带来的内存重分配次数
  c 字符串由于不记录长度，对于一个长度为 n 的字符串底层实现是用长度为 n+1 的字符数组，每次增加字符串或减小字符串长度前，程序都要对 c 字符串的底层字符数组进行内存重分配(重新申请一块较大的内存空间，把旧的字符数组空间数据和新增加或较少的数据放进新的内存空间)。如果是增长字符串操作，那么在执行前都要手动扩展底层字符数组的空间大小，若没有这一步就很有可能产生缓冲区溢出；如果是减小字符串操作，那么在执行前都要手动释放底层字符数组的空间大小，若没有这一步就很有可能产生内存泄漏；



